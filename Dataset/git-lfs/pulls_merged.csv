pull_request,number_of_commits,number_of_comments,number_of_reviews,user_type,user_login,merged_at,number_of_additions,number_of_deletions,number_of_files_changed,number_of_days,message,number_of_characters,second_line_is_blank,language,number_of_test_files
2809,5,0,5,Internals,technoweenie,2018-01-08T20:52:07Z,557,164,27,2,"This is a follow-up to #2806, finally teaching the `tq.TransferQueue` to pass on the refspec to the server.",107,False,en,12
2806,12,0,4,Internals,technoweenie,2018-01-05T01:34:08Z,80,52,5,0,"This started as a rewrite of #2774 against new master (due to lots of conflicts with the progress meter in #2762). However, I decided to keep it scoped to just running multiple transfer queues, leaving the actual refspec-sending stuff to a follow up PR. I think that'll make this easier to review.

* While `commands.uploadContext` is an internal type, I'm trying to use exported functions in `commands`, outside of the actual `uploadContext` type. Also, some functions were moved to the `uploadContext` type, instead of merely accepting one as an argument. There's certainly more to be done with `*uploadContext`, but I'd rather do that in a specific refactor PR.
* `*tq.TransferQueue` now flushes the latest update, but doesn't close the Meter's internal channel. This is so there's only 1 line in the output, instead of 1 per ref. I'm open to having a single meter line per ref, but I think that should come with the upload output changes instead.
* `(*uploadContext) Await()` has been broken up into `CollectErrors(*tq.TransferQueue)` and `ReportErrors()`. This is so `CollectErrors()` can be called after each uploaded ref.",1128,True,en,0
2797,1,0,0,Internals,b4mboo,2017-12-21T03:20:45Z,1,0,1,0,"LFS locking is currently only verified by the client. The server APIs just returned what paths are locked, while the client controls whether you can push or not. This change allows to set `lfs.locksverify` in a *./.lfsconfig* file which LFS will automatically pick up for all users of the repo.

Without defining `lfs.locksverify` as a safe key, the client will output a warning and simply ignore the setting.
",410,True,en,0
2796,7,1,0,Internals,ttaylorr,2018-01-03T23:37:05Z,110,7,3,14,"This pull request adds a new flag to the `git lfs ls-files` command, `--all` to scan for _all_ LFS objects in a repository, not just those at the given reference (or HEAD, by default).

This feature was requested by @emericv in https://github.com/git-lfs/git-lfs/issues/2575:

> There is a way to have the whole LFS object sha256 list from a git repo? (like a git-lfs ls-files, but including modified/deleted objects refs of all branchs/tags).

@technoweenie suggested in https://github.com/git-lfs/git-lfs/issues/2575#issuecomment-328909675 to use `ScanRefWithDeleted`, but I think that `--all` may be sufficient (ignoring reference arguments). That said, it might be worth expanding this to cover:

1. `--all`: the entire repository, ignoring the explicit reference argument.
2. `--deleted`: the entire reference space, showing deleted objects (via `ScanTreeWithDeleted()`). 

EDIT: I implemented the above in c4d5f495.

Closes: https://github.com/git-lfs/git-lfs/issues/2575.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2575",1048,True,en,1
2795,6,0,0,Internals,ttaylorr,2017-12-19T22:36:05Z,69,11,3,0,"⚠️ This pull request is based upon https://github.com/git-lfs/git-lfs/pull/2794, and an inter-diff is available [here][1].

##

This pull request teaches `git lfs ls-files` to show tracked LFS objects that are present in the index, which may or may not appear in a tree, as was suggested by @aleb in https://github.com/git-lfs/git-lfs/issues/2705:

> Currently `git lfs ls-files` by default lists the files at the current HEAD, but excluding the new files in the staging area. This is inconsistent with the behaviour of `git ls-files` which by default lists also the new files in the staging area.
> 
> It would be nice to fix this inconsistency:

To accomplish this, we print the set intersection of all LFS objects scanned from the tree (using the `gitscanner`'s `ScanTree()` method), and all LFS objects found in the index (using the `gitscanner`'s `ScanIndex()` method). The later adds an amount of computation proportional to the size of the index, with a constant factor of spawning the necessary `git-diff-index(1)` programs.

Making this work required a few other changes:

1. da94a63: always prefer the destination SHA-1 when scanning the results from `git-diff-index(1)`. This behavior was introduced in https://github.com/git-lfs/git-lfs/pull/137 (via: https://github.com/git-lfs/git-lfs/commit/aa8cea0f98ae4bd5c41c7eb2733a27bc78451468), but is unnecessary as far as I can tell (@rubyist, please correct me if I am wrong).
2. 7efde39: prefer results from the cache before taking the diff-index outside of the cache. This ordering makes more sense for both users of `ScanIndex()` (currently: `git lfs fsck`, `git lfs ls-files`).

Finally, we can apply e271768, and include the results from scanning the index as well as the tree to include _all_ LFS objects in the same manner as `git ls-files`.

Closes: https://github.com/git-lfs/git-lfs/issues/2705.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2705

[1]: https://github.com/git-lfs/git-lfs/compare/c3418c5...4abc433",2003,True,en,1
2794,4,0,0,Internals,ttaylorr,2017-12-19T22:35:26Z,11,18,2,0,"This pull request teaches `git lfs ls-files` how to behave correctly when run in a repository before an initial commit has been made.

Previously, in a repository with no commits (and therefore, no `HEAD` reference), the behavior of `git lfs ls-files` was such:

```
~/D/new-repo $ git init
Initialized empty Git repository in /Users/ttaylorr/Desktop/new-repo/.git/
~/D/new-repo $ git lfs ls-files
Git can't resolve ref: ""HEAD""
```

whereas now, it behaves as follows:

```
~/D/new-repo $ git init
Initialized empty Git repository in /Users/ttaylorr/Desktop/new-repo/.git/
~/D/new-repo $ git lfs ls-files
~/D/new-repo $ 
```

The above behavior was caused by the fact that `git.CurrentRef()` would try to resolve the `HEAD` reference, when it did not in fact exist. To resolve this, we compare the state of the repository against a SHA-1 constant representing the empty tree (see: git/git.go, `git.RefBeforeFirstCommit`).

We can safely fall back to this SHA-1, since the only error in trying to resolve `HEAD` would occur in bare repositories and repositories without any commits.

This change was introduced for two reasons:

1. Parity with Git's `git-ls-files(1)` builtin.
2. In anticipation of supporting https://github.com/git-lfs/git-lfs/issues/2705 (which will allow `git ls-files` to be run on a repository with objects cached, but absent from any tree).

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2705",1432,True,en,1
2793,1,0,0,Internals,ttaylorr,2017-12-19T22:34:29Z,58,1,3,0,"This pull request adds `--include`, `--exclude` flag arguments to the `git-lfs-ls-files(1)` command, as per discussion in https://github.com/git-lfs/git-lfs/issues/2761#issuecomment-347938964:

> > How about `--pattern`, which works with any pattern that `.gitignore` or `.gitattributes` supports?
> 
> @technoweenie I like this -- what about our standard `--include`, `--exclude` (which would allow searching for one or many files/directories)?

Support for this leverages upon the work done by @technoweenie's work in https://github.com/git-lfs/git-lfs/pull/1696, that one can assign a `filepathfilter.Filter` implementation to the `*lfs.GitScanner`'s `Filter` field, and it will emit only tree entires that match the filter's include and exclude rules, as:

```go
s := lfs.NewGitScanner()
s.Filter = filepathfilter.New(...)
```

Closes: https://github.com/git-lfs/git-lfs/issues/2761

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2761",956,True,en,1
2788,7,0,0,Internals,ttaylorr,2017-12-18T19:26:57Z,155,54,7,3,"This pull request fixes `go tool vet` violations found in Git LFS, and runs `go tool vet` on the same list of packages being tested by any invocation of `script/test`.

@technoweenie's comment in https://github.com/git-lfs/git-lfs/issues/2743#issuecomment-346107557 got me thinking:

> [ ... ]
> 
> In fact, what do you think of adding `go vet` to `script/test`? I doubt it passes now, but I'd like to start nudging lfs towards a standard go codebase.

I think that this is a good idea. `go tool vet` provides useful insight on code _correctness_, not style as opposed to `golint`. I think that correctness of this sort is useful information to know about while testing, so let's do both at the same time.

In doing so, this pull request comes in two parts:

1. https://github.com/git-lfs/git-lfs/compare/7e4013d%5E1...a393bb1: fix current correctness violations found by `go tool vet`.
2. 49de92b: refactor `script/test` to:
  - Accept relative package names or subdirectories (`git`, `./git` respectively) as arguments.
  - Correctly run `go tool vet` over the same set of packages.

I think as a future point of discussion, adding `golint` ([source](https://github.com/golang/lint)) would be fruitful (as perhaps a part of `script/lint`, not `script/test`), but I believe that this discussion is out of the current scope.

## 

/cc @git-lfs/core ",1349,True,en,4
2786,1,0,0,Internals,ttaylorr,2017-12-14T17:29:05Z,28,1,2,0,"This pull request fixes an issue pointed out by @hagami in https://github.com/git-lfs/git-lfs/issues/2772: 

> Before execute git lfs migrate import --everything --include=""*.zip"", git log shows below in my repository.
> 
> [ ... ]
> 
> After execute the command, empty line between ""test"" disappeared.

Here's some background: when parsing a commit, the stage of the encoded commit that we are currently parsing is kept track of. This is to differentiate a line beginning with `parent` when present in a header vs. when present in a commit message. To keep track of this, we use the fact that headers are separated from the commit message by a LF character.

Previously, something like this happened:

```go
for scan.Scan() {
	if len(s.Text()) == 0 {
                finishedHeaders = true
                continue
        }

        // ...
}
```

Which has the unfortunate side-effect of `continue`-ing over the parsing step if an empty newline is present in a commit _message.

To fix this, change `if len(s.Text()) == 0` to `if len(s.Text()) == 0 && !finishedHeaders`, such that the only `continue` happens once during the transition from parsing headers to parsing the commit message.

Closes: https://github.com/git-lfs/git-lfs/issues/2772.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2772",1316,True,en,1
2785,1,0,0,Internals,ttaylorr,2017-12-14T17:28:54Z,75,1,4,0,"This pull request supports `git-rev-list(1)`-style `^`-prefixed refspecs to be passed as arguments to the `git lfs migrate` command(s).

## 

/cc @git-lfs/core ",160,True,en,2
2784,3,0,0,Internals,ttaylorr,2017-12-14T18:06:51Z,23,19,6,0,"This pull request fixes an issue where extra LF characters were appended when re-encoding a migrated commit, causing theoretically idempotent migrations to issue ref updates.

The BNF for the loose commit format<sup>[[1](https://public-inbox.org/git/44D42F0D.3040707@gmail.com/)]</sup> says:

> ```
> Git files data formats
> ======================
>
> OBJECTS
> -------
>
> [ ... ]
>
> <COMMIT>
>   : _deflate_( <OBJECT_HEADER> <COMMIT_CONTENTS> )
>   | <COMPACT_OBJECT_HEADER> _deflate_( <COMMIT_CONTENTS> )
>   ;
>
> <COMMIT_CONTENTS>
>   : ""tree"" <SP> <HEX_OBJ_ID> <LF>
>     ( ""parent"" <SP> <HEX_OBJ_ID> <LF> )*
>     ""author"" <SP>
>       <SAFE_NAME> <SP>
>       <LT> <SAFE_EMAIL> <GT> <SP>
>       <GIT_DATE> <LF>
>     ""committer"" <SP>
>       <SAFE_NAME> <SP>
>       <LT> <SAFE_EMAIL> <GT> <SP>
>       <GIT_DATE> <LF>
>     <LF>
>     <DATA>        # <- *No trailing <LF>*
>   ;
>
> [ ... ]
>
> <DATA>
>   # Uninterpreted sequence of bytes.
>   ;
> ```

This bug was introduced in https://github.com/git-lfs/git-lfs/commit/622f9961cbdce4fb6192dda9c74a26e681bced04, and I suspect it had to do with the implementation of `assertLine`, a helper function used to make assertions about the text in a `*bytes.Buffer` between the readhead and the next `\n` character.

If reading the final line, call `buf.ReadString('\n'), and receive `(""text"", io.EOF)`, which is a valid return value, indicating that there was text ""text"", but that it is the final element of the buffer. If this is the case, the `if err != nil` check ignored the text that _was_ read, and instead failed the test.

I suspect I added a trailing `\n` to silence this error, but this is incorrect as far as Git is concerned.

This patch fixes the `assertLine` helper, removes the extra newline, and updates the appropriate tests.

##

/cc @git-lfs/core 

",1827,True,en,4
2780,9,0,0,Internals,ttaylorr,2017-12-14T17:28:44Z,440,0,30,2,"⚠️ This pull request is based off of the branches `git-odb/tag-parse` and `git-githistory-ref-updater-odb`. An inter-diff is available [here][1].

##

This pull request implements support within the `git/githistory` sub-package for rewriting annotated tags, and thus fixes https://github.com/git-lfs/git-lfs/issues/2679. From my original comment<sup>[[1](https://github.com/git-lfs/git-lfs/issues/2679#issuecomment-349177631)]</sup>:

> To the `--include-ref`, your script adds the _name of the tag_, whereas technoweenie's adds the _name of the reference_ that the tag is attached to. The difference here being, when we build up a table of previous to migrated SHA-1's, the object that is being migrated is stored, but not the tag itself.
> 
> As a concrete example, if tag A has OID 1 and points to a commit with OID 2, the migration index will contain OID 2, but not OID 1, since the OIDs aren't resolved down to the objects that they are pointing at.

Leveraging the fact that `git/odb` can now parse annotated tags (via: https://github.com/git-lfs/git-lfs/pull/2778), this pull request teaches the `*git/githistory.refUpdater` type to special-case local tags, and update create new annotated tags in their place that correctly refer to the migrated objects.

Currently, this breaks signed tags, but a subsequent pull-request will add an `--break-tags`/`--no-break-tags` option that warns when tags are signed.

Closes: https://github.com/git-lfs/git-lfs/issues/2679. 

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2679

[1]: https://github.com/git-lfs/git-lfs/compare/0206853...git-githistory-migrate-atags",1634,True,en,6
2779,1,0,0,Internals,ttaylorr,2017-12-14T17:28:30Z,7,0,3,2,"This pull request teaches the `*git/githistory.refUpdater` to hold a reference to a `*git/odb.ObjectDatabase` in anticipation of having to rewrite (and save new) annotated tags.

##

/cc @git-lfs/core ",201,True,en,1
2778,3,0,0,Internals,ttaylorr,2017-12-14T17:28:20Z,262,0,6,2,"This pull request implements support within the `git/odb` package for reading and writing loose and packed representations of annotated tags.

The process for adding a new object type to the `git/odb` package was as follows:

1. 1e239fe: add a new `ObjectType` constant for `Tag`'s, to be used as a return value for `(*Tag) Type() ObjectType`.
2. b78fa93: implement the `Object` interface on a new concrete type, in this case `*Tag`. By implementing this interface, the `git/odb/pack` sub-package can use it for free, and _automatically read packed representations of the same object type_.
3. 944eaf8: wire up the new implementation to the `*git/odb.ObjectDatabase` type to add convenience APIs for reading/writing the new object type.

##

/cc @git-lfs/core ",760,True,en,3
2773,8,1,0,Internals,technoweenie,2017-12-14T21:41:55Z,313,48,14,7,Implements #2712 for `git lfs [ lock | unlock | locks ]`.,57,False,en,6
2770,1,0,0,Externals,sschuberth,2017-12-05T19:48:28Z,3,2,2,0,"As of [1] goversioninfo supports specifying the icon to embed as part of
versioninfo.json. Use that new mechanism for consistency with specifying
other meta-data fields.

[1] https://github.com/josephspurrier/goversioninfo/pull/17",230,False,en,0
2769,2,1,6,Internals,ttaylorr,2017-12-05T23:33:12Z,36,9,4,0,"This pull request fixes a bug pointed out by @sgoo in https://github.com/git-lfs/git-lfs/issues/2688, where `git lfs migrate info --everything` would fail when run under a bare repository.

The issue occurred because `git-lfs-migrate(1)` assumed that remote references do always exist, which is not the case when operating in a bare repository. (Interestingly, this is not the first time that I have forgotten about bare repositories: c.f., https://github.com/git-lfs/git-lfs/pull/2389, https://github.com/git-lfs/git-lfs/pull/1310).

Normally, this assumption is not error-prone, when the user provides an explicit list of reference to include and not include in a migration. However, when this list is not provided, _and_ the migration is run in a bare repository, the migrator would previously (and incorrectly) include remote references that do not exist.

From the Git documentation<sup>[[1](https://git-scm.com/docs/git-clone#git-clone---bare)]</sup>: 

> `--bare` [...] Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/.

To fix this, we skip the exclusion of remote references when the repository is bare.

Closes https://github.com/git-lfs/git-lfs/issues/2688.

##

/cc @git-lfs/core @sgoo",1286,True,en,2
2767,1,0,0,Internals,ttaylorr,2017-12-05T23:29:29Z,8,0,1,1,"This pull request adds a `Simple()` method to the `*tasklog.Logger` API, which is consistent with other existing methods, and was pointed out by @technoweenie in https://github.com/git-lfs/git-lfs/pull/2757#discussion_r154760580.

##

/cc @git-lfs/core ",253,True,en,0
2764,4,0,6,Internals,ttaylorr,2017-12-04T16:54:28Z,40,3,3,2,"This pull request resolves https://github.com/git-lfs/git-lfs/issues/2763 by adding a `--size` flag to the `git-lfs-ls-files(1)` command, which works as follows:

```
~/repository (master) $ git lfs ls-files --size
d1b2a59fbe * a.dat (8)
```

I'm not sure why we didn't have this feature previously, but to the best of my recollection, we were thinking of adding more complex options to `--size` like `--size=bytes`, `--size=kilobytes`, etc. My thought is that `--size` alone is sufficient (since downstream parsers can understand it easily), but perhaps we'd like to add more than this for command line-viewers to see something more reasonable.

I think that now is a good time to have that discussion, and I'll be more than happy to implement whatever we go with.

Closes: https://github.com/git-lfs/git-lfs/issues/2763.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2763",892,True,en,1
2762,12,2,2,Internals,ttaylorr,2017-12-08T17:42:08Z,265,293,12,8,"This pull request does the scaffolding necessary to, and removes the `*progress.Meter` implementation from package `progress`.

My initial approach with this branch was to copy verbatim the `*progress.ProgressMeter` type from `progress` to package `tq`. This worked fine, but I noticed that it expanded package `tq`'s API significantly, with the majority of API changes coming from `progress.DryRun`, `progress.WithOSEnv`, (etc) options. To mitigate this, my first inclination was to create a sub-package `tq/progress`, which would house these types/functions. Wanting not to create a new package, I removed the progress meter option functions in favor of an options struct, and moved that into the `tq` package directly.

Here's a quick breakdown of what happened:

1. f411d01: merge in the changes from `progress-remove-logger` to avoid a merge conflict later when merging this branch into master.
2. 145d0de, 622c7d3: teach `*ProgressMeter` to respond to the `nil`-receiver, to make it possible to remove `progress.Noop()`, and instead use `(nil)(*progress.Meter`).
3. a549105: remove `progress.Noop()`.
4. fa1d512: since `*ProgressMeter` is the only remaining implementation of `progress.Meter`, remove the `progress.Meter` interface.
5. e35d20f: rename `*progress.ProgressMeter` -> `*progress.Meter` to [avoid stuttering][1].
6. 6521683: to reduce the scope of the `*progress.Meter`-related API, remove option functions in favor of a struct-style instantiation, i,e.,

```go
m := progress.NewMeter(&progress.MeterOption{
        DryRun: false,
        // ...
})
```

7. 54fb383: finally, move `*progress.Meter` to `*tq.Meter`, thus enabling the `progress` package to be removed.

##

/cc @git-lfs/core  

[1]: https://blog.golang.org/package-names#TOC_3.",1759,True,en,0
2759,5,1,0,Internals,ttaylorr,2017-12-05T23:29:04Z,1,69,2,6,"This pull request removes `spinner.go` from package `progress` since it is no longer used within Git LFS (see: https://github.com/git-lfs/git-lfs/pull/2757, https://github.com/git-lfs/git-lfs/pull/2758).

Looking at usage of the exported identifiers in `meter.go` is the only remaining thing to look at in the progress package before it can be removed entirely 🎉 .

##

/cc @git-lfs/core ",391,True,en,0
2758,5,0,4,Internals,ttaylorr,2017-12-05T22:05:47Z,137,19,4,6,"This pull request unifies the formatting of `git-lfs-fetch(1)`'s output, similarly to https://github.com/git-lfs/git-lfs/pull/2757.

Before:

```
~/repository (master) $ git lfs fetch --all
Scanning for all objects ever referenced...
Fetching objects...
✔ 501 objects found, done
Git LFS: (291 of 291 files) 1.1 KB / 1.1 KB, done
```

After:

```
~/repository (master) $ git lfs fetch --all
fetch: Fetching all references...
fetch: 501 object(s) found, done
Git LFS: (501 of 501 files) 1.9 KB / 1.9 KB, done
```

## 

This removes the later of the two remaining uses of the `*progress.Spinner` type, which will allow it to be removed entirely in a subsequent pull request.

Similar to https://github.com/git-lfs/git-lfs/pull/2757:

> Please let me know if you have any thoughts on the formatting of these messages. I tried to make them as similar as I would imagine Git writing them, with these thoughts in mind:
> 
> 1. Lowercase prefix of the command that is being run.
> 2. "", done\n"" on the end (courtesy of `*tasklog.Logger`).
> 3. ~~Use percentages where appropriate, text where otherwise.~~

##

/cc @git-lfs/core ",1123,True,en,1
2757,18,3,10,Internals,ttaylorr,2017-12-05T01:29:13Z,103,80,6,6,"This pull request removes the use of the `*progress.Spinner` type in `git-lfs-prune(1)` in favor of a more consistent logging scheme.

Before:

```
~/example (master) $ git lfs prune
Pruning 1 files, (18 B)tained
✔ 3 local objects, 2 retained, done
✔ Deleted 1 files, done
```

After:

```
~/example (master) $ git lfs prune
prune: 3 local object(s), 2 retained, done
prune: Deleting objects: 100% (1/1), done
```

##

This removes one of two existing uses of the `*progress.Spinner` implementation, and the next pull-request in this series will remove the other use-case, which will allow `*progress.Spinner` to be deleted.

Please let me know if you have any thoughts on the formatting of these messages. I tried to make them as similar as I would imagine Git writing them, with these thoughts in mind:

1. Lowercase prefix of the command that is being run.
2. "", done\n"" on the end (courtesy of `*tasklog.Logger`).
3. Use percentages where appropriate, text where otherwise.

##

/cc @git-lfs/core ",1005,True,en,3
2756,2,0,0,Internals,ttaylorr,2017-12-01T17:40:23Z,127,8,3,3,"This pull request introduces a new `Task` implementation, `*tasklog.SimpleTask`, for logging unrelated messages.

This functionality is required in replacing the usage of `*progress.Spinner` from within the `git-lfs-prune(1)` command. Instead of building domain-specific Task implementations, this pull request proposes the introduction of a string-based Task implementation that logs (and formats) strings without formatting guidelines.

This allows for quick prototyping of new Logger use-cases without the need to build out domain-specific loggers, and is a good fit for use within the `git-lfs-prune(1)` command.

##

/cc @git-lfs/core ",640,True,en,1
2755,1,1,0,Internals,ttaylorr,2017-12-01T17:40:14Z,1,8,1,3,"This pull request changes the behavior of `*tasklog.ProgressTask` to no longer drop updates where the channel write to `ch` would block.

I discovered this issue while tweaking some of the output in the `git-lfs-prune(1)` command to use the new utilities provided by package `tasklog`. Sometimes, when using the `*PercentageTask` implementation provided, the final line would be:

```
<prefix>:   0% (0 of 1)
```

when it instead should have been:

```
<prefix>: 100% (1 of 1)
```

This is due to the non-blocking write that is removed in this pull-request. This is an artifact left over from before https://github.com/git-lfs/git-lfs/commit/fc1faca25aa1942aef8902bd6f1b1790ca6fdfed, when the `*log.Logger` implementation was taught how to discard too-frequent updates.

The old non-blocking write would cause some messages to be dropped in a race-y fashion when combined with this too-frequent filtering. To address this, write all updates, and expect instead that the `*tasklog.Logger` will drop them appropriately.

## 

/cc @git-lfs/core ",1042,True,en,0
2751,2,0,0,Externals,wsprent,2017-11-27T21:42:32Z,36,2,2,4,"Currently `git migrate import` corrupts commit objects which contain empty committer/author names by removing the leading space from the email 

(i.e. `author 'SP' 'SP' <my@email.com> --> author 'SP' <my@email.com>`).

This causes `git fsck` to fail with a 
`missingNameBeforeEmail: invalid author/committer line - missing space before email`
error. (And, I guess, would also mangle names containing consecutive whitespace... ;) )

This PR modifies `Commit.Decode` to grab the identifiers as is, retaining all whitespace.",521,True,en,1
2750,4,0,2,Internals,ttaylorr,2017-12-01T18:03:40Z,64,41,3,8,"This pull request is the second-to-last step in extracting the implementation of `*progress.Meter` from the `progress` package.

In addition to generating formatted updates and sending them to a `*tasklog.Logger` instance, the `*progress.Meter` sends messages to a (now-defunct) `*progressLogger` implementations that writes data to an `*os.File` and calls `(*os.File).Sync()` after each successful write. If any write failed, it handles those errors gracefully.

This component of the `progress` package is more generally applicable and has potential for re-use. Before extracting the implementation of `*progress.Meter`, I'd like to pull this into package `tools`. Doing so requires the following two steps:

1. 3c09710 Fix a Tell Don't Ask violation by removing the `Shutdown()` method from `*progressLogger`.
2. a47d632 Extract and make public an implementation of `*SyncWriter` which will be used in all places where `*progressLogger` once was.

And finally, in 3ef075d, we can make the replacement.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2743",1074,True,en,0
2749,3,1,0,Internals,ttaylorr,2017-11-22T22:25:54Z,103,108,36,0,"This pull request moves CopyCallback (and its friends) out of the `progress` package and into the `tools` package. Since this is based on https://github.com/git-lfs/git-lfs/pull/2747, an inter-diff can be summarized as a4ff7b8.

EDIT: This is the next step in removing the `progress` package, as outlined in https://github.com/git-lfs/git-lfs/issues/2743. Prior to this pull request, `progress` consisted of:

1. The `Progress` interface
2. Implementations of the above as `*progress.Spinner` and `*progress.Meter`.
3. `CopyCallback` (and related utilities).

As it has grown, `CopyCallback`'s use has become less related to the rest of the `progress` package. Since it is used in many locations within Git LFS, this pull request proposes moving it to the `tools` package. I think that since its surface area is small, `CopyCallback`-esque functionality does not warrant an entire package of its own, and it would fit well in its current state within the `tools` package.

Following this pull request, the remainder of `progress` will be moved into the `tasklog` and `tq` packages, thus enabling us to remove the `progress` package entirely. 

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2743",1212,True,en,7
2747,2,1,0,Internals,ttaylorr,2017-11-22T22:25:39Z,75,75,24,0,"This pull request promotes the implementation of a task-based logging system found originally in `git/githistory/log` to a new, top-level package `tlog`.

This accomplishes one of the goals that I proposed in https://github.com/git-lfs/git-lfs/issues/2743#issuecomment-345873955:

> In fewer words, here are some things that I'd like to do:
> 
> 1. [...]
> 2. Move the git/githistory/log package to package log (no longer nested in git/githistory).

However, instead of calling it `log` (confusing with Go's standard library package `log`) or `gitlog` (confusing with `git-log(1)`-related utilities), chosen here is `tlog` for **task**-log. I think that this is a good name since it:

- Isn't easily confused with other functions.
- Makes it a part of the name that this package is ""task""-based, and therefore, provides some synchronicity guarantees.

Since this package contains a mostly-stable API, I feel comfortable promoting this package to live in the `github.com/git-lfs/git-lfs`-namespace. Future goals in https://github.com/git-lfs/git-lfs/issues/2743 support adding new functionality to the `log` package, which is something that I'd like to do after moving the code, and not before.

Tracking: https://github.com/git-lfs/git-lfs/issues/2743

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2743",1317,True,en,4
2746,2,2,0,Internals,ttaylorr,2017-11-22T18:47:05Z,36,1,2,0,"This pull request fixes an issue pointed out by @fortytwoish in https://github.com/git-lfs/git-lfs/issues/2742, where `git lfs status` would not correctly format un-pushed objects, producing the following:

> git lfs status shows
> 
> ```
> $ git lfs status
> On branch master
> Git LFS objects to be pushed to origin/master:
>
>         [...]
>         Content/Maps/Prototypes/Autorunner.umap (%!s(MISSING))
>         [...]
> ```

I broke this in https://github.com/git-lfs/git-lfs/commit/6089d1931 (via: https://github.com/git-lfs/git-lfs/pull/2042), and this issue wasn't caught since we don't have any integration tests covering `git lfs status` running on un-pushed objects. In this pull request, such a test is added, along with a fix to remove the `(%!s(MISSING))` verb issue.

Closes: https://github.com/git-lfs/git-lfs/issues/2742

##

/cc @git-lfs/core @fortytwoish",875,True,en,1
2739,1,0,0,Internals,ttaylorr,2017-11-20T17:44:56Z,29,22,2,2,"This pull request fixes an issue pointed out by @phord via https://github.com/git-lfs/git-lfs/issues/2655:

> I have a large repo with 45000 refs. When I first tried to run git lfs migrate info on it, it failed with  this error:
>
> ```
> $ git lfs migrate info
> migrate: Fetching remote refs: ..., done
> fork/exec /usr/libexec/git-core/git: argument list too long
> ```

The general problem is that when migrating a set of references who's combined string length is longer than the system argument list limit, the system will refuse to execute the `git-rev-list(1)` command because its arguments are too long.

One approach in fixing this is to process separate invocations of `git-rev-list` and merge the results back together, but this gets complicated fairly quickly when merging distinct topologically ordered sets.

Another approach (and one that was already used in a particular case of `git-rev-list(1)` invocation) is to use the `--stdin` flag, which<sup>[[1](https://git-scm.com/docs/git-rev-list#git-rev-list---stdin)]</sup>:

> In addition to the <commit> listed on the command line, read them from the standard input. If a `--` separator is seen, stop reading commits and start reading paths to limit the result.

And will, in effect, allow an arbitrarily long list of references to be read over stdin, mitigating the argument length problem. We already used this in certain cases of `git.ScanLeftToRemote`, but this change teaches the `git.RevListScanner` to use `--stdin` for _all_ modes. 

Closes: https://github.com/git-lfs/git-lfs/issues/2655.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2655",1633,True,en,1
2738,5,1,0,Internals,ttaylorr,2017-11-20T18:55:42Z,92,5,4,3,"This pull request addresses an enhancement pointed out @phord in https://github.com/git-lfs/git-lfs/issues/2656 where the `git-lfs-migrate(1)` command's use of `git-fetch(1)` would make the command un-useable offline.

Since it's been a little while since I've thought about how this works, here's a refresher for my own edification. When determining what to migrate, the tool considers first explicitly given references, or, if none were provided, the unpushed changes on the current branch (i.e., `git log <branch>..<remote-tracking-branch>`). To ensure that we get an up-to-date result and don't accidentally require a force push when the user wasn't expecting one, we always `git fetch` to grab the latest remote refs, if any of them have moved.

Prior to this pull request, there was no way to explicitly disable that, meaning if you don't have an internet connection, you have to (at least) remove remotes, which means the migration won't update any remote refs (since they will be deleted when calling `git remote remove`).

This pull request addresses this problem by providing a `--assume-current-remote-refs` that explicitly tells Git LFS to _not_ contact the remote, and assume the copy of remote references it currently has is up-to-date.

I decided against the original issue title:

> [...] shouldn't fetch or reach out to the remote at all without permission

Since I think the default behavior is safe, if not at least good. I would prefer to explicitly opt-_out_ of the safe behavior rather than into it.

Closes: https://github.com/git-lfs/git-lfs/issues/2656.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2656",1648,True,en,2
2737,5,1,0,Internals,technoweenie,2017-11-21T00:04:15Z,84,60,2,3,"This adds support for `--include=""*.*""`, which should match everything:

```
$ git ls-files ':*.*'
.gitattributes
.gitignore
.mailmap
.travis.yml
CHANGELOG.md
CODE-OF-CONDUCT.md
CONTRIBUTING.md
INSTALLING.md
LICENSE.md
README.md
ROADMAP.md
appveyor.yml
circle.yml
commands/command_checkout.go
commands/command_clean.go
commands/command_clone.go
```

This also speeds up `*` matches too. It worked previously by calling `filepath.Match()` through a `*pathlessWildcardPattern`. ",476,True,en,1
2736,1,0,0,Internals,ttaylorr,2017-11-20T18:55:29Z,27,0,1,3,"This pull request adds a test to https://github.com/git-lfs/git-lfs/pull/2708 that ensures `git lfs track` doesn't show attributes that are commented (and would therefore not be tracked by Git LFS.)

##

/cc @git-lfs/core @mathstuf ",232,True,en,1
2735,1,2,0,Internals,technoweenie,2017-11-20T18:52:52Z,10,16,1,3,"This updates `script/integration` so it waits until it sends all output from the channel to STDOUT before exiting the command. It prevents cases where the _last_ test script fails, but no output is shown for that test script.",225,False,en,0
2734,9,2,1,Internals,ttaylorr,2017-11-20T18:55:09Z,90,10,5,3,"This pull request fixes a bug pointed out by @phord in https://github.com/git-lfs/git-lfs/issues/2654 where the `git lfs migrate` suite would refuse to disambiguate confusing reference names when asked to perform migrations.

@technoweenie points out a fix that I implemented in this pull request via https://github.com/git-lfs/git-lfs/issues/2654#issuecomment-335191900:

> Ah, I think this would be solved by including the ref prefixes, disambiguating the ref names.

To accomplish this, I taught the `*git.Ref` type to `String()` itself, returning a fully-qualified reference, and collect those instead of the local reference names. This allows for references to have existing SHA-1's as their local name, and migrate will still work correctly.

Closes: https://github.com/git-lfs/git-lfs/issues/2654.

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2654",874,True,en,3
2733,4,0,7,Internals,ttaylorr,2017-11-16T22:51:50Z,48,4,4,0,"This pull request fixes a bug pointed out in https://github.com/git-lfs/git-lfs/issues/2729 where @TingluoHuang noticed that setting `http.$url.extraHeader` in your Git config would still cause API requests needing authorization to contact your credential helper, even if the authorization header was set.

Introduced here is a mechanism to avoid contacting the credential helper if any matching `http.extraHeaders` entry contains a header with the key `Authorization: `. This intentionally does not fall back to the credential cache or other credential helpers, since we assume that if a user explicitly provided an `Authorization` header, they would like to use that.

Closes: https://github.com/git-lfs/git-lfs/issues/2729

##

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2729",795,True,en,1
2732,14,0,7,Internals,ttaylorr,2017-11-21T00:08:29Z,196,140,12,4,"This pull request extends the `progress.Meter` interface to implement `git/githistory/log.Task` so that the `progress.Meter` can be driven from a `*git/githistory/log.Logger`.

Being able to use the various implementations of `progress.Meter` within the `git/githistory/log` sub-package has the following benefits:

- Separating the concept of generating a message and printing it.
- Eliminating IO-races, where two things want to log at the same time and the message is garbled, or out of order.
- Consistent use of the `git/githistory/log` package, which makes changing IO behavior in this context easier.

Since it's been awhile for me, I wanted to write down some of the ideas in the `git/githistory/log` package here:

1. The `*Logger` logs `Task`s, which provide a channel of updates, and a `Throttled()` method, telling the logger whether or not they should be throttled.
2. The `*Logger` logs a `Task` until completion, enqueuing and subsequently printing messages from other `Task`s only after the currently running Task is complete. It buffers further tasks in a pseudo-infinite buffer.

This pull request seeks to achieve the above benefits by implementing `log.Task` in `progress.Meter`, making it possible to `log.NewLogger(...).Enqueue(progress.NewMeter())`. The approach towards doing this was done in a minimal fashion, keeping the majority of the formatting code as-is, but adding a new `update()` method, which sends a new update after each time a method that would change the output of the progress meter is called.

For instance:

```go
func (p *ProgressMeter) Add(size int64) {
	defer p.update()
 	atomic.AddInt32(&p.estimatedFiles, 1)
 	atomic.AddInt64(&p.estimatedBytes, size)
}
```

will modify the `*ProgressMeter`'s state, then issue a deferred `p.update()` call, which will construct a new update, and send it. The `*log.Logger` will either accept it, or drop it on the floor if the `*ProgressMeter` is generating too many updates.

This had some other unexpected benefits like removing the `for _ = range time.NewTicker(...).C` idiom, and simplifying the `Start()` and `Pause()` implementations.

## 

/cc @git-lfs/core @technoweenie ",2162,True,en,1
2730,2,0,0,Externals,dpursehouse,2017-11-16T02:00:19Z,8,0,2,0,"Includes fixes for #2713 and #2714 

- `uninstall` is added to the list of commands on the top level man page
- the `--local` option is added to the man page for `uninstall`",173,True,en,0
2722,5,1,5,Internals,technoweenie,2017-11-20T18:53:27Z,47,57,9,11,Updates the `locks/verify` calls to send the full refspec. /cc #2712.,69,False,en,5
2719,1,4,0,Externals,bilke,2017-11-08T20:16:52Z,1,0,1,1,This functionality was introduced in https://github.com/git-lfs/git-lfs/commit/2082b26ce728bb8a960b28bcac9aaecbb6a251c1 but was not documented.,143,False,en,0
2716,2,6,0,Externals,QuLogic,2017-11-08T20:39:48Z,7,2,1,4,"Also, back off on polling a bit after the first check to reduce any I/O contention that might slow things down even more. Instead of 5 seconds, this will wait up to about 60 seconds for files created by the test server to appear. This allows very slow systems to be able to pass tests.

Finally, add a message if the file doesn't appear to make it clear what went wrong.

For example, slow builders like [aarch64](https://kojipkgs.fedoraproject.org//work/tasks/291/22880291/build.log) or [armv7hl](https://kojipkgs.fedoraproject.org//work/tasks/294/22880294/build.log) mysteriously fail right after printing git(lfs) versions without any indication why.",653,True,en,1
2715,1,0,0,Internals,technoweenie,2017-11-03T17:06:10Z,86,10,8,0,Fixes #2711,11,False,en,1
2709,2,5,0,Externals,mathstuf,2017-11-16T21:08:50Z,4,0,1,15,,0,False,en,1
2708,2,7,2,Externals,mathstuf,2017-11-17T16:16:51Z,6,2,1,16,"---
This only addresses the initial description of #2413. It does not fix `[attr]` behavior or checking for `-filter=lfs`.",122,False,en,0
2706,11,2,1,Internals,technoweenie,2017-11-03T16:32:22Z,730,289,16,2,"Implements 2 aspects of #2712:

* basic `push.default` support, which governs how Git chooses an implicit remote ref based on the remote and local ref being pushed.
* Verify locks on each ref being pushed.

Bonus: locks are not verified for `git lfs push --object-id` anymore. Since this push doesn't affect any Git code, there's no need to verify anything.

This also extracts a `*lockVerifier` and `*refUpdate`. There is still too much coupling, but it's better than everything being in `*uploadContext`. Baby steps....",521,True,en,7
2704,2,1,0,Internals,technoweenie,2017-11-20T23:50:47Z,1,0,1,21,This adds ubuntu/artful to the list of distros for future LFS releases.,71,False,en,0
2700,17,0,0,Internals,technoweenie,2017-10-30T21:12:56Z,163,144,23,2,"This teaches `*config.Configuration` how to get the default remote.

1. The `CurrentRemote` property was replaced with `Remote() string` and `SetRemote(string)`
2. Behavior from `git.DefaultRemote()` was replicated in `Remote()`.
3. All traces of `git.DefaultRemote()` were removed.

Fixes #2169.

EDIT: 1 caveat: this does not work with an empty repository, since `git rev-parse` blows up:

https://github.com/git-lfs/git-lfs/blob/bee3e755e1cc2206c342344ea98bd29bb51c3235/git/git.go#L195-L200

Not sure if this should assume any default branch name. Maybe it could look for any `branch.*.remote` config keys? Or this could just require a repository with at least 1 commit.",673,True,en,3
2699,1,0,0,Internals,technoweenie,2017-10-27T21:29:08Z,0,2,1,0,"There's no need to close the scanner if `NewPointerScanner()` returns an error, since it returns a `nil` scanner:

https://github.com/git-lfs/git-lfs/blob/d039e3791aca6100a0e0944cc7f46d1f4d0f047b/lfs/gitscanner_catfilebatch.go#L69-L76

This also fits with common go conventions.",278,True,en,0
2698,1,0,0,Internals,technoweenie,2017-10-27T15:35:46Z,2,2,1,0,"This should fix the rare intermittent test failures. Sometimes `base64` generates strings that some OS's won't allow as directory names. This PR runs the content through `shasum -a 256` to ensure the random filename only consists of hex characters.

[Sample failure](https://circleci.com/gh/git-lfs/git-lfs/2489?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link):

```
test: migrate info (--everything with --include-ref) ...           FAILED
-- stdout --
-- stderr --
    + set -e
    + setup_multiple_local_branches
    + set -e
    + reponame=migrate-info-multiple-local-branches
    + remove_and_create_local_repo migrate-info-multiple-local-branches
    ++ base64
    ++ head -c 8
    ++ sed -e 's/\///'
    + local reponame=/oxVeYF-migrate-info-multiple-local-branches
    + git init /oxVeYF-migrate-info-multiple-local-branches
    fatal: cannot mkdir /oxVeYF-migrate-info-multiple-local-branches: Permission denied
    + test_status=128
-- git trace --
   trace: built-in: git 'init' '/oxVeYF-migrate-info-multiple-local-branches'
```",1075,True,en,1
2695,16,2,0,Internals,technoweenie,2017-10-30T20:25:35Z,738,541,13,3,"This PR adds support for per-url credential helpers (#2686) and fixes performance issues discussed in #2690.

* [x] Teach the LFS credential cacher to only call approve the first time. LFS should only ever call git credential approve for a given url/path once in the lifetime of a single LFS command.
* [x] Teach the LFS HTTP client to only call Approve() on the credential helper if it was used for a request. I don't know how other LFS servers work, but GitHub's doesn't require it for transferring specific objects.
* [x] Add approve tracing to LFS so we can confirm a fix.
* [x] Teach LFS to only send `path` to credential helpers if `credential.useHttpPath` is enabled.
* [x] If askpass is set, fall back to credential helper if it's misconfigured.
* [x] Check for `credential.<url>.usehttppath` and `credential.<url>.helper`

By creating the credential helper per request, any notion of a cache is lost. So, there's still more work to be done in `(*Client) getCredentialHelper`.",984,True,en,6
2692,10,0,0,Internals,technoweenie,2017-10-26T17:09:32Z,465,431,46,0,":fire: `git.Config`. There's still more refactoring work to be done, but this is the last static config value. ",111,False,en,21
2689,18,0,0,Internals,technoweenie,2017-10-26T16:46:07Z,540,723,51,0,"Replaces the `localstorage` with a new, slightly better designed `fs` package. More of the static vars/funcs have been removed too.",131,False,en,13
2687,7,0,0,Internals,technoweenie,2017-10-25T00:35:34Z,128,81,19,0,:fire: `config.Config`.,23,False,en,5
2678,2,0,0,Internals,technoweenie,2017-10-24T17:25:29Z,1,1,1,4,/cc #2677.,10,False,en,0
2676,23,1,0,Internals,technoweenie,2017-10-19T19:35:36Z,789,964,43,1,"Started working on something, got disgusted by the global config objects, so I started some refactoring.",104,False,en,3
2674,1,0,0,Internals,technoweenie,2017-10-18T16:21:40Z,21,4,5,0,,0,False,en,0
2673,4,0,0,Internals,technoweenie,2017-10-17T21:32:57Z,26,28,4,0,"Fixes #2670. This PR fixes two common, but not fatal, problems that can arise when running `git lfs install`:

1. The values from `git lfs install --skip-smudge` can not be upgraded with `git lfs install`
2. An unexpected config value should not be overwritten. Instead, print a warning _without changing the exit code_. This way installations don't fail, but a user is told if their config values are unexpected.",413,True,en,1
2672,2,0,0,Internals,technoweenie,2017-10-17T20:12:56Z,81,53,2,0,"The `tools.FastWalkGitRepo()` mimics `filepath.Walk()`, with a few performance optimizations:

* Subdirectories, in groups of up to 100, are walked in goroutines.
* Files are not returned in any specific order.
* `.gitignore` patterns are respected.

This PR introduces a limit to the concurrent goroutines that can be spawned, with an arbitrary default of 20x the number of CPUs that are available. That seems to be plenty, and well within system limits. It does mean that `tools.FastWalkGitRepo()` will slow down for particularly wide or deep directory structures in a repository, but hopefully it won't crash.

FWIW, `tools.FastWalkGitRepo()` is used in the following commands:

* `git lfs track`, when it's scanning your repository for nested `.gitattributes` files
* `post-merge` and `post-checkout`, when LFS ensures lockable files not currently locked by you are marked readonly.

I want to include this in LFS v2.3.4. A smaller experimental version of this patch is at https://github.com/git-lfs/git-lfs/compare/fastwalk-depth. I removed the debug messages, and went a little further extracting an internal struct type for a single `tools.FastWalkGitRepo()` call.",1171,True,en,1
2659,4,4,5,Internals,shiftkey,2017-10-11T20:00:14Z,16,4,2,1,"Downstream issue: https://github.com/desktop/desktop/issues/2984

```
Error running git [config --global filter.lfs.clean git-lfs clean -- %f]: 'warning: filter.lfs.clean has multiple values
error: cannot overwrite multiple values with a single value
       Use a regexp, --add or --replace-all to change filter.lfs.clean.' 'exit status 5'
Run `git lfs install --force` to reset git config.
```

`--add` and `--replace-all` are vintage flags for `git config`, but it seems like something in a recent Git update (2.14.2? need to confirm) is enforcing this check check better to ensure changes are lax (this bit us in a similar way when we were updating global config in https://github.com/desktop/desktop/issues/2945).

Wrapping my head around how flow `--replace-all` through when `--force` is set in a way that makes sense - shout if you have a better way to do this.
",869,True,en,1
2657,3,1,0,Internals,technoweenie,2017-10-09T16:55:46Z,46,16,6,0,,0,False,en,0
2651,3,0,0,Internals,technoweenie,2017-10-18T22:55:37Z,34,22,3,13,This uses `config.URLConfig` to get host-specific proxy settings like `http.{url}.proxy`. Fixes #2644.,102,False,en,1
2648,1,0,0,Internals,technoweenie,2017-10-04T20:05:13Z,7,4,1,0,"#2508 enabled credential caching for SSH. This enables it for http requests that go through `git-credential` or GIT_ASKPASS.

The struct tag notation for git config values doesn't support setting a default value. So, this uses the `Bool()` method, which does accept a default.",276,True,en,0
2647,4,4,2,Internals,technoweenie,2017-10-05T22:42:44Z,28,16,3,1,"Brings LFS back for `git update-index` calls. This fixes issues where `git status` is unclean after a `git lfs pull` or `git lfs clone`.

/cc https://github.com/git-lfs/git-lfs/issues/2646#issuecomment-334204675",211,True,en,2
2643,1,0,0,Internals,technoweenie,2017-10-03T18:53:52Z,28,3,5,0,,0,False,en,0
2642,2,0,0,Internals,technoweenie,2017-10-03T17:46:19Z,17,20,3,0,"Fixes #2640 by moving the file permission logic from `UnlockFile()` to `UnlockFileById()`. The path is taken from the `lock` property returned by the `/unlock` api endpoint.

```sh
$ GIT_CURL_VERBOSE=1 git lfs unlock --id=123
> POST /my-repo.git/info/lfs/locks/123/unlock HTTP/1.1
> Host: github.com
> Accept: application/vnd.git-lfs+json; charset=utf-8
> Authorization: Basic * * * * *
> Content-Length: 15
> Content-Type: application/vnd.git-lfs+json; charset=utf-8
> User-Agent: git-lfs/2.3.1 (GitHub; darwin amd64; go 1.9)
>
{""force"":false}

< HTTP/1.1 200 OK
< Content-Length: 141
< Content-Type: application/vnd.git-lfs+json
< Date: Tue, 03 Oct 2017 17:11:25 GMT
< X-Frame-Options: DENY
< X-Github-Request-Id: FF7E:5D17:5AA5486:AB0C1BC:59D3C4BD
<
{""lock"":{""id"":""123"",""path"":""my-file.zip"",""locked_at"":""2017-10-03T17:11:09Z"",""unlocked_at"":""2017-10-03T17:11:25.692648804Z""}}
Unlocked Lock 123
```",899,True,en,1
2641,2,0,0,Internals,technoweenie,2017-10-03T17:33:17Z,49,11,3,0,Fixes #2639 by ensuring files are added to the git index with a path relative to the current working directory.,111,False,en,2
2637,1,1,0,Internals,technoweenie,2017-10-03T15:45:21Z,7,2,2,0,Fixes #2634. May change if the consensus reached in #2634 changes.,66,False,en,1
2633,3,0,0,Internals,technoweenie,2017-10-03T16:12:50Z,17,7,4,3,"Fixes #2624 

BEFORE:

```sh
$ git lfs fetch
line 1: keyword expected; got maachine
```

AFTER:

```sh
$ script/run fetch
bad netrc file /Users/rick/.netrc: line 1: keyword expected; got maachine
exit status 2
```

This includes a bonus tweak that doesn't initialize an api client unless it's needed. So `lfs version` won't trigger the error. You'll have to run something like `git lfs fetch`.",393,True,en,0
2632,2,0,0,Internals,technoweenie,2017-10-03T15:59:04Z,2,2,2,3,Closes #2259.,13,False,en,0
2626,3,0,2,Internals,technoweenie,2017-10-18T22:32:38Z,184,15,6,20,"This prevents LFS from replacing LFS pointers with the actual content if the `clean` filter is not configured. Otherwise, this leads to a dirty `git status`. Fixes #2472",169,False,en,3
2625,1,0,0,Internals,technoweenie,2017-09-28T15:20:54Z,6,3,2,0,Fixes #2214 for `git lfs track <pattern>`. ,43,False,en,1
2622,2,0,0,Internals,technoweenie,2017-10-03T16:48:33Z,6,1,1,5,"Really tiny, and probably inconsequential optimization.",55,False,en,0
2621,2,0,0,Internals,technoweenie,2017-10-18T22:18:00Z,2,2,1,21,"This fixes an inconsistency in the first auth attempt vs subsequent auth attempts, as described in https://github.com/git-lfs/git-lfs/issues/2618#issuecomment-332593686. There's a quirk where if `ssh git-lfs-authenticate` returns a bad `Authorization` header, LFS will only ask for credentials on the first attempt. This is because it notices the `lfs.<url>.access` is empty, and changes it from `nil` to `basic`. Subsequent attempts already have `lfs.<url>.access` set, so it never asks your git credential helper.

LFS accepts auth from the following sources (in order of preference). Some methods are set according to the Git config, and can't be changed during an LFS command.

* `(*lfsapi.Client) NewRequest()` calls `ssh git-lfs-authenticate` for SSH git remotes. This response can return an `Authorization` header.

https://github.com/git-lfs/git-lfs/blob/master/lfsapi/client.go#L30-L60

* The remote could point to an https url with embedded credentials.
* The user could have a netrc file.
* Git can ask, if `GIT_ASKPASS` is configured.
* Git can ask, using a credential helper to cache it, if configured.

Of these, the only thing that LFS can effectively retry is when the git credential helper is used. Otherwise, every API request will have to be made multiple times because the default configured passwords (from ssh, the remote url, or netrc) are wrong.

* If `ssh git-lfs-authenticate` is returning bad credentials, it should be fixed with the ssh command.
* If the remote contains incorrect embedded `user@pass` credentials, it should be fixed in the git config.
* If netrc credentials are incorrect, it should be fixed.",1638,True,en,0
2620,1,0,0,Internals,rubyist,2017-09-27T20:59:16Z,6,6,3,0,"This updates `tracerx` to add timestamps to tracing output to match what git does.

Fixes #2619 

```
[scott@black tracerx]$ GIT_TRACE=1 git lfs locks
12:35:03.467185 git.c:560               trace: exec: 'git-lfs' 'locks'
12:35:03.467207 run-command.c:626       trace: run_command: 'git-lfs' 'locks'
12:35:03.469551 trace git-lfs: run_command: 'git' version
12:35:03.471019 trace git-lfs: run_command: 'git' config -l
12:35:03.471975 trace git-lfs: HTTP: GET https://github.com/rubyist/tracerx.git/info/lfs/locks
12:35:03.794442 trace git-lfs: HTTP: 200
12:35:03.796144 trace git-lfs: HTTP: {""locks"":[],""next_cursor"":""""}
```",624,True,en,0
2617,1,0,0,Internals,technoweenie,2017-09-26T23:04:58Z,3,3,1,0,This fixes a failure when building an rpm for centos6.,54,False,en,1
2615,1,0,0,Internals,technoweenie,2017-09-26T22:28:38Z,33,3,5,0,I think it's a good time to put out a quick `GIT_ASKPASS` bugfix release.,73,False,en,0
2614,3,0,0,Internals,technoweenie,2017-09-26T18:58:07Z,20,2,2,0,"This skips the request immediately, and provides a better error message (with the problem described at the front, before the long url).

BEFORE:

```
Fetching master
Git LFS: (0 of 2 files) 0 B / 178.50 KB
batch response: Post lfs.github.localhost/technoweenie/lfs-test/objects/batch: unsupported protocol scheme """"
error: failed to fetch some objects from 'lfs.github.localhost/technoweenie/lfs-test'
```

AFTER:

```
Fetching master
Git LFS: (0 of 2 files) 0 B / 178.50 KB
batch request: missing protocol: ""lfs.github.localhost/technoweenie/lfs-test""
error: failed to fetch some objects from 'lfs.github.localhost/technoweenie/lfs-test'
```",642,True,en,0
2610,8,0,0,Internals,technoweenie,2017-09-26T17:01:49Z,94,38,10,3,"This adds an option to print the commit oid and path of every migrated file.  I'm not sure if this should be default or not, so I'm playing it safe for v2.3.1.

```
$ git lfs migrate import --include=""*.gem"" --include-ref=master --verbose
migrate: Sorting commits: ..., done
migrate: commit 4be47bd500d595ad735e077ea7b2b1b0ff399de4: vendor/cache/yajl-ruby-0.8.0.gem
migrate: Rewriting commits:   5% (21335/454650)
```",417,True,en,1
2609,4,0,0,Internals,technoweenie,2017-09-26T17:39:02Z,39,4,2,3,"This matches Git's behavior. `SSH_ASKPASS` is tried after `GIT_ASKPASS` and `core.askpass`, according to https://git-scm.com/docs/gitcredentials. ",146,False,en,1
2608,3,0,0,Internals,technoweenie,2017-09-26T16:35:20Z,67,10,3,3,"Fixes 3 issues with `GIT_LFS_PROGRESS`:

1. It's reported twice for `lfs pull` or `lfs clone`, since `(*ProgressMeter) StartTransfer(string)` is called in the GitScanner before being added to the transfer queue AND in the transfer queue. https://github.com/git-lfs/git-lfs/issues/2599
2. The `checkout` never knows how many files there are, so the progress is reported as `1/1`, `2/2`, `3/3`, etc.
3. No tests :(

I'm not crazy about changing `checkout` to accumulate a `[]*WrappedPointer` slice, but it's the only way to know the total number of files to checkout before starting to check files out.",600,True,en,1
2607,2,0,0,Internals,technoweenie,2017-09-22T17:31:53Z,4,2,3,0,"This trims whitespace from passwords provided by `GIT_ASKPASS`, bringing it up to speed with the username.",106,False,en,1
2600,4,0,0,Internals,technoweenie,2017-09-20T21:44:49Z,110,607,25,0,"This adds code to close packfiles _and_ their index files. It also replaces `mmap.Open()` with `os.Open()`. The mmap package is experimental, and not really necessary. In fact, I got better perf in a `git lfs migrate info --include-ref=master` run with `os.Open()`.

/cc #2597",276,True,en,3
2598,7,3,2,Internals,shiftkey,2017-09-20T17:23:48Z,45,11,2,1,"Fixes #2592 

![](https://media.giphy.com/media/EiF2Xr3x9K6I0/giphy.gif)

This currently works by checking for `HEAD` ref after a clone and quietly moving on, but I'm open to different approaches to tackling this if we want to make the actions here more resilient and less noisy for this error case.

Any pointers for adding new tests to catch this regression would also be welcome!",382,True,en,1
2596,3,2,0,Internals,technoweenie,2017-09-22T16:32:54Z,4,3,1,3,Not sure why I thought multiple `--include` flags was legit.,60,False,en,0
2590,5,1,3,Externals,sprohaska,2017-09-22T22:53:34Z,174,25,9,5,"PR-2429 has implemented a mechanism to unconditionally specify
standalone custom transfer agents.

This commit addresses two limitations, so that standalone custom
transfer can be configured per remote.

* Custom transfer agents may now be specified based on an URL prefix
  match on the API URL.

* git-lfs passes the Git remote in the stage 1 initiation message.
  The standalone custom transfer agent can use it to determine the
  remote file location.

One remote can, for example, point to a server that supports ssh login
and use rsync.  Another remote can point to GitHub.  LFS works for both.
Example Git config:

```
remote.github.url=...
remote.origin.url=ssh://gitssh.example.com/git/some/repo
lfs.customtransfer.rsync.path=git-lfs-rsync-agent
lfs.https://gitssh.example.com/git/.standalonetransfer=rsync
```

The config assumes that `git-lfs-rsync-agent` determines the remote from
the stage 1 init message and then inspecting `remote.origin.url` to
infer the rsync host.  <https://github.com/aleb/git-lfs-rsync-agent>,
2017-09-17, does not yet do that.

[PR-2429] 09b7c5381bc3fa4ba7ca3564681a5ae5b7e6f3dc 'Allow using custom transfer agents directly', <https://github.com/git-lfs/git-lfs/pull/2429>.

CC: Alexandru Băluț <ab@daedalean.ai>
Signed-off-by: Steffen Prohaska <prohaska@zib.de>",1303,False,en,1
2588,1,0,0,Externals,sschuberth,2017-09-15T16:22:22Z,13,3,1,0,"This avoids the not very telling error message

    [ISPP] Actual parameter FileName is not of the declared type

when Inno Setup tries to extract version information from a non-existing
binary.",194,True,en,0
2586,3,0,0,Externals,sschuberth,2017-09-15T14:29:10Z,1,1,1,0,,0,False,en,0
2585,3,6,3,Internals,shiftkey,2017-09-22T20:22:46Z,1,0,1,7,"After installing Git LFS you'll see an entry in Add/Remove Programs that doesn't have an icon:

<img width=""491"" src=""https://user-images.githubusercontent.com/359239/30464294-e8740d08-9a0f-11e7-8e5c-20780321496e.png"">

I'm _pretty sure_ this is the fix, as it autocompletes in the GUI but beyond that I can't point to any docs around what this represents:

<img width=""243"" src=""https://user-images.githubusercontent.com/359239/30464322-19631c4c-9a10-11e7-849c-25d9e741cb70.png"">

I also couldn't validate this locally with Inno Setup 5.5.9 as it returns this error (same thing when you try and compile it in the GUI):

```
C:\Users\shiftkey\go\src\github.com\git-lfs\git-lfs\script>compile-win-installer-unsigned.bat

C:\Users\shiftkey\go\src\github.com\git-lfs\git-lfs\script>""C:\Program Files (x86)\Inno Setup 5\iscc.exe"" /Qp ""windows-installer\\inno-setup-git-lfs-installer.iss""
[ISPP] Preprocessing.
Error on line 7 in C:\Users\shiftkey\go\src\github.com\git-lfs\git-lfs\script\windows-installer\inno-setup-git-lfs-installer.iss: [ISPP] Actual parameter FileName is not of the declared type.
Compile aborted.
```",1118,True,en,0
2584,1,1,0,Internals,ttaylorr,2017-09-14T17:00:23Z,25,1,2,0,"This pull request allows callers to disable the hook installation component of running `git lfs track` via an environment variable `GIT_LFS_TRACK_NO_INSTALL_HOOKS`.

If set to a truth-y value, this skips the `lfs.InstallHooks(false)` call made by `git lfs track`. It is implemented as an environment flag since this is not functionality that we are intending to expose to users, rather, this is intended to be used by other programs leveraging Git LFS. It is absent from the manpage for the same reason.

---

/cc @git-lfs/core @joshaber ",538,True,en,1
2583,1,0,2,Internals,ttaylorr,2017-09-14T17:21:02Z,121,4,5,0,"---

/cc @git-lfs/core @git-lfs/releases ",41,True,en,0
2580,3,0,6,Internals,technoweenie,2017-09-14T15:42:20Z,74,13,1,0,"This updates the man page:

* Lists the `import` mode
* Reorders the sections so that `info` is described before `import`
* Add some examples of how to use `info` and `import`.",176,True,en,0
2579,4,0,0,Internals,technoweenie,2017-09-13T21:25:51Z,75,12,4,0,"I noticed that `HasPrefix()` returns false if there are no _include_ patterns. I think if none of the _exclude_ patterns have rejected it, then it should return `true`.

There is one existing test case this fails on: a prefix of `foo/bar/baz/`, with an exclude pattern of `/foo/bar/baz` or `foo/bar/baz`. It's commented out.

Without this fix, `git lfs migrate` will only scan the root directory if no `--include` flag is given.",428,True,en,3
2578,4,1,0,Internals,ttaylorr,2017-09-13T22:23:35Z,88,35,3,0,"This pull request fixes a bug where program arguments would be incorrectly accepted by the `GIT_ASKPASS` parser, therefore breaking `GIT_ASKPASS` and `core.askpass` exec paths that have spaces or quotes in them.

---

/cc @git-lfs/core @joshaber ",246,True,en,1
2577,1,0,0,Internals,ttaylorr,2017-09-13T15:49:39Z,6,1,1,0,"This pull request changes the log message when performing ""rewrites"" without ref updates to ""Examining commits"" instead of ""Rewriting commits"".

For example, before this pull request:

```
~/g/git-lfs (master) $ git lfs migrate import
migrate: Fetching remote refs: ..., done
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (0/0), done
migrate: Updating refs: ..., done

~/g/git-lfs (master) $ git lfs migrate info
migrate: Fetching remote refs: ..., done
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (0/0), done
```

And with this pull request:

```
~/g/git-lfs (migrate-different-msg-no-ref-updates) $ git lfs migrate import
migrate: Fetching remote refs: ..., done
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (0/0), done
migrate: Updating refs: ..., done

~/g/git-lfs (migrate-different-msg-no-ref-updates) $ git lfs migrate info
migrate: Fetching remote refs: ..., done
migrate: Sorting commits: ..., done
migrate: Examining commits: 100% (0/0), done
```

---

/cc @git-lfs/core ",1053,True,en,0
2574,6,0,0,Internals,technoweenie,2017-09-12T15:34:15Z,170,62,6,0,"This implements two fixes to make LFS pushes better:

1. `lfs.allowincompletepush` is now on by default. It's easier to push repositories when you're missing LFS content. It still warns about those missing files, but at least you're not blocked.
2. Fixed an issue where the `ensureFile()` helper wasn't obeying the `lfs.allowincompletepush`. That helper detects cases where a `.git/lfs/objects/{oid}` file is missing, and attempts to fill it in from the file in the working directory. Fails on any modified or deleted files in the current HEAD, of course.",555,True,en,3
2572,1,0,0,Internals,ttaylorr,2017-09-11T19:10:35Z,2,2,1,0,"This pull request fixes some incorrect indentation that accidentally got committed through a merge conflict resolution.

## ",124,True,en,0
2571,1,0,3,Externals,larsxschneider,2017-09-11T15:53:41Z,3,0,1,0,"It can be hard to trace Git LFS errors on the server without the exact
time. Fix this by adding the time in UTC to the error log output.",136,False,en,0
2570,2,1,6,Externals,larsxschneider,2017-09-11T18:15:20Z,48,1,1,0,"It can be hard to trace Git LFS errors on the server without client IP
address. Fix this by adding the IP address to the error log output.

#### Attention
Is this OK from a privacy perspective? I think it is OK as we log the file to the local machine that knows the IP address anyways. A user that is concerned about the IP address could remove it from an error report. The same is already the case if the error output contains sensitive filenames of a repo.",458,False,en,0
2567,3,0,0,Internals,ttaylorr,2017-09-08T20:50:47Z,9,21,1,0,"This pull request uses cobra's `PersistentFlags()` option to avoid looping and reassigning flags to subcommands.

`PersistentFlags` are another flag set that is merged from a command's parent into the command's own flag set when `ParseFlag()` is called<sup>[[1](https://github.com/spf13/cobra/blob/b78744579491c1ceeaaa3b40205e56b0591b93a3/command.go#L1283-L1289
)][[2](
https://github.com/spf13/cobra/blob/b78744579491c1ceeaaa3b40205e56b0591b93a3/command.go#L1261-L1269)].

By using `PersistentFlags()`, we can avoid looping through each subcommand.

---

/cc @git-lfs/core",573,True,en,0
2566,1,1,0,Internals,ttaylorr,2017-09-08T20:28:25Z,12,0,1,0,"This pull request prevents a failure from hardlinking new objects created during migration when a different filesystem is mounted at `/tmp`.

As pointed out by @ioquatix in https://github.com/git-lfs/git-lfs/issues/2381#issuecomment-327677404:

> I'm using 2.2.1 and I had to do the following:
> 
> ```
> sudo -u http TMPDIR=`pwd`/.git/lfs/tmp git lfs pull
> ```
>
> Otherwise I got the same errors trying to copy files from /tmp to /srv/http/...

Using `tmpfs` mounted at `/tmp` can still cause a cross-device link issue when trying to create a hardlink via `os.Rename()`.

I was curious why this was happening, since we use `lfs.TempDir` and `lfs.TempFile()` for creating temporary files to store objects when migrating. It turns out, however, that failing to call `lfs.InitializeLocalStorage()` will let `lfs.TempDir` be equal to `os.Gettemp()`:

https://github.com/git-lfs/git-lfs/blob/a2981c1b39353858e08f498e9141ad118c9d1e35/localstorage/currentstore.go#L22

and:

https://github.com/git-lfs/git-lfs/blob/a2981c1b39353858e08f498e9141ad118c9d1e35/localstorage/currentstore.go#L37

Thus, failing to call `lfs.InitLocalStorage()` will hardlink files from `/tmp` into `.git/lfs/objects` (and `.git/objects`), potentially causing hardlink errors as above.

Closes: https://github.com/git-lfs/git-lfs/issues/2381

---

/cc @git-lfs/core 
",1338,True,en,0
2562,1,0,0,Internals,ttaylorr,2017-09-08T20:39:38Z,2,2,1,0,"Running 'go tool pprof' in CPU mode while Git LFS is running a migration
against a large repository shows that 4.73% percent of the CPU time is spent in
a function called 'runtime.memmove'. This is the function called when
append()-ing to a slice causes the slice to grow, and memory occupied by the
existing slice must be moved into a different contiguous group.

```
$ go tool pprof $(which git-lfs) git-lfs-1504820145.pprof dot
File: git-lfs
Type: cpu
Time: Sep 7, 2017 at 5:35pm (EDT)
Duration: 35.17s, Total samples = 30.42s (86.49%)
Entering interactive mode (type ""help"" for commands, ""o"" for options)
(pprof) list runtime\.memmove
Total: 30.42s
ROUTINE ======================== runtime.memmove in ...
     1.44s      1.44s (flat, cum)  4.73% of Total
         .          .     30:// void runtime·memmove(void*, void*, uintptr)
         .          .     31:TEXT runtime·memmove(SB), NOSPLIT, $0-24
         .          .     32:
...
```

The implementation of 'runtime.memmove' is [fairly complex][1] and takes a
relatively long amount of time to execute. Unfortunately, the 'patch' function
in package 'git/odb/pack' is one of the smaller contributors:

```
(pprof) tree runtime\.memmove
----------------------------------------------------------+-------------
                                             0.01s   100% |   git/odb/pack.patch
         0     0%  4.73%      0.01s 0.033%                | runtime.growslice
                                             0.01s   100% |   runtime.gcAssistAlloc
----------------------------------------------------------+-------------
```

That said, the delta instructions do hint at the size of the patched result of
applying 'delta' to 'base', which we can use to eagerly allocate a contiguous
block of memory for.

[1]: https://github.com/golang/go/blob/go1.9/src/runtime/memmove_amd64.s 

---

/cc @git-lfs/core 
/cc #2415 ",1879,False,en,0
2559,1,0,0,Internals,ttaylorr,2017-09-07T20:38:20Z,21,2,1,0,"This pull request fixes a correctness issue with ref-updating migration modes where non-local refs would be moved in certain cases.

The problem with moving non-local references is that it is only correct if a 'git push' has been accepted against the remote which owns that reference. For example, if I update my copy of `refs/remotes/origin/master`, but don't actually push `master` to that remote, my copy of `refs/remotes/origin/master` is out of sync.

This can happen when running migrations that update local references which point to the same SHA-1 as a remote reference.

- When migrating, maintain a cache of old SHA-1's to the points on the graph that they moved to (i.e., I migrated commit X to a new commit of SHA-1 ""Y"".)
- Once migration is complete, iterate through all references in a repository.
- For each reference, lookup the translated location of the SHA-1 that the reference currently points at, and issue a `git update-ref` creating a reflog entry and moving the reference.

Given the above, if `refs/heads/master` was migrated (and pointed to the same SHA-1 as `refs/remotes/origin/master` at the time that the migration occurred) `refs/remotes/origin/master` will also be migrated, which is incorrect until `git push origin master` has completed.

To address this, modify the `git/githistory.Rewriter` to only pass local references to the `*refUpdater` type, thus not modifying remote references. 

---

/cc @git-lfs/core ",1447,True,en,0
2558,1,0,0,Internals,ttaylorr,2017-09-07T20:38:10Z,145,1,4,0,"This pull request teaches the `--everything` flag to the `import` and `info` modes of `git-lfs-migrate(1)`.

`--everything` indicates that all local references should be migrated. In other words `--everything` means ""migrate the entire section of my repository's local copy that is reachable by _any_ reference"". Practically, this means ""migrate everything"".

Previously, in order to do this, users had to do some combination of:

```sh
git show-ref --heads --tags \
  | cut -d ' ' -f 2 \
  | sed -e 's/^/--include-ref=/' \
  | xargs git lfs migrate import
```

which is correct, but not useable. The presence of `--everything` has the same practical effect as making the included refspec the output of `git show-ref --heads --tags` (via `git.LocalRefs()`).

---

/cc @git-lfs/core ",782,True,en,2
2554,5,0,0,Internals,ttaylorr,2017-09-12T19:47:24Z,325,40,15,5,"This pull request introduces the `*pack.Set` type to aid in searching for packed objects among multiple packfiles.

Git repositories can in many scenarios generate more than one packfile. Likely, a single object will be found in a single packfile. We use the `*pack.Set` to search all of the `*Packfile`'s contained in a repository to find a desired object.

Searches are ordered in a deterministic fashion by the number of objects in a given packfile that begin with the first byte of the desired object's SHA-1. We generate this ordering by mapping a single byte to a set of packfiles: `map[byte][]*Packfile`, where the value `[]*Packfile` is in descending order for a given prefix by fanout count for that prefix.

This pull request is implemented in two phases:

1. 1542bf9: implement the `*Set` type for n-pack lookups
2. 6eb5a78: replace usage of the `*git.ObjectScanner` type for `*Set`.

The `*Set` type has a few useful properties:

1. Implements the same interface as a single `*Packfile`, so `*Packfile`'s and `*pack.Set`'s can be used interchangeably given a sufficiently general type definition.
2. Allows for creation given a repository root, wherein `NewSet` will find all packfiles in a repository by performing filesystem-level operations.
3. Allows for creation given a set of `*Packfile`'s, for environments where less setup is required, like unit tests.

Practically speaking, using this native implementation of packed object reads provides a noticeable speed increase in migrate operations, mostly in part due to the speed of piped data transfer.

| | commits | time (s) | rate (objs/sec) |
| --- | --- | --- | --- |
| git-lfs-2.2.1@[621d1f8][1] | 34,023 | 10min (600sec) | 56.705 |
| git-lfs-2.3.0@[28e2158][2] | 142,606 | 10min (600sec) | 237.677 |
| | | |
| | +108,583 | - | 4.19x faster |
 
EDIT:

Due to a bug caught in #2579, the above statistics are inaccurate. I re-ran the above benchmarks with #2579 merged in, and found the following:

| | commits | time (s) | rate (objs/sec) |
| --- | --- | --- | --- |
| git-lfs-2.2.1@[621d1f8][1] | 34,023 | 10min (600sec) | 56.705 |
| git-lfs-2.3.0@[a4f03b8][3] | 34,340 | 10min (600sec) | 57.233 |
| | | |
| | +317 | - | 1.009x faster |

These results are definitely less dramatic than those above :). That said, this enhancement will be more beneficial in the long term, as it will make it easy to parallelize the graph traversal in the migrator without having to have multiple copies of `git-cat-file(1) --batch` running.

[1]: https://github.com/git-lfs/git-lfs/commit/621d1f8
[2]: https://github.com/git-lfs/git-lfs/commit/28e2158
[3]: https://github.com/git-lfs/git-lfs/commit/a4f03b8

Closes: #2415 

---

/cc @git-lfs/core @peff 
/cc #2415 ",2719,True,en,3
2553,10,0,0,Internals,ttaylorr,2017-09-12T19:47:10Z,1285,0,16,5,"❗️ This pull request has branches `git-odb-pack-chain-base` and `git-odb-pack-chain-delta` as parents. Until those are merged, here is an inter-diff: https://github.com/git-lfs/git-lfs/compare/4908c70...git-odb-pack-packfile.

This pull request introduces a `*Packfile` type to package `git/odb/pack` whose responsibility it is to assemble an existing delta-base chain that corresponds to the given SHA-1 object name.

This pull request comes in two parts:

1. d2e66cb: implement the `*Packfile` type.

This type is responsible for assembling a representation of the delta-base chain corresponding to a given object.

Delta-base chains work as follows:

A delta-base chain has one base component, and zero or more delta components applied on top of the base. To resolve a delta-base chain, the base is first resolved, and then each delta component is applied successively. Delta components are referenced either by a negative offset (type: `OBJ_OFS_DELTA`), or by a 20 byte SHA-1 referring to the object that contains the delta-base chain (type: `OBJ_REF_DELTA`, whichever is shorter). Once a delta-base chain is assembled, it can be resolved easily.

The algorithm for assembling a delta-base chain as described above is executed as follows:

- Given an object, find the last element in the delta-base chain by asking for the offset of that object's SHA-1 in the receiving `*Packfile`'s corresponding `*Index`.
- Determine the type and length of that link in the delta-base chain.
- If the current chain component is a `*ChainBase`, parse it, and return the assembled `Chain`.
- If the current chain component is an `OBJ_REF_DELTA`, find the object it is referencing, passing its SHA-1 to step 1.
- If the current chain component is an `OJB_OFS_DELTA`, seek backwards, reading the base and delta instructions, constructing a `*ChainDelta` corresponding to that data. Repeat until step 2.

Specifically, the `*Packfile` type implements the above algorithm:

- `Object` resolves the delta-base chain by determining the given SHA-1's offset in the pack, and then passing that offset to `find()`.
- `find()` returns either a `*ChainBase`, or a `*ChainDelta` by determining the base for a given delta, and then recursively applying the `find` function to it.
- `findBase` finds the offset of a base (and passes it to `find`).

2. 6455926: teach `DecodePackfile` to instantiate instances of `*Packfile`, as above.

This function memory maps a packfile, and returns it. `DecodePackfile` does not apply any of the delta base chains, rather, it reads the header, version and object count to ensure that a valid packfile is present.

---

/cc @git-lfs/core @peff 
/cc #2415 ",2669,True,en,8
2552,3,0,0,Internals,ttaylorr,2017-09-12T19:46:57Z,287,0,2,5,"This pull request provides the second of two implementations of the `Chain` interface:

> In the following two pull requests in this series, two implementations of `Chain` will be provided: `*ChainBase` and `*ChainDelta`, which will decompress and apply patch deltas respectively.

Deltas contain a base and a set of delta instructions or operations which are applied in succession in order to ""patch"" the target object.

The base of a `*ChainDelta` can, itself, be a `*ChainDelta`, which represents a delta-base chain of length greater than two. Since the base must first be resolved entirely before applying a patch to it, this behavior ensures that a delta-base chain of length greater than two is applied in the correct order, i.e., starting with the base and working up to the last delta. See the following type definition:

```go
package pack

type ChainDelta struct {
        Base  Chain
        Delta []byte
}
```

The instructions contained in field `Delta []byte` can contain either one of two opcodes:

1. `COPY`: encodes a copy offset and copy size (referred to as `co`, `cs`, respectively) which copies `cs` bytes from `co` in the base offset onto the target object. `co` and `cs` are both encoded as a bitmask+byte[s...]. An example of this: `0x0005` (`0000 0101`), the bitmask is `0101`, which means the following two bytes will be OR'd together as `b[0] | (b[1] << 16)`. The first bitmask+varint combination is the copy offset, and then second is the copy size.
2. `ADD`: encodes an add operation of length `c` (the non-zero opcode itself) where the following `c` bytes are the contents to add to the target object. 

---

/cc @git-lfs/core @peff
/cc #2415 ",1673,True,en,1
2551,2,0,0,Internals,ttaylorr,2017-09-12T19:46:41Z,189,0,4,5,"This pull request provides the first of two implementations of the `Chain` interface:

> In the following two pull requests in this series, two implementations of `Chain` will be provided: `*ChainBase` and `*ChainDelta`, which will decompress and apply patch deltas respectively.

`*ChainBase` handles the first kind of component of the delta-base chains found in Git packfiles: the base. A base encodes some base object's data in a zlib-compressed format, to which delta operations can be applied (patched).

Since the `*ChainBase` must handle zlib-compressed data, we run into the challenge of converting the `mmap(2)`'d `*os.File` (given as an `io.ReaderAt`) into an `io.Reader` that package `compress/zlib` can read from. This is done using the `*OffsetReaderAt` type, which implements the `io.Reader` interface by encoding an offset into an `io.ReaderAt`, and updating the offset each time a read is performed.

Because we cannot readily determine the length of the compressed object data in a packfile, we must take into account the greedy behavior from package `compress/zlib`. One approach to dealing with this is to find the next object, and limit reads from going beyond that. However, since we are not sharing `*OffsetReaderAt` instances with more than one `Chain` implementation, we can read past the end of the compressed data, and `compress/zlib` will simply ignore the extraneous bytes. [Here](https://play.golang.org/p/TPlQyCDCUo) is an example.

---

/cc @git-lfs/core @peff
/cc #2415 ",1502,True,en,2
2550,3,0,0,Internals,ttaylorr,2017-09-12T19:46:24Z,217,0,6,5,"This pull request introduces some of the necessary scaffolding work to support packed object reads in package `git/odb/pack`.

The eventual design goal of this package is to have a `git/odb/pack.(*Packfile)` type that given a SHA-1 `[]byte`, returns an `(*Object)`, with the following type definitions:

```go
package git/odb/pack

type Object struct { ... }

func (o *Object) Type() PackedObjectType { ... }
func (o *Object) Unpack() ([]byte, error) { ... }
```

This pull request introduces the three types necessary to support a design as described above:

1. ef50370: The `PackedObjectType`, a const type that has valid values corresponding to the different types of objects that can be packed.
2. 9ea23ca: The `Object` type, with the above methods for determining the unpacked object's type, and for unpacking the object itself.
3. c7f13cd: The `Chain` interface, which is a recursive type that applies one or more layers of a delta-base chain.

In the following two pull requests in this series, two implementations of `Chain` will be provided: `*ChainBase` and `*ChainDelta`, which will decompress and apply patch deltas respectively.

The larger goal is to eventually introduce a type `*Set` in package `git/odb/pack` which allows searching for objects across several packfiles. We can then replace usage of the `git.(*ObjectScanner)` in `git/odb.(*ObjectDatabase)` with the `*Set` type when looking for the contents of packed objects. Given the `*Object` instance as described above, we can than reconstruct the loose object contents of a packed object and parse it using the existing APIs in package `git/odb`.

Here is an example of how that is currently done: https://github.com/git-lfs/git-lfs/blob/5e4f4ad3ba79eb7c9817e8a897be681ce83d9804/git/odb/object_db.go#L225-L237

---

/cc @git-lfs/core @peff
/cc #2415 ",1824,True,en,3
2546,2,0,0,Externals,larsxschneider,2017-09-05T17:31:29Z,1,1,1,2,"The locking config per-host is supposed to affect all repositories on a 
given client machine. However, the help page suggests to set this value 
for a single repository only. Improve the example by using the global 
Git config.",228,False,en,0
2541,6,0,2,Internals,ttaylorr,2017-09-07T20:47:18Z,399,12,7,8,"This pull request teaches a typesafe `Equal()` to `*Blob`'s, `*Commit`'s, and `*Tree`'s, and uses that function in the `git/githistory` package to avoid writing unchanged objects to disk.

Previously, the `git lfs migrate` command would write the contents of every object that it examined in the migration, regardless of whether that object's contents changed. This is sub-optimal, because it involves not only marshaling the contents of unchanged objects to a buffer and performing an expensive save, but also because it effectively has the behavior of unpacking all objects in a repository. That's no good.

To address this, this pull request opts for the following option that I originally proposed in https://github.com/git-lfs/git-lfs/issues/2359:

> Teach either:
> 
> 1. [...]
> 2. Packfile APIs in order to write either a) packed objects, or b) _skip writing packed objects if the object already exists in the database (loose or packed)_.

We can detect whether objects already exist in the object database in either a loose or packed format by determining whether or not the contents of the blob/tree/commit changed when rewriting it. In order to open the object, it must exist, so therefore, if it is unchanged, the object is already saved to the database.

By defining `(t *<T>) Equal(<T> other)` on each object type in package `git/odb`, and comparing the ""rewritten"" instances of each object against the original, we can avoid writing objects to the database (which involves several filesystem-level operations, `open()`, `write()`, a syscall to move, etc.) and instead return early, avoiding all of the previously mentioned operations.

This yields a significant performance boost. When examining the `git-lfs/git-lfs` repository prior to this change, it takes about 38.12 seconds to examing all ~6,000 commits:

```
~/g/git-lfs (master) $ time git lfs migrate info
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (5840/5840), done
# ...
git lfs migrate info  36.30s user 19.80s system 147% cpu 38.127 total
```

Including this change, however, the operation takes only 18.14 seconds:

```
~/g/git-lfs (master) $ time git lfs migrate info
migrate: Sorting commits: ..., done
migrate: Examining commits: 100% (5840/5840), done
# ...
git lfs migrate info  23.74s user 5.71s system 162% cpu 18.144 total
```

Closes: https://github.com/git-lfs/git-lfs/issues/2359.

---

/cc @git-lfs/core ",2421,True,en,3
2540,2,0,7,Externals,larsxschneider,2017-08-31T02:02:26Z,41,4,3,1,"There was no way to conveniently display LFS pointer file properties for
debugging. Teach 'git lfs ls-files' a '--debug' option that prints all
available information following the 'git ls-files' interface [1].

[1] https://github.com/git/git/commit/84974217151a66b65ae5b173045483ce5eeb5142

--

If you like the approach of this PR, then this would this would replace #1829.
My goal here is a quick way to check the sizes of the Git LFS files in a repo.",452,False,en,1
2539,1,0,0,Externals,larsxschneider,2017-08-29T22:22:16Z,0,4,1,0,"The constant was introduced in dca7f73 (""really basic pre-commit hook
that rejects commits with files > 5MB"", 2013-09-23) and is not used
anymore. Cleanup the code and remove it.",178,False,en,0
2538,5,0,0,Internals,ttaylorr,2017-08-30T18:29:17Z,16,6,2,0,"This pull request uses #2536 and #2537 to fetch ref updates before migrating, when no explicit ref arguments are given.

When `git lfs migrate import` is given without an `--include-ref` or `--exclude-ref` flag, we assume that the user wants to migrate all local refs and ignore commits reachable by any remote refs. To do this, we call `ls-remote` for each remote that the repository has, and append the negation `^` operator to all remote refs before passing them to `git-rev-list(1)`.

This works when the client has an up-to-date list of refs on all known remotes, but causes the migrator to fail (propagating an error from `git-rev-list(1)`) when it tries to negate a reference that the repository does not have present locally.

To fix this, we teach the migrator to first fetch all refs present so that they are valid arguments to pass to `git-rev-list(1)`. This is only done when refs are _not_ explicitly given as arguments.

```
~/g/my-repo (master) $ git lfs migrate import
migrate: Fetching remote refs: ...
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (0/0), done
migrate: Updating refs: ..., done
```

---

/cc @git-lfs/core 
/cc @jonico: this fixes the bug with missing/outdated remote refs you showed me last week.",1254,True,en,0
2537,2,0,0,Internals,ttaylorr,2017-08-30T16:45:42Z,23,11,4,0,"This pull request allows callers of the `git/githistory.NewRewriter()` function to pass in a `git/githistory/log.(*Logger)` that they created, instead of just supplying the `io.Writer` sink.

This allows callers to maintain a handle on the given logger without expanding the API of functions that `*HistoryRewriter` receives. Callers that hold a reference to the logger can add their own arbitrary tasks to it, while maintaining the same synchronicity guarentees that the `*Logger` type provides.

This is done in anticipation of the `git-lfs-migrate(1)` command being able to fetch remote refs before beginning a migration. Doing so will require the migrator to log that it is fetching so it does not appear to hang, and thus requires a change like the one presented in this pull request.

---

/cc @git-lfs/core ",814,True,en,0
2536,1,0,0,Internals,ttaylorr,2017-08-30T16:45:27Z,6,0,1,0,"This pull request implements `git.Fetch()`, which takes in a variable number of remotes, and performs a `git fetch` operation on them.

This is work done in anticipation of first calling `git-fetch(1)` from the migrator, to ensure that the necessary remote refs are present locally when comparing them against the output of `git-ls-remote(1)` in order to determine what should be included and not included in the migration.

---

/cc @git-lfs/core ",448,True,en,0
2535,1,0,0,Internals,ttaylorr,2017-08-30T16:45:18Z,24,6,2,0,"This pull request fixes an omission I made in https://github.com/git-lfs/git-lfs/pull/2422, where the remaining bytes of a small offset with the MSB set would be treated as an offset into the large offset, not an index.

When the migrator sees a pack index entry where the object offset has the most significant bit set, it previously and incorrectly assumed that the remaining bits were an absolute offset into the pack index, pointing at a read position where the rest of the large offset could be read. This assumption is incorrect. Instead, the rest of the bits in the small offset encode a relative index into the large offset table. 

For instance: if a 4-byte unsigned integer is encoded as: `0x80000001`:

- The MSB is set.
- The remainder of the bits `(0x80000001&0x7fffffff)` is `0x01`.
- Previously, the migrator would being reading the large 8-byte offset at position 1 of the index file, when instead, it should read the second (0-indexed) entry in the table of large offsets at the end of the pack's index file.

An example from Grit:

https://github.com/github/grit/blob/13d5737ee6de729ed85d951cccaa3127cd22dcde/lib/grit/git-ruby/internal/pack.rb#L218-L223

---

/cc @git-lfs/core 
/cc @peff",1206,True,en,1
2531,1,0,0,Externals,larsxschneider,2017-08-26T17:42:29Z,11,12,2,0,"The gitIndexer starts a new `git update-index` process when the first
file is given to it. A reference to this process is stored in the `cmd`
variable of the gitIndexer struct. This variable was always `nil` after
the refactoring in ae4d2611 (""move `git update-index` invocation to git
package"", 2017-08-02). Consequently, a new `git update-index` process
was invoked for every file.

Fix this by refactoring the `git update-index` invocation, again. This
time we return the subprocess pointer. This is necessary because we
want to call `Wait()` on the process when the gitIndexer is closed.

---

I noticed the bug in #2439 and realized that I introduced it with my recent refactoring. Sorry!
Has anyone a good idea how to check the number of invoked `git update-index` processes in a test case?",796,False,en,0
2530,1,1,0,Internals,ttaylorr,2017-08-28T21:38:08Z,8,6,1,3,"This pull request fixes a bug that @larsxschneider noticed in https://github.com/git-lfs/git-lfs/pull/2511#issuecomment-323599680 (and that @technoweenie explained in https://github.com/git-lfs/git-lfs/pull/2511#issuecomment-323601319):

> As for the SSH thing, my hunch is that the expiration timeout is not being respected. Is this happening at around the 10 minute mark?
> 
> [...]
> 
> - Does the Batch API try to refresh the Authorization header after it expires? I thought it recognizes that and automatically retries. Maybe there's a race condition, and it should refresh the token if expires_in is < 5 or something.
> - Does the SSH cred cacher respect the expires_in? It should be falling back to a real ssh call after expires_in seconds have passed.

I incorrectly noted that the behavior looks correct in https://github.com/git-lfs/git-lfs/issues/2519#issuecomment-324730475, but upon further investigation was able to find the bug.

To explain, here's how the `tools.IsExpiredAtOrIn()` function works:

1. Receive a starting time, a relative duration to expire, an absolute time to expire, and the current time.
2. If the relative duration is non-zero (i.e., the SSH `git-lfs-authenticate` call supports `ExpiresIn`), add that duration to the starting time ""from"", and mark that as the expiration time.
3. If now, mark the absolute ""at"" time as the expiration time.
4. Figure out if the current time is less than ""in"" units of time away from the expiration time as determined above.

The problem was in step four: previously, we were taking the current time to be the ""now"" parameter, where it actually should be `time.Now()`. The from parameter is given as the creation timestamp of the SSH credential cache entry, which will always be earlier (and therefore, non-expired) than the expiration timestamp.

Fix this by using `time.Now()` instead of `now` in order to determine if the time has passed.

Closes: https://github.com/git-lfs/git-lfs/issues/2519.

---

/cc @git-lfs/core 
/cc @larsxschneider 
/cc https://github.com/git-lfs/git-lfs/issues/2519    

",2071,True,en,0
2529,4,0,0,Internals,ttaylorr,2017-08-30T16:45:09Z,16,3,3,5,"This pull request teaches the `readAvailable` function, used to accumulate available pathnames during a Git checkout, to initialize the receiving slice with a capacity equal to the maximum number of objects in a transfer queue's batch.

---

/cc @git-lfs/core 
/cc @larsxschneider ",281,True,en,1
2528,3,1,0,Internals,ttaylorr,2017-08-30T16:57:13Z,34,1,2,5,"This pull request fixes a bug pointed out by @mrbobbybobberson in https://github.com/git-lfs/git-lfs/issues/2497#issuecomment-324173879.

According to our wiki:

> If you'd like to register a file type as lockable, without using LFS, you can edit the .gitattributes file directly:
>
> `*.yml lockable`
>
> Once file patterns in .gitattributes are lockable, Git LFS will make them readonly on the local file system automatically. This prevents users from accidentally editing a file without locking it first.

The post-commit hook should mark those files as read-only. This is correct (and verified by the `test/test-post-commit.sh` test) when files are _also_ tracked using Git LFS. When the `post-commit` hook runs, Git LFS tries to determine a filepathfilter that matches all of the files that are marked as lockable in any of the repository's .gitattributes file(s):

https://github.com/git-lfs/git-lfs/blob/200b8f08cac8f28c46dbf59ae4ca4cf9bcbb9c7d/locking/lockable.go#L39-L52

it does so by scanning the repository's .gitattributes(s) for any paths that are lockable, using this function:

https://github.com/git-lfs/git-lfs/blob/200b8f08cac8f28c46dbf59ae4ca4cf9bcbb9c7d/git/attribs.go#L27-L31

This function scans through each line of each `.gitattributes` file that it finds and returns some information about each one in a slice. Before inspecting each line, however, it first tries to determine if it's tracked by LFS:

https://github.com/git-lfs/git-lfs/blob/200b8f08cac8f28c46dbf59ae4ca4cf9bcbb9c7d/git/attribs.go#L44

For entries like:

```
*.dat lockable
```

this is not the case, as the string `""filter=lfs""` does not appear in that line. Since `lockable` is a part of the scope of Git LFS, include that check as a fallback when scanning each line.

This can go in the list of future improvements to make if we ever write a `.gitattributes` parser, but for now I think this will do.

Closes: https://github.com/git-lfs/git-lfs/issues/2497.

---

/cc @git-lfs/core 
/cc @mrbobbybobberson",2000,True,en,1
2526,7,10,5,Internals,ttaylorr,2017-08-30T16:44:40Z,33,0,2,5,"This pull request marks the `git-lfs(1) 'clone'` command as deprecated, and puts that deprecation behind a ""feature flag"".

Since merging #2511, `git clone` is as fast as `git lfs clone` in the majority of cases. To avoid the maintenance cost of the `git lfs clone` command, we mark it as deprecated here, and point callers in the direction of `git clone`. @technoweenie points out a great reason for doing this in https://github.com/git-lfs/git-lfs/issues/2466#issuecomment-322290355:

> > git lfs clone could certainly go 😄 ! Maybe we can mark it as deprecated with a warning on invocation in the 2.x series already?
> 
> I'm all for deprecating it. We should recommend users update Git, but keep the command around for any stragglers. Also, reject PRs for support of any _new_ `clone` flags, since new flags would mean you have a new enough Git with delay support :) 👍

Removing this command also decreases the size of LFS's surface area. Less commands that LFS provides on top of Git make the experience of using LFS more seamless and familiar. I think that's a good thing 👍 .

---

/cc @git-lfs/core 
/cc #2466 ",1125,True,en,1
2525,2,0,0,Internals,ttaylorr,2017-08-25T15:49:38Z,42,9,3,0,"This pull request makes the argument to `git.(*FilterProcessScanner)` a sentinel constant type instead of a string.

This change was promoted by https://github.com/git-lfs/git-lfs/pull/2511#discussion_r135134618, wherein @larsxschneider suggests that we should implement the `delayedStatusFromErr` by calling `statusFromErr`, and then promoting the ""success"" return value to ""delayed"".

I think this is a great idea, since it unifies the protocol-related parts of this code. However, it also tightly couples these two functions together: if `success` changes in the protocol, we have to update it not only in the `statusFromErr` function, but in the `delayedStatusFromErr` function as well.

To avoid this problem, let's introduce a sentinel type that transparently holds the protocol encoding by implementing the `fmt.Stringer` interface. We can then do comparisons on the named constant instead of the value, and isolate the changes to the constant's definition(s).

---

/cc @git-lfs/core 
/cc @larsxschneider 
/cc #2466 ",1024,True,en,0
2524,1,2,0,Internals,ttaylorr,2017-08-25T15:48:56Z,0,14,2,0,"This pull request disables running our integration tests on the 'next' branch of Git.

This change was originally introduced in order to test @larsxschneider's 'delay' patch in #2511, but that has since been merged into the master branch of Git, and is already covered under an existing test runner.

To save time on CI and avoid redundancy, let's remove the extraneous branch.

---

/cc @git-lfs/core 
/cc #2466 ",413,True,en,0
2516,15,9,10,Internals,ttaylorr,2017-09-13T21:27:38Z,162,3,6,26,"This pull request resolves an issue pointed out by @larsxschneider and @terrorobe in https://github.com/git-lfs/git-lfs/issues/2314, wherein a mysterious `io.EOF` error would appear after issuing a batch API request.

An EOF can occur given the following conditions:

1. LFS opens a HTTP connection to an LFS-compliant API server, with keep-alive.
2. The LFS server, or a proxy fronting connections to it times out the connection between batch requests, an io.EOF will occur.

To address this, we treat `io.EOF`'s as unexpected, and retry the request until successful, or a non-`io.EOF` error is returned.

I'd like to discuss a few other potential improvements:

- Adding an integration test for the io.EOF behavior: while researching this, I found `net/http.Hijacker`, a type that will allow us access to the TCP connection underlying a given `net/http.(*Request)` instance, but this is not implemented by `net/http/httptest`. I see a few alternatives: we could implement a custom listener that resolves this by embedding the `net/tcp.(*Conn)` in the request's context. We could also write our own server that does implement `http.Hijacker`.
- Should there be a limit to the number of times we retry batch requests? If so, should this be configurable, or a constant?
- Should we retry all requests, or just batch API ones?

I would love recommendations on the above.

Closes: https://github.com/git-lfs/git-lfs/issues/2314.

---

/cc @git-lfs/core 
/cc @technoweenie @larsxschneider @terrorobe for specific thoughts",1517,True,en,1
2515,2,0,0,Internals,ttaylorr,2017-08-18T16:06:27Z,48,48,5,0,"This pull request fixes a minor typo I noticed in https://github.com/git-lfs/git-lfs/pull/2514.

---

/cc @git-lfs/core ",120,True,en,5
2514,4,0,0,Internals,ttaylorr,2017-09-07T20:37:44Z,36,2,3,20,"This pull request fixes a bug pointed out by @mrbobbybobberson in https://github.com/git-lfs/git-lfs/issues/2494:

> But when we ""git lfs unlock"" a file that was previously locked, its readonly attribute is not set again, which leaves the file writeable (and robs us of the helpful reminder which files should be locked before edit).

This is because the following boolean was unset, and defaulted to its zero-value of `false`:

https://github.com/git-lfs/git-lfs/blob/621d1f821f73efcedc829dda43fd9c1fcf07c6ab/locking/locks.go#L131-L134

This is because we do not currently assign this to the value of `config.(*Configuration). SetLockableFilesReadOnly()`. This pull requests does that, and adds tests to guard against any regressions here.

Closes: https://github.com/git-lfs/git-lfs/issues/2494.

---

/cc @git-lfs/core 
/cc @mrbobbybobberson ",845,True,en,1
2511,20,18,27,Internals,ttaylorr,2017-08-24T22:28:17Z,323,33,14,8,"This pull requests teaches the `git-lfs-filter-process(1)` command the 'delay' capability that was proposed by @larsxschneider in https://github.com/git-lfs/git-lfs/issues/1632#issuecomment-259756814 and added to Git in https://github.com/git/git/commit/51b8aecabed1363f13c990320a50e1fb2aa3f696.

This implementation allows the process filter to respond with a `status=delayed` when asked to smudge the contents of a file that it does not already have in the local `.git/lfs/objects` cache.

If any items were delayed, Git will later ask for blobs that were available with the `list_available_blobs` command, which Git LFS will either respond with the immediately available blobs, wait until at least one becomes available, or respond with an empty set indicating that the transfer is complete.

To implement this, I added a new `delayedSmudge` helper function, which behaves the same way as `smudge()`, but instead adds the pointer to `*tq.TransferQueue` given as an argument.

Here are some benchmarks when running `git clone` on GitHub.com and a local copy of GitHub:

| | `lfs.concurrenttransfers=1` | `...=3` | `...=8` | `...=16` | `...=32` |
| ---: | --- | --- | --- | --- | --- | 
| `v2.13.2` | 
| github.com | 29.2297 | - | - | - | - |
| github.dev | 18.4657 | - | - | -| - | 
| |
| `v2.14.1.next` | 
| github.com | 45.6183 | 28.6867 | 14.9877 | 13.8893 | 13.7767 |
| github.dev | 9.02767 | 7.41867 | 7.70833 | 7.33933 | 7.71067 |

For a delta of:

| | `lfs.concurrenttransfers=1` | `...=3` | `...=8` | `...=16` | `...=32` |
| ---: | --- | --- | --- | --- | --- | 
| github.com | -43.3866 | 0.543 | 14.242 | 15.3404 | 15.453 |
| github.dev | 9.43803 | 11.04703 | 10.75737 | 11.12637 | 10.75503 |

Excluding outliers:

| | v2.13.2 | `v2.14.1.next` | delta | delta % |
| --- | --- | --- | --- | --- |
| github.com | 29.2297 | 17.8351 | **11.4s faster** | **164% faster** | 
| github.dev | 18.4657 | 7.840934 | **10.6s faster** | **236% faster** |

There were three big performance changes that impact this improvement:

1. https://github.com/git-lfs/git-lfs/pull/2483: Infinitely buffering the `tq.(*TransferQueue).Add()` function, which allows the `TransferQueue` to accept new items sent by Git, instead of waiting until the first batch of items were transferred.
2. https://github.com/git-lfs/git-lfs/pull/2506: Increasing the default number of concurrently running transfers from 3 to 8 allows LFS to take advantage of more network bandwidth and process items faster.
3. Not blocking on `list_available_blobs` until `tq.Wait()` returns. Instead, read from `tq.Watch()` until a read becomes blocking (via `select { case <-tq.Wait(): ... default: }`. This allows Git to perform the checkout while the `tq.(*TransferQueue)` is still transferring items.

Following this, I'd like to deprecate the `git lfs clone` command, since `git clone` is now as fast or faster than `git lfs clone` as of the latest tip of `git.git`.

EDIT: the each number is the average of 5 runs of a given command, with the outliers removed. The `benchmark` command is written as: [benchmark.sh](https://gist.github.com/ttaylorr/8236014ec48d3528f72530e5a9a2b27a#file-benchmark-sh). The `average-timings` command is written as: [average-timings.sh](https://gist.github.com/ttaylorr/8236014ec48d3528f72530e5a9a2b27a#file-average-timings-sh).

Closes: https://github.com/git-lfs/git-lfs/issues/2466.

---

/cc @git-lfs/core 
/cc @larsxschneider ",3422,True,en,11
2510,5,1,5,Internals,ttaylorr,2017-08-16T15:49:53Z,20,9,4,1,"This pull request follows up from a comment left by @technoweenie in https://github.com/git-lfs/git-lfs/pull/2507#pullrequestreview-56176535:

> I think including the warning when adding files would be good too. We can allow the commit, but I think it'd be better to warn them sooner (before push) rather than later (during fetch/clone).

To accomplish this, we teach `clean()` (and friends) to return the number of bytes read and written. We then perform the same check using the `possiblyMalformedSmudge` function, and optionally warn.

---

/cc @git-lfs/core ",562,True,en,0
2509,1,0,0,Externals,andyneff,2017-08-14T20:40:16Z,1,0,1,0,Added Linux Mint 18.2 (Sonya) to the upload script,50,False,en,0
2508,1,0,0,Internals,ttaylorr,2017-08-14T20:23:31Z,2,2,2,0,"This pull request enables the credential caching introduced in #2080 by default, as was noted (and forgotten about) in the original manpages.

---

/cc @git-lfs/core ",166,True,en,0
2507,1,1,0,Internals,ttaylorr,2017-08-15T15:50:39Z,1,2,1,0,"This pull request teaches the `git-lfs-smudge(1)` and `git-lfs-filter-process(1)` commands to display the 4gb object warning on all platforms, not just `runtime.GOOS == ""windows""`.

In situations where multiple collaborators are working on a repository among different operating systems, it is useful for a contributor running macOS to know that he/she/they can potentially cause an issue for another collaborator running Windows when they commit a file larger than 4gb. 

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/pull/2459",546,True,en,0
2506,1,2,0,Internals,ttaylorr,2017-08-14T20:23:20Z,3,3,3,2,"This pull request increases the default number of `lfs.concurrenttransfers` to 8.

---

/cc @git-lfs/core 
/cc #2466 ",117,True,en,0
2505,4,0,0,Internals,ttaylorr,2017-08-11T20:37:38Z,51,2,3,0,"This pull request fixes a bug pointed out by @jonico in https://github.com/git-lfs/git-lfs/issues/2492:

> * cd into a directory of a Git repository with a lockable file already tracked by lfs
> * call `git lfs lock` on that file, referring to it with its file name (no path) only
> * git lfs will report that it could not lock because it could not find the file

This is due to the fact that we attempt to set the write flag on a repository-relative path, which is only relative to your current working directory if you are in the root of your repository. For instance, if you lock a file `b.dat` in `sub`, in repository `/usr/local/src/repo`, the absolute lock path is `/usr/local/src/repo/sub/b.dat`, and the repository-absolute path is `sub/b.dat`.

We pass the later into the `tools.SetFileWriteFlag` which performs a working directory-relative `os.Stat()`. To fix this, we make the path absolute before passing into the `tools.SetFileWriteFlag`.

Closes: https://github.com/git-lfs/git-lfs/issues/2492.

---

/cc @git-lfs/core 
/cc @jonico ",1046,True,en,2
2502,3,0,0,Internals,ttaylorr,2017-08-11T16:20:19Z,47,0,3,0,"This pull request addresses https://github.com/git-lfs/git-lfs/issues/2490 by adding a warning to all LFS commands when an unsafe configuration is present in a repository's .lfsconfig:

> It might be useful to:
> 
> * print a warning when a setting is ignored, and
> * update [`docs/man/git-lfs-config.5.ronn`](https://github.com/git-lfs/git-lfs/blob/master/docs/man/git-lfs-config.5.ronn) to specify what ""safe keys"" can be used in `.lfsconfig`.

- 038e4a3: add a warning when unsafe keys are detected in the `.lfsconfig`
- 8970e6e: create a section in `git-lfs-config(5).ronn` containing a list of 'safe' keys.

Closes: #2490.

---

/cc @git-lfs/core 
/cc @aleb",663,True,en,1
2501,4,0,0,Internals,ttaylorr,2017-08-10T23:35:14Z,6,1552,25,0,"This pull request removes some unused dependencies that vendored.

Since these weren't referenced within the `github.com/git-lfs/git-lfs` , the compiled binary doesn't get any smaller; but it's good to get rid of some extra dependencies.

---

/cc @git-lfs/core ",262,True,en,6
2500,10,1,0,Internals,ttaylorr,2017-08-11T18:11:42Z,264,4,5,0,"This pull request teaches the authentication mechanism in package `lfsapi` to execute and share credentials with `GIT_ASKPASS` (and `core.askpass`) as described<sup>[[1](https://git-scm.com/docs/gitcredentials#_requesting_credentials)]</sup>:

> 1. If the `GIT_ASKPASS` environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user’s input is read from its standard output.
>
> 2. Otherwise, if the `core.askPass` configuration variable is set, its value is used as above.

Here's a breakdown of how things happened:

1. 12380c2: extract a `getCredentialHelper()` function to anticipate additional complication in determining which set of CredentialHelper implementations to use.
2. 04cec03: implement a `CredentialHelpers` type (defined as `type CredentialHelpers []CredentialHelper`) which acts like an `io.MultiReader` or `io.MultiWriter` for `CredentialHelper`s.
3. c95fcdd: implement a `AskPassCredentialHelper` to execute the program and arguments given as `GIT_ASKPASS` or `core.askpass`.
4. 9b36cc3: use the above two to properly implement `GIT_ASKPASS` and `core.askpass`.

Closes: #2285.

---

/cc @git-lfs/core ",1220,True,en,1
2499,1,2,1,Externals,aleb,2017-08-10T16:14:04Z,8,0,2,0,…ansfer agent,15,False,bn,1
2495,2,0,0,Internals,ttaylorr,2017-08-10T15:39:31Z,96,68,9,0,"This pull request fixes #2360 by teaching `*git/githistory/log.Task` to send a message and a time.Time in a single update.

This fixes a race condition that is fairly prevalent on CI. The race occurs when CPU cycles are missed in this test code:

https://github.com/git-lfs/git-lfs/blob/d7c2c79ca6ee04a85ee87fdc32d8d3de32ed2389/git/githistory/log/log_test.go#L105-L112

Causing a greater duration than was requested to elapse. This has the downstream effect of making the logger think that enough time has passed in order to not throttle writes to the `io.Writer` sink, thus indicating to the test that the throttling mechanism is broken, which ultimately failing the test.

Instead of checking the wall clock at channel read time, we share the time as it was when the message was created, which allows us to ""mock"" the time, guarenteing that the tests will pass.

The important diff is:

```diff
diff --git a/git/githistory/log/log.go b/git/githistory/log/log.go
index 52b485ae..b6f0e2f6 100644
--- a/git/githistory/log/log.go
+++ b/git/githistory/log/log.go
@@ -196,17 +196,15 @@ func (l *Logger) logTask(task Task) {
        logAll := !task.Throttled()
        var last time.Time

-       var msg string
-       for msg = range task.Updates() {
-               now := time.Now()
-
-               if logAll || l.throttle == 0 || now.After(last.Add(l.throttle)) {
-                       l.logLine(msg)
-                       last = now
+       var update *Update
+       for update = range task.Updates() {
+               if logAll || l.throttle == 0 || update.At.After(last.Add(l.throttle)) {
+                       l.logLine(update.S)
+                       last = update.At
                }
        }
```

Closes: https://github.com/git-lfs/git-lfs/issues/2360.

---

/cc @git-lfs/core  ",1798,True,en,4
2493,1,0,0,Internals,ttaylorr,2017-08-09T20:59:58Z,13,0,1,0,"This pull request fixes a concurrent map read/write issue in the credential cacher, which was pointed out by @canyou2014 in https://github.com/git-lfs/git-lfs/issues/2489.

When using the credential cacher with a `lfs.concurrenttransfers` setting greater than 1, concurrent transfer requests were susceptible to approve/reject credentials at the same time. See the lack of synchronization:

https://github.com/git-lfs/git-lfs/blob/621d1f821f73efcedc829dda43fd9c1fcf07c6ab/tq/adapterbase.go#L154-L172

https://github.com/git-lfs/git-lfs/blob/621d1f821f73efcedc829dda43fd9c1fcf07c6ab/tq/basic_download.go#L113

https://github.com/git-lfs/git-lfs/blob/621d1f821f73efcedc829dda43fd9c1fcf07c6ab/lfsapi/creds.go#L74-L80

This pull request fixes that issue by adding a `*sync.Mutex` guarding read and write access to the credential cache.

Closes: https://github.com/git-lfs/git-lfs/issues/2489.

---

/cc @git-lfs/core 
/cc @canyou2014",929,True,en,0
2488,1,0,0,Internals,ttaylorr,2017-08-09T16:21:10Z,32,1,2,0,"This pull request fixes a bug in `git-lfs-clean(1)` that was pointed out by @mohseenrm in https://github.com/git-lfs/git-lfs/issues/2487: 

> Issue: `git lfs clean` produces incorrect output for files over 1024 bytes

I introduced this bug in https://github.com/git-lfs/git-lfs/commit/482eba2176a39bfaa44f812af78b10e68015670d, wherein an optimization is introduced to combine readers when necessary to avoid blocking on `read()s` with no data when attached as a `process` filter.

482eba2176a39bfaa44f812af78b10e68015670d is implemented by passing a `fileSize` parameter, which is used to determine if all of the file has been read, or if there is more data waiting. When `git lfs clean` is invoked over `stdin`, it assumes the filesize is -1, which then fails the following check:

https://github.com/git-lfs/git-lfs/blob/6432d540bbca967fd91029f0d122131cd5ccb1d0/lfs/pointer_clean.go#L90-L95

and assumes that it has read the entire file.

To fix this, we teach `lfs.copyToTemp()` that when given a `fileSize` of -1, always continue reading from the given `io.Reader`.

Closes: https://github.com/git-lfs/git-lfs/issues/2487.

---

/cc @git-lfs/core 
/cc @mohseenrm",1166,True,en,1
2485,13,0,0,Internals,ttaylorr,2017-08-08T21:11:53Z,201,18,7,0,"This pull request fixes a bug pointed out by @jlbaxter in https://github.com/git-lfs/git-lfs/issues/2482#issuecomment-320790610:

> ```
> $ git lfs migrate import --include=""Pods/GoogleMaps/Frameworks/GoogleMaps.framework/googlemaps""
> migrate: Sorting commits: ..., done
> migrate: Rewriting commits: 100% (14/14), done
> 
> $ git push
> # ...
> remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.
> remote: error: Trace: b86b8906dcc9cea93584324a9d38247e
> remote: error: See http://git.io/iEPt8g for more information.
> remote: error: File Pods/GoogleMaps/Frameworks/GoogleMaps.framework/googlemaps is 123.08 MB; this exceeds GitHub's file size limit of 100.00 MB
> ```

When the `*git/githistory.HistoryRewriter` traverses through the subtrees, it ensures that the absolute path for every nested subtree is a pattern match for the given `--include` and `--exclude` filter set. This works fine when there are no nested subtrees, as every blob will have a fully-qualified path.

When there are nested subtrees however, consider the following: a migration wants to touch files in foo/bar/baz. To traverse into 'baz', we must first traverse through 'foo', and 'bar'. Visiting 'foo' calls `filter.Match(""foo"")`, which returns false, since `foo` is not a match of `foo/bar/baz`.

As shown above, the logic for subtree culling is incorrect. Rather than asking if a subtree is a Match() of a given filter, we must ask if it is a Prefix(). In other words, we are asking if children of a given subtree _could_ match the filepath filter.

To solve this, here's what happened:

1. d907934: extract `r.allows()`, which we will later use to determine whether to call `Match()`, or `HasPrefix()` based on the entry type being a blob or tree, respectively.
2. 3e8ab9b: teach `HasPrefix` to `Pattern` implementations in package `filepathfilter`.
3. 4942644: modify `r.allows()` to switch on the object type.
4. 45baf90: integration tests.

---

/cc @git-lfs/core ",2014,True,en,5
2483,3,0,0,Internals,ttaylorr,2017-08-07T20:52:25Z,82,26,1,0,"This pull request teaches `tq.(*TransferQueue).Add()` to accept new items into the `q.incoming` queue of items while a batch is processing.

This is done to improve the performance of the 'delay' filter capability (see: #2466 for more). Prior to this pull request, a delayed checkout was performed like:

1. Git and LFS handshake and negotiate supported capabilities. 
2. Git writes 100 items to LFS before LFS blocks while processing the items in the first batch.
3. If there are more items in the checkout, see step 2.
4. Checkout complete.

This means that we are doing nothing for however long it takes for Git to tell LFS about an entry in the checkout while a batch is processing. 

Instead, accept new items while a batch is processing and save the time that it takes for Git to tell LFS about new items in the checkout. To do so, we keep a secondary batch called ""pending"", which is appended to from the `<-q.incoming` channel while a batch is processing. When a batch finishes processing, the union of ""next"" and ""pending"" are taken, with the first 100 elements becoming the next batch, and the rest are given back to ""pending"". This process repeats itself until there are no items remaining.

In #1758, I said that the benefit to having `Add()` be a blocking operation until an item was accepted into a new batch was:

> **Back-pressure**. If the `*TransferQueue` can't accept more items, there's no sense in wasting a large amount of disk and CPU usage scanning the Git data. Previously, instances of `git rev-list`, `git cat-file` and `git cat-file --batch` would run ad nauseam even if the `TransferQueue` couldn't accept new items. Now, `Add()` will block after a maximum buffer depth has been reached. In other words, by default, `Add()` will accept 200 (twice the default batch size of 100) items before apply back-pressure up to the `gitscanner`, causing it to wait.

This statement is no longer true, since the amount of memory required per object is negligible as compared to the `tq` package as it was prior to #1758.

---

/cc @git-lfs/core 
/cc #2466 ",2073,True,en,0
2476,2,0,0,Internals,ttaylorr,2017-08-04T17:12:52Z,97,18,1,0,"This pull request teaches the `*tq.TransferQueue` to correctly alert `Watch()`-ers of duplicate transfers added to the queue.

Prior to this pull request, the `*tq.TransferQueue` would reject new incoming transfers for which an identical OID has already been seen. This behavior was intended to prevent the `*tq.TransferQueue` from performing duplicate work when it was unnecessary to do so.

When implementing the 'delay' capability (see more: #2466), I noticed that not all items I had `Add()`-ed to the `*tq.TransferQueue` would be sent back through the channel I had opened via `tq.(*TransferQueue).Watch() <-chan *tq.Transfer`. This is because, originally, the `*tq.TransferQueue` dropped new transfers that contained duplicate OIDs.

In this pull request, we change this behavior to ""remember"" a set of transfers who share the same OID. Only the first transfer in this set is ever transferred. If a new transfer is added that shares the same OID as a previous transfer, one of two things happens:

1. If the first transfer that shares the same OID as the new transfer is already completed, write the new transfer to any ""watcher"" channel immediately, since it is already completed.
2. If there isn't a completed transfer that shares the same OID, append it to the relevant set of transfers. Once the active transfer in that set finishes, alert any watcher that _all_ transfers are ""complete"".

This is required work for #2466.

---

/cc @git-lfs/core 
/cc #2466 ",1468,True,en,0
2475,1,0,0,Internals,ttaylorr,2017-08-03T17:58:01Z,12,3,1,0,"This pull request teaches the `git lfs unlock` command to appropriately respond to errs when calling `git.IsFileModified()`.

In https://github.com/git/git/commit/b9a7d55, Git causes `git.IsFileModified()` to return an error when asked for the status of files that do not exist. Since this is correct behavior on Git's part, teach `unlockAbortIfFileModified` to ignore errors when the file does not exist and `--force` is given.

---

/cc @git-lfs/core 
/cc #2470 #2466 ",470,True,en,0
2471,1,0,0,Internals,ttaylorr,2017-08-04T15:10:28Z,16,0,2,1,"This pull request exposes the `*pktline.WriteList()` method as a public API through the `*git.FilterProcessScanner` type.

In implementing support for the 'delay' capability (see: https://github.com/git-lfs/git-lfs/issues/2466), I discover that we need a way to write a list of packets to the `git-filter-client` when asked for a list of available blobs, as seen below:

```go
switch req.Header[""command""] {

// ...

case ""list_available_blobs"":
	s.WriteList(pathnames(available))
}
```

This pull request exposes and tests the `(*git.FilterProcessScanner).WriteList()` method to the public so it can be used in that manner.

This is required work for: https://github.com/git-lfs/git-lfs/issues/2466.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2466",776,True,en,1
2470,3,0,6,Internals,ttaylorr,2017-08-03T19:50:47Z,14,0,2,0,"This pull request teaches CircleCI and Travis how to run CI with the version of Git present at the tip of branch 'next'.

This is useful for adding the 'delay' capability to `git lfs filter-process` (see: https://github.com/git-lfs/git-lfs/issues/2466), since the 'delay' capability is not yet in master, or a released version of Git. This will give us a chance to test the 'delay' functionality out in CI before it's released in Git.

Once Git releases a version that contains https://github.com/git/git/commit/2841e8f81cb2820024804b9341577be1d0ce1240, we can revert this pull request.

This is required work for: https://github.com/git-lfs/git-lfs/issues/2466.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2466",738,True,en,0
2469,1,0,0,Internals,ttaylorr,2017-08-03T20:23:15Z,15,14,4,1,"This pull request changes the API of package `tq` as:

```diff
diff --git a/tq/transfer_queue.go b/tq/transfer_queue.go
index 67f4e9a7..2776e83f 100644
--- a/tq/transfer_queue.go
+++ b/tq/transfer_queue.go
@@ -640,3 +640,3 @@ func (q *TransferQueue) Wait() {
 // as it completes. The channel will be closed when the queue finishes processing.
-func (q *TransferQueue) Watch() chan string {
+func (q *TransferQueue) Watch() chan *tq.Transfer {
 	c := make(chan string, q.batchSize)
```

This is useful for supporting the 'delay' capability in the `git lfs filter-process` command. Previously, the `Watch()` channel returned an OID per completed object transfer, which we would then have to map back to a transfer name to determine which blobs were available when Git issued the `list_available_blobs` command.

With this pull request, we can instead maintain a `map[string]*tq.Transfer` (mapping from pathname to `*tq.Transfer`), which allows us to easily find, for example, the location on disk where the object is downloaded, as:

```go
m[req.Header[""pathname""]].Path
```

This is required work for https://github.com/git-lfs/git-lfs/issues/2466.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2466",1223,True,en,0
2468,4,0,4,Internals,ttaylorr,2017-08-03T22:36:19Z,16,11,3,1,"This pull request teaches the NegotiateCapabilities() method to return a string slice of capabilities supported by the `git-filter-client`.

Previously, we relied on an assumption that the list of required and supported capabilities negotiated between the `git-filter-client` and `git-filter-server` were constant (specifically: `capability=clean` and `capability=smudge`). Since `git` now supports the 'delay' capability, we need to be able to search through the list of capabilities supported by the `git-filter-client` to determine whether or not it is legal for `git lfs filter-process` to return a delayed checkout entry.

This is required work for: https://github.com/git-lfs/git-lfs/issues/2466.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2466",778,True,en,1
2467,1,0,0,Internals,ttaylorr,2017-08-04T15:10:45Z,8,0,2,1,"This pull request teaches the `*git/PktlineWriter`'s `Flush()` function to respond to a `nil` receiver.

This is required work for adding the 'delay' capability into LFS, as is described in https://github.com/git-lfs/git-lfs/issues/2466. When delaying a file during checkout, no data is written to the pkt-line stream ([source](https://github.com/git/git/blob/487fe1ffcd3b3a38477b7e564f235bb7d1b89ecc/Documentation/gitattributes.txt#L524-L538)), and therefore the `*git.PktlineWriter` is not initialized during that scanner cycle.

Instead of applying:

```diff
diff --git a/commands/command_filter_process.go b/commands/command_filter_process.go
index a622aaad..bb745d3d 100644
--- a/commands/command_filter_process.go
+++ b/commands/command_filter_process.go
@@ -77,6 +77,11 @@ func filterCommand(cmd *cobra.Command, args []string) {
 		}
 
+		var ferr error
+		if w != nil {
+			ferr = w.Flush()
+		}
+
 		var status string
-		if ferr := w.Flush(); ferr != nil {
+		if ferr != nil {
 			status = statusFromErr(ferr)
 		} else {
```

instead teach `w.Flush()` to return `nil` when called on a `nil` receiver.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2466",1186,True,en,1
2465,4,0,0,Internals,ttaylorr,2017-08-01T20:47:19Z,22,3,4,0,"This pull request fixes a two bugs that we've had since v2.0.0 which broke `$GIT_LFS_PROGRESS` for clean/smudge operations.

The first bug affects smudging files. Since the early days, we've used the `progress.CopyCallback` type to instruct the `*progress.progressLogger` type to log updates to a file given by `$GIT_LFS_PROGRESS`. [[source][1]]. When we introduced the `tq` subpackage, we followed up with https://github.com/git-lfs/git-lfs/pull/1775, which doesn't pass the given `progress.CopyCallback` to the `*tq.TransferQueue`.

To address this, we: 

1. e031ee6: teach a new option instance that can be given to the `tq` constructor for passing `progress.CopyCallback`s around.
2. 92fdd06: pass the given `progress.CopyCallback` into the `tq`, ensuring that updates are sent to `$GIT_LFS_PROGRESS`.
3. 5009112: Fix the direction from 'smudge' to 'download' the former of which is invalid [[source][2]]. 

The second bug was a hidden negated conditional in the `*progress.progressLogger` type's `Write()` function. The `*progress.progressLogger` keeps track of a bool `writeData` which is true if data is allowed to be written to the underlying `*os.File`, and false otherwise. [[source][3]].

In https://github.com/git-lfs/git-lfs/pull/1746, a change was made to move the false case into the conditional, i.e.:

```go
func (m *progressMeter) Write(b []byte) (n int, err error) {
        if m.writeData {
                return
        }
} 
```

But the conditional `if m.writeData` was not negated. This is fixed in https://github.com/git-lfs/git-lfs/commit/2708fbac4af428743626a14ee65f79bcf811afd9.

---

/cc @git-lfs/core 
/cc @joshaber

[1]: https://github.com/git-lfs/git-lfs/commit/0204cb2abe5415de4705e0d03ebae6412758ad5d
[2]: https://github.com/git-lfs/git-lfs/blob/v2.2.1/docs/man/git-lfs-config.5.ronn#L266-L267
[3]: https://github.com/git-lfs/git-lfs/commit/e4e1c5db523ac84f41958f003459ecb6246ed69f",1915,True,en,0
2463,1,0,0,Internals,ttaylorr,2017-07-31T21:54:14Z,26,0,2,0,"This pull request fixes a bug pointed out in https://github.com/git-lfs/git-lfs/issues/2452, where `git lfs track` cannot detect paths already tracked in a repository's `.gitattributes` file(s) when the current working directory is symlinked.

The issue arrises when we try and compare the attr path in `.gitattributes`, with the given argument(s). To do this, we first:

1. Relativize the result of calling `os.Getwd()` against the Git repository's root path. This will give us `/dir` for a directory `/Users/ttaylorr/go/src/github.com/git-lfs/git-lfs/dir` and a repository root of `/Users/ttaylorr/go/src/github.com/git-lfs/git-lfs`.
2. Compare, for all arguments, all known tracked patterns in any `.gitattributes` file the fully qualified path in the file, with the relativized filepath given as an argument.
3. If they are equal, the filepath is already tracked: `""<file>"" is already supported`.
4. Otherwise, perform some additional equality checks and then add optionally change the `.gitattributes` file.

Step 2 will fail when the current working directory is symlinked, because the relativized paths _may_ look different.

To fix this, we first follow the links up the chain to the apex and instead compare against that path.

Closes: #2452.

---

/cc @git-lfs/core 
/cc #2452 ",1287,True,en,1
2462,2,0,0,Internals,ttaylorr,2017-07-31T21:00:31Z,16,7,1,0,"This pull request teaches `script/build.go` (accessible via `script/boostrap`) how to pass `-ldflags` and `gcflags` to the Go compiler, if they are given.

This is useful for debugging the `git-lfs` binary, where DWARF tables should be included and compiler optimizations and inlining should be disabled. I originally implemented this as:

```diff
diff --git a/script/build.go b/script/build.go
index fba6292a..f42cad59 100644
--- a/script/build.go
+++ b/script/build.go
@@ -23,6 +23,7 @@ var (
 	BuildArch  = flag.String(""arch"", """", ""Arch to target: 386, amd64"")
 	BuildAll   = flag.Bool(""all"", false, ""Builds all architectures"")
 	BuildDwarf = flag.Bool(""dwarf"", false, ""Includes DWARF tables in build artifacts"")
+	BuildDebug = flag.Bool(""debug"", false, ""Prepares a git-lfs binary useful for debugging"")
 	ShowHelp   = flag.Bool(""help"", false, ""Shows help"")
 	matrixKeys = map[string]string{
 		""darwin"":  ""Mac"",
@@ -31,7 +32,7 @@ var (
 		""windows"": ""Windows"",
 		""amd64"":   ""AMD64"",
 	}
-	LdFlags []string
+	LdFlags, GcFlags []string
 )
 
 func mainBuild() {
@@ -55,10 +56,14 @@ func mainBuild() {
 			""github.com/git-lfs/git-lfs/config.GitCommit=""+string(cmd),
 		))
 	}
-	if !*BuildDwarf {
+	if !*BuildDwarf || !*BuildDebug {
 		LdFlags = append(LdFlags, ""-s"", ""-w"")
 	}
 
+	if *BuildDebug {
+		GcFlags = append(GcFlags, ""-N"", ""-l"")
+	}
+
 	buildMatrix := make(map[string]Release)
 	errored := false
 
@@ -148,6 +153,9 @@ func buildCommand(dir, buildos, buildarch string) error {
 	if len(LdFlags) > 0 {
 		args = append(args, ""-ldflags"", strings.Join(LdFlags, "" ""))
 	}
+	if len(GcFlags) > 0 {
+		args = append(args, ""-gcflags"", strings.Join(GcFlags, "" ""))
+	}
 	args = append(args, ""-o"", bin, ""."")
 
 	cmd := exec.Command(""go"", args...)
```

But I think the `-gcflags` and `-ldflags` approach is more flexible.

---

/cc @git-lfs/core ",1844,True,en,0
2461,1,0,0,Internals,ttaylorr,2017-07-31T21:00:24Z,83,171,10,0,"This pull request follows up with https://github.com/git-lfs/git-lfs/pull/2420#issuecomment-315569552 to promote the `IndexVersion` const type into an interface, as follows:

```go
// IndexVersion is a constant type that represents the version of encoding used
// by a particular index version.
type IndexVersion interface {
	// Name returns the name of the object located at the given offset ""at"",
	// in the Index file ""idx"".
	//
	// It returns an error if the object at that location could not be
	// parsed.
	Name(idx *Index, at int64) ([]byte, error)

	// Entry parses and returns the full *IndexEntry located at the offset
	// ""at"" in the Index file ""idx"".
	//
	// If there was an error parsing the IndexEntry at that location, it
	// will be returned.
	Entry(idx *Index, at int64) (*IndexEntry, error)

	// Width returns the number of bytes occupied by the header of a
	// particular index version.
	Width() int64
}
```

Previously, `IndexVersion` was defined as:

```go
type IndexVersion uint32
```

and we had two publicly exported constants:

```go
package git/odb/pack

const (
        V1 IndexVersion = iota + 1
        V2
)
```

This was great, but forced us into a lot of switching like:

```go
func (v IndexVersion) Width() int {
        switch v {
        case V1: // ...
        case V2: // ...
        }
}
```

This pull request pulls out the three responsibilities the IndexVersion type had into three distinct interface methods, which are implemented by concrete types `*pack.V1` and `*pack.V2`.

This has the added benefit of removing some of the duplicated `bytes.Compare` logic out of the `IndexVersion` implementations, and into a more appropriate home in `func (*Index) Entry()`.

---

/cc @git-lfs/core 
/cc #2415 ",1740,True,en,5
2460,3,0,0,Internals,ttaylorr,2017-07-31T19:24:05Z,27,22,5,0,"This pull request sets the default value of `--above` in `git lfs migrate info` to be empty, which in fact means that it will be set to 0b.

As I recall, the reason we added this was to give a better sense of which files were taking up the most space in a repository, if, for instance, not all files of a given extension are uniformly large/small.

In practice, I've found that this can be potentially confusing to first-time users of the command. By setting the default to empty, we encourage a flow of:

1. Run `git lfs migrate info`, which has reasonable defaults.
2. See that a given extension(s) is/are taking up lots of space.
3. Drill down into `git lfs migrate info --include=""*.ext"" --above=""3mb""`.

---

/cc @git-lfs/core ",732,True,en,2
2459,3,0,0,Internals,ttaylorr,2017-07-31T19:24:14Z,63,32,5,0,"This pull request teaches the `git lfs {smudge,filter-process}` commands to warn when smudging blobs larger than 4 GB on Windows.

From https://github.com/git-lfs/git-lfs/issues/2434#issuecomment-317582466:

> [...] I ran this by a Git core dev, and he mentioned that Git on Windows does not support files over 4GB. Unfortunately, this is not something we can fix in LFS. The best we can do now add a warning when large objects are added.

This pull request adds that warning.

Here's a quick breakdown of how things happened:

1. 3a080f9: teach `smudge()` (et. al.) to return `(int64, error)` as `io.Copy` does, to indicate the number of bytes smudged by a call to that function.
2. f6beec6: use the return value from that function to determine and potentially warn about files larger than 4gb being copied into the worktree.

@technoweenie also mentioned:

> [...] I think we should add an early warning in the filter smudge and process code, perhaps linking to a page offering this workaround.

I originally added a link back to https://github.com/git-lfs/git-lfs/issues/2434, but thought that adding a section to the manpage would be sufficient, and perhaps a little cleaner, since the manpages are distributed in the binary and don't require you to be online to view them.

Closes: https://github.com/git-lfs/git-lfs/issues/2434.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2434",1410,True,en,0
2458,1,0,0,Internals,ttaylorr,2017-07-31T19:29:17Z,4,0,1,0,"This pull request adds additional assertions to the ""empty pointers"" test in test/test-malformed-pointers.sh file, following https://github.com/git-lfs/git-lfs/issues/2447 and https://github.com/git-lfs/git-lfs/issues/2449.

By checking the length of `git cat-file -p :empty.dat`, we ensure that an empty file gets cleaned as an empty pointer.

---

/cc @git-lfs/core 
/cc @mathstuf ",383,True,en,1
2457,1,0,0,Internals,ttaylorr,2017-07-31T18:53:58Z,9,0,2,0,"This pull request fixes a failing test pointed out in https://github.com/git-lfs/git-lfs/issues/2456:

> ```
> --- FAIL: TestClosingAnObjectDatabaseMoreThanOnce (0.01s)
>         Error Trace:    object_db_test.go:206
> 	Error:		Expected nil, but got: Error in git cat-file --batch: exit status 128 fatal: Not a git repository (or any of the parent directories): .git
>
> FAIL
> FAIL	github.com/git-lfs/git-lfs/git/odb	0.056s
> ```

This issue occurs in the `TestClosingAnObjectDatabaseMoreThanOnce` test, which asserts that closing an `*ObjectDatabase` twice fails when mounted in a directory `/tmp`. Since `/tmp` doesn't contain a Git repository, the first call to `Close()` calls close on the `*ObjectScanner` and returns an error caused by a non-zero exit code when killing `git-cat-file(1) --batch`.

To address this: we make the `*ObjectScanner` field be nil (and teach `*ObjectScanner.Close()` how to respond to a call on a nil receiver), therefore bypassing the error.

Closes: #2456.

---

/cc @git-lfs/core 
/cc #2456 ",1027,True,en,1
2455,2,0,0,Internals,ttaylorr,2017-07-31T18:49:05Z,33,2,2,0,"This pull request fixes a bug pointed out in #2450, via https://github.com/git-lfs/git-lfs/issues/2450#issuecomment-319116502:

> ```
> ~/D/harfbuzz (master) $ git lfs migrate info
> migrate: Sorting commits: ..., done
> migrate: Rewriting commits: NaN% (0/0), done
> ```

When there are zero commits to migrate, the migrator should show that it is 100% of the way done, not `NaN%`.

Since we guarantee that the `*PercentageTask` cannot be overcounted in de896f2, we guarentee that 100% is a correct value for all valid calls to the `Count()` method in 78195ec.

---

/cc @git-lfs/core 
/cc #2450 ",597,True,en,1
2453,12,4,15,Externals,larsxschneider,2017-08-24T20:24:40Z,226,168,12,25,"Git LFS invokes Git for various actions internally. A new Git instance is started with the default Git config and therefore might invoke another Git LFS process via the filter machinery. I have noticed that in #2439.

Teach Git LFS to invoke Git with disabled LFS filters to prevent unnecessary Git LFS processes.

I recommend to review the changes by commit.

---

**Attention: I haven't performed extensive testing on this, yet.**",432,True,en,0
2449,1,0,0,Externals,mathstuf,2017-07-31T18:53:32Z,3,0,1,2,"Closes #2447.

---
Cc: @technoweenie ",37,True,pl,0
2443,1,1,0,Externals,rudineirk,2017-07-28T02:00:11Z,1,0,1,1,"This pull-request adds fedora/26 to the list of targets for Packagecloud, which will make all future builds available on the latest release of Fedora.",150,False,en,0
2441,1,1,0,Internals,ttaylorr,2017-07-28T01:26:51Z,1,1,1,1,"This pull request addresses a potential integer overflow when performing the binary search used to find objects in pack index files. When the sum of the two boundaries is large, it can overflow the maximum size of type `int64`, causing undefined behavior.

As @peff points out in https://github.com/git-lfs/git-lfs/pull/2423#pullrequestreview-52074137:

> [...] this is subject to overflow when the size of the bounds approaches the capacity of your left/right integer types.

He suggests:

> One overflow-safe way is `bounds.Left() + (bounds.Right() - bounds.Left()) / 2`.

Since the `(bounds.Right() - bounds.Left())` sub-expression is evaluated first, that will never overflow, since they are both `int64`s.

EDIT: this was tested in the same manner as described in https://github.com/git-lfs/git-lfs/pull/2423#issuecomment-317777195, and produced the same results (`OK`) both before and after this change:

```bash
~/g/git-lfs (master) $ OBJECTS=""$(git verify-pack -v .git/objects/pack/pack-5b2c32d3c1d5708b8edc9abfa5f34c7e2e431c2f.idx | cut -d '' -f 1 | grep -E ""^[[:alnum:]]{40}$"")""

~/g/git-lfs (master) $ echo ""$OBJECTS"" | go run ~/github/verify-pack/cmd/verify-pack/main.go .git/objects/pack/pack-5b2c32d3c1d5708b8edc9abfa5f34c7e2e431c2f.idx | shasum -a 256
7bfa44dd8fb4df5823a7a31db81c8b4cf0204485f55c9f41b624f757028ced5e  -

~/g/git-lfs (git-odb-pack-int-overflow) $ git checkout git-odb-pack-int-overflow
Switched to branch 'git-odb-pack-int-overflow'
Your branch is up-to-date with 'origin/git-odb-pack-int-overflow'.

~/g/git-lfs (git-odb-pack-int-overflow) $ echo ""$OBJECTS"" | go run ~/github/verify-pack/cmd/verify-pack/main.go .git/objects/pack/pack-5b2c32d3c1d5708b8edc9abfa5f34c7e2e431c2f.idx | shasum -a 256
7bfa44dd8fb4df5823a7a31db81c8b4cf0204485f55c9f41b624f757028ced5e  -
```

---

/cc @git-lfs/core @peff
/cc #2415 ",1840,True,en,0
2440,1,0,0,Internals,ttaylorr,2017-07-25T19:07:35Z,531,2,17,0,"This pull request vendors the `golang.org/x/exp/mmap` package required to power the `git/odb/pack` package.

We currently don't require use of the `mmap` package, but will eventually in order to open the index files.

Unfortunately, Glide doesn't currently support vendoring a subset of an apex package, so we manually remove the other packages within `golang.org/x/exp` that we don't require, via the following in `script/vendor`:

```bash
# Remove all subpackages of golang.org/x/exp/... which aren't 'mmap'.
find ./vendor/golang.org/x/exp/* -type d | grep -v mmap | xargs rm -rf
``` 

---

/cc @git-lfs/core 
/cc #2415 ",623,True,en,2
2438,6,0,0,Internals,ttaylorr,2017-08-10T15:42:19Z,66,18,3,16,"This pull request teaches the `git-lfs-status(1)` command to indicate when objects are missing.

```
On branch master

Git LFS objects to be committed:

	a.dat (?: <missing> -> LFS: 3e23e81)

Git LFS objects not staged for commit:
```

Where previously, an error parsing the output from `git-cat-file(1) --batch` that occurred [here][1] would propagate that parse error up the stack, and eventually to [here][2] and [here][3] caused the command to exit in a dirty state.

The issue results from the fact that `git-cat-file(1) --batch` formats it output differently when the object being asked for is missing<sup>[[1](https://git-scm.com/docs/git-cat-file#_batch_output)]<sup>: 

> If a name is specified on stdin that cannot be resolved to an object in the repository, then cat-file will ignore any custom format and print:
>
> ```
> <object> SP missing LF
> ```

To address this, parse the `<object> SP missing LF` case correctly, and add a special `'<missing>'` tag to the output of `git-lfs-status(1)`.

Other considerations:

1. `git-cat-file(1) --batch` can generate output we don't understand when `--follow-symlinks` is given, but we don't currently do that, so we're safe.
2. Only one test case is added here (missing source blob), since the destination blob can't be missing as it hasn't been written to the object database yet and is instead read from the worktree/index.
3. This does not change the formatting of `git lfs status --{json,porcelain}`. I don't think we can address this without breaking existing scripts.

Closes: https://github.com/git-lfs/git-lfs/issues/2431.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2431

[1]: https://github.com/git-lfs/git-lfs/blob/v2.2.1/git/object_scanner.go#L200-L203
[2]: https://github.com/git-lfs/git-lfs/blob/v2.2.1/commands/command_status.go#L188-L190
[3]: https://github.com/git-lfs/git-lfs/blob/v2.2.1/commands/command_status.go#L161-L169",1925,True,en,1
2437,2,0,0,Internals,ttaylorr,2017-07-24T19:48:06Z,33,11,2,0,"This pull request introduces a new API to the `git/odb/pack` package: `pack.IsNotFound(err)`.

I took this idea from the `os` package in the standard library, which returns errors from `os.Stat()` that satisfy `os.IsNotExist()`<sup>[[1](https://golang.org/pkg/os/#IsNotExist)]</sup>:

> IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist.
>
> It is satisfied by ErrNotExist as well as some syscall errors.

This pull request is designed to make calling `Entry()` more ergonomic. Previously, calls from another package would look like this:

```go
var idx *pack.Index

entry, err := idx.Entry([]byte{...})
if err != nil {
        return err
}

if entry == nil {
        return nil
}

// ...
```

Whereas now it could look like:

```go
var idx *pack.Index

entry, err := idx.Entry([]byte{...})
if err != nil {
        if pack.IsNotExist(err) {
                 return nil
        }
        return err
}

// ...
```

---

/cc @git-lfs/core 
/cc #2415 
",1015,True,en,1
2436,3,0,0,Internals,ttaylorr,2017-07-24T19:48:12Z,78,74,9,0,"This pull request applies a few cosmetic changes to the `git/odb/pack` package introduced in the last series of PRs.

Here's a quick breakdown:

- bdc9ff0: rename `f io.ReaderAt` to `r io.ReaderAt` in the `*Index` type. `f` was originally chosen because it ordinarily represents an `mmap(2)`'d file, but it can be more generally an `io.ReaderAt`.
- edd354e: un-export index offset-related constants, by prepending them with `index<t>`.
- 28ae318: fix a few places that I imported `errors` from the standard library instead of our preferred `github.com/git-lfs/git-lfs/errors` package.

---

/cc @git-lfs/core 
/cc #2415 ",620,True,en,4
2429,1,7,7,Externals,aleb,2017-07-31T21:51:00Z,400,44,11,11,"Some custom transfer agents figure out everything by themselves and don't need
any authentication or transfer details from the API server.

Added the `lfs.standalonetransferagent` config option for specifying which
custom agent should be used directly.
",253,False,en,3
2426,2,0,0,Externals,ssgelm,2017-07-24T21:28:39Z,799,138,13,6,As discussed in #2390 this updates to the latest git HEAD of github.com/pkg/errors and fixes a bug related to a change in internal structure.,141,False,en,5
2425,1,0,0,Externals,ssgelm,2017-07-17T20:00:56Z,3,0,1,0,See subject.  There are a few files that are sometimes created when building debs (I think relating to newer versions of debian tools?),135,False,en,0
2423,3,2,1,Internals,ttaylorr,2017-07-24T17:59:44Z,404,0,4,8,"This pull request uses https://github.com/git-lfs/git-lfs/pull/2421 & https://github.com/git-lfs/git-lfs/pull/2422 to implement a [binary search][1] and entry parse operation over V1 and V2 index files. This is used to determine a given object's offset in the corresponding packfile.

In https://github.com/git-lfs/git-lfs/commit/b761e15ee4eac7255721f88a21d46ef80f9fcab4, we implement a `*bounds` type, which stores a `left` and `right` index used for the binary search. This is done in order to implement the `Equal()` method on `*bounds` in order to detect infinite loops, as:

```go
var last *bounds

for bounds.Left() < bounds.Right() {
  if last.Equal(bounds) {
    // If the bounds are unchanged, that means either that the object does not
    // exist in the packfile, or the fanout table is corrupt.
    //
    // Either way, we won't be able to find the object.  Return immediately to
    // prevent infinite looping.
    return nil, nil
  }
  last = bounds

  // ...
}
```

In https://github.com/git-lfs/git-lfs/commit/0c15b26c215f4b6372019906daed6bbb1fa3938c, we use the `*bounds` type implement a binary search through the index files in order to find the packfile offset for a given object. This works like the following:

1. Use the fanout table to figure out a lower and upper bound for where the object could be within the index file.
  a. If the bounds are unchanged from the last search, return immediately: we have a corrupt index.
  b. If `left >= right`, we don't have the object, so return `(nil, nil)` immediately.
2. For those offsets, pick a midpoint and try and parse the entry at that location.
3. If the entry at that location has a SHA-1 greater than the one we're looking for, narrow our search to the lower half of our sorted list.
4. If the entry at that location has a SHA-1 lesser than the one we're looking for, narrow our search to the upper half of our sorted list.
5. If the entry has a SHA-1 equal to the one that we were looking for, return it immediately.
6. Otherwise, with the modified bounds, go to step 2.

---

/cc @git-lfs/core @peff
/cc #2415 

[1]: https://en.wikipedia.org/wiki/Binary_search_algorithm",2151,True,en,2
2422,4,0,0,Internals,ttaylorr,2017-07-24T17:44:35Z,242,9,7,8,"This pull request implements object searching for v1 index files, and is the third in the series started by #2420.

It implements the v2 index lookup, similar to that implemented in https://github.com/git-lfs/git-lfs/pull/2421.

The v2 index format varies slightly from v1. Instead of placing the object offset and object name next to each other, they are split into separate ""tables"". v2 also knows how to store a cyclic redundancy check for each object, as well how to encode 8-byte unsigned offsets.

More specifically, the structure is as follows:

1. A magic 4-byte header
2. A 4-byte version tag (network order)
3. 256 4-byte network order unsigned integers comprising the L1 fanout table.
4. The 20-byte object names, in order.
5. 4-byte entries for each object giving the CRC in network byte order.
6. 4-byte ""small"" offsets. If the most significant bit of this is set (i.e., `x&0x8000000 > 1`), the rest of the offset encodes the location of an 8-byte offset in the same file.

The `v2Search` function introduced in this pull request understands the above format and can search through it.

---

/cc @git-lfs/core @peff
/cc #2415 ",1139,True,en,3
2421,3,0,0,Internals,ttaylorr,2017-07-24T17:18:31Z,228,1,6,8,"This pull request implements object searching for v1 index files, and is the second in the series started by #2420.

The main goal of this pull request is to implement a function that the `IndexVersion.Search()` function can call into, as:

```go
func (i *IndexVersion) Search(idx *Index, name []byte, at uint64) (*IndexEntry, int, error) {
        switch i {
        case V1:
                return v1IndexSearch(idx, name, at)
        }

        panic(...)
}
```

This implements the search functionality (i.e., find an object, or return a comparison value of where to search next) for V1 pack files.

I estimate that it's unlikely LFS will parse many v1 packfiles during regular usage. Git stopped writing v1 packfiles near https://github.com/git/git/commit/c553ca25bd60dc9fd50b8bc7bd329601b81cee66, which was first released in the v1.5.2 series, which was released earlier than our minimum supported version of Git.

That being said, I think it's important for LFS to be able to parse all packfiles, since we won't have `git-cat-file(1)` to fallback on if we can't parse an earlier packfile version.

V1 packfiles have the following structure:

1. 256 4-byte network order unsigned integers, comprising the L1 fanout table.
2. One 24 byte entry per object, composed of a 4-byte network byte ordered unsigned integer (the object offset) and 20 bytes for the object name.

The `v1Search` function understands the above structure and does the appropriate search/comparison operation.

---

/cc @git-lfs/core @peff
/cc #2415 ",1525,True,en,3
2420,3,1,0,Internals,ttaylorr,2017-07-24T17:02:15Z,240,0,9,8,"This pull request introduces the `*Index` type, and creates a new package `git/odb/pack` to hold it.

The goal of this new package is twofold:

1. Parse index files to find packfile offsets.
2. Parse and assemble objects within packfiles.

This pull request is the first in a series of four aimed at accomplishing the first goal. Contained in this pull request is the scaffolding necessary to get us going for parsing actual index files. That means:

- An `*Index` type, which will eventually get a `Entry([]byte) uint64, error)` method to resolve object names to their offsets in a packfile.
- An `IndexVersion` type, which will learn how to parse index entries in later pull requests in this series.
- A `DecodeIndex()` function, which will learn how to use the above `IndexVersion` instances to parse the index header, and eventually find objects in the index.

To address a point raised in #2415:

> @peff wisely points out that I can use [`mmap(2)`](https://en.wikipedia.org/wiki/Mmap) in order to avoid the `seek(1)` cost of bouncing around a file on disk. To me, this means that the 2nd option of lazily loading each entry makes more sense, since:

This is the implementation that I pursued in this series. The idea is that, in order to save memory (and to avoid parsing objects that wont be searched for) we delay parsing index entires until they are asked for.

The next two pull requests in the series will introduce implementations of `IndexVersion.Search()` which have the following signature:

```go
func (i IndexVersion) Search(idx *Index, name []byte, at uint64) (*IndexEntry, int, error) {
        // ...
}
```

Or, in other words: given an index, an object to search for, and a location to search in, return either an entry (match), a comparison value (no match), or an error otherwise.

We can use this comparison value (see: `bytes.Compare()`) in order to direct the next window of our binary search through the index file in order to produce an entry in `O(log(n))` time.

---

/cc @git-lfs/core 
/cc #2415 ",2027,True,en,4
2410,1,0,0,Internals,ttaylorr,2017-07-11T18:00:50Z,17,0,2,0,"This pull request follows up on a comment left by @technoweenie<sup>[[1][1]]</sup>:

> Also, `git lfs install --manual` doesn't work. I think it just needs [this `update` flag](https://github.com/git-lfs/git-lfs/blob/2fe41e90149a8d02c8d33e4b25f2a314bda1e346/commands/command_update.go#L62).

This teaches the `--manual` mode to `git lfs install`, by hijacking flags owned by the `git-lfs-update(1)` command (since `git-lfs-install(1)` runs `updateCommand()` to implement itself).

I've added a note that this should be addressed in the future, but I think that this is ship-able today.

---

/cc @git-lfs/core 

[1]: https://github.com/git-lfs/git-lfs/pull/2392#issuecomment-314495588",684,True,en,0
2404,1,0,0,Internals,ttaylorr,2017-07-10T18:54:48Z,11,1,1,0,This backports #2393.,21,False,en,0
2403,1,0,0,Internals,ttaylorr,2017-07-10T19:08:58Z,3,3,3,0,"This pull request bumps the version tag to `2.2.2-pre` as in #2385. It is intended to be merged after #2402 in anticipation of a potential v2.2.2 release.

---

/cc @git-lfs/core ",179,True,en,0
2402,2,0,0,Internals,ttaylorr,2017-07-10T19:08:42Z,27,4,5,0,"This pull request releases v2.2.1. It is still pending on a set of open backports waiting to merge into the release-2.2 tree.

Heads up: @git-lfs/releases -- v2.2.1 is scheduled to be released on Monday, July 10th, 2017.

---

/cc @git-lfs/core 
/cc @git-lfs/releases ",268,True,en,0
2401,1,0,0,Internals,ttaylorr,2017-07-10T16:59:01Z,48,2,4,0,This backports #2389.,21,False,en,2
2400,1,0,0,Internals,ttaylorr,2017-07-10T16:58:50Z,2,2,1,0,This backports #2388.,21,False,en,0
2399,2,1,0,Internals,ttaylorr,2017-07-10T17:50:59Z,2,786,16,0,This backports #2386.,21,False,en,2
2397,1,0,0,Internals,ttaylorr,2017-07-10T16:58:43Z,16,4,2,0,This backports #2383.,21,False,en,1
2396,1,0,0,Internals,ttaylorr,2017-07-10T16:58:36Z,5,4,2,0,This backports #2382.,21,False,en,0
2395,1,0,0,Internals,ttaylorr,2017-07-10T16:58:29Z,2,2,1,0,This backports #2377.,21,False,en,0
2394,1,0,0,Internals,ttaylorr,2017-07-10T16:58:21Z,26,9,2,0,This backports #2374.,21,False,en,1
2393,10,3,0,Internals,ttaylorr,2017-07-10T18:01:25Z,11,1,1,3,"This pull request adds tracing output to the `git lfs install`, `git lfs uninstall`, and `git lfs upgrade` commands when installing `.git/hooks`, similar to that suggested in: https://github.com/git-lfs/git-lfs/issues/2363#issuecomment-311985990 & https://github.com/git-lfs/git-lfs/issues/2363#issuecomment-311994628.

This should make it easier to diagnose situations where hooks aren't being installed correctly, as we'll now have information about:

1. Which files are being `stat(1)`-ed
2. Which directories are being created
3. Which files are being written
4. Whether files that do exist are marked as upgrade-able.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2363",698,True,en,0
2392,10,4,0,Internals,ttaylorr,2017-07-12T15:30:09Z,126,26,6,5,"This pull request indents the contents of both `git lfs install --manual` and `git lfs update` (when there are conflicting hooks).

This was suggested by @ELLIOTTCABLE in https://github.com/git-lfs/git-lfs/issues/2368.

Before implementing this, I was wary that it could cause issues where the text is copied line-wise (including the tabs) into the hook file. This is prevented by stripping leading and trailing whitespace from the given string, as well as leading whitespace on a per-line basis (via: 3705794 & fc62f34).

Closes: https://github.com/git-lfs/git-lfs/issues/2368.

---

/cc @git-lfs/core ",603,True,en,3
2389,7,1,0,Internals,ttaylorr,2017-07-05T20:45:44Z,48,2,4,0,"This pull request skips the final `git-checkout(1)` that we do on repositories after migrating them via `git-lfs-migrate(1) import`.

This was pointed out in https://github.com/git-lfs/git-lfs/issues/2380#issuecomment-313148926.

Before this PR:

```
~/D/foo.git (master) $ git rev-parse --is-bare-repository
true

~/D/foo.git (master) $ git lfs migrate import
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (1/1), done
  master        85d2a9aa2e1fa73548092096f563688e6cd3f2c6 -> a65ddcf4418a78b9e414ead8a5c86c4aebfbb0e1
migrate: Updating refs: ..., done
Error running git [checkout --force]: 'fatal: This operation must be run in a work tree' 'exit status 128'
```

Here's a quick look at how things went down:

1. 2a2a76c: teach `git.IsBare()` to determine if a repository is bare (via `git-rev-list --is-bare-repository`).
2. ca61a20: only call `git.Checkout()` if `!git.IsBare()`.
3. f3fc56c: teach `make_bare` to convert a full repository into a bare one
4. 9b0a2e8: call `git-lfs-migrate(1)` on a bare repository to ensure it doesn't fail.

---

/cc @git-lfs/core 
/cc #2380",1102,True,en,2
2388,2,0,0,Internals,ttaylorr,2017-07-05T20:46:44Z,2,2,1,0,"This pull request changes an `*os.File.Close()` call into an `os.Remove()` call to avoid keeping many objects in `.git/lfs/tmp` after migrations (as pointed out in: https://github.com/git-lfs/git-lfs/issues/2380#issuecomment-313134306).

EDIT: I deliberately skipped checking the return value from `os.Remove()`, since the presence of files in the `.git/lfs/tmp` directory doesn't affect the migration, so it's non-fatal if they can't be removed.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2380#issuecomment-313134306",545,True,en,0
2386,1,0,0,Internals,ttaylorr,2017-07-05T20:46:55Z,2,786,16,0,"This pull request removes the vendored dependency `github.com/cheggaaa/pb`. Its last usage was removed in #2377.

---

/cc @git-lfs/core 
/cc #2377 @ssgelm ",156,True,en,2
2385,1,0,0,Internals,ttaylorr,2017-07-05T15:23:22Z,3,3,3,0,"This pull request bumps the version on the `release-2.2` branch to '2.2.1-pre', which will be the next version released from this branch.

To my memory, we haven't done `-pre` version tag bumps on the `release-*` branches before, but I think that this is a good pattern to start, since it will make it easier to distribute builds outside of the release cycle.

If this seems 👎, though, I'm happy to pass on it.

---

/cc @git-lfs/core  ",439,True,en,0
2384,1,0,0,Internals,ttaylorr,2017-07-05T15:23:39Z,3,3,3,0,"This pull request bumps the version on master to `2.3.0-pre`, since the next version released from master will be 2.3.0.

---

/cc @git-lfs/core ",145,True,en,0
2383,3,3,0,Internals,ttaylorr,2017-07-05T20:46:21Z,16,4,2,0,"This pull request fixes a hang that occurs when the set of commits to migrate is empty, as pointed out in #2380.

In `*git/odb.Rewriter.commitsToMigrate()`, we store a set of `[][]byte`, where each `[]byte` entry is a commit's SHA1 which should be migrated. Our logic looks something like this:

```go
 func (r *Rewriter) commitsToMigrate(opt *RewriteOptions) ([][]byte, error) {
 	waiter := r.l.Waiter(""migrate: Sorting commits"")

 	scanner, err := git.NewRevListScanner(...)

 	var commits [][]byte
 	for scanner.Scan() {
 		if len(commits) == 0 {
 			waiter.Complete()
 		}

 		commits = append(commits, scanner.OID())
 	}

 	return commits
}
``` 

This has the behavior of flashing a `""migrate: Sorting commits""` message to the terminal, appending `""..., done""` when the first result was received from `git-rev-list(1)`. If, however, the loop inside of `for scanner.Scan()` wasn't entered, the `Waiter` never receives a `Complete()` call.

The `*git/githistory/log` package [picks up the next task][1] (`r.l.Waiter()`, `r.l.Counter()`, etc.) without blocking, but [cannot receive any updates on it][2] causing any channel write whose buffer is full to block. This results in the subsequent [rewriting commits log task][3] to block infinitely, for the waiter is never closed.

There are two cases where an early return would cause such a block:

1. Errors, like `scanner.Err() != nil`, `git.RevListScanner()` returning a non-nil error, etc. These don't require the `""migrate: Sorting commits...""` message to print `""..., done""`, since they cause LFS to exit before spinning up the next logging task.
2. Empty result sets from `git-rev-list(1)`, which is fixed in this PR.

Closes: #2380.

---

/cc @git-lfs/core 
/cc @shana 

[1]: https://github.com/git-lfs/git-lfs/blob/v2.2.0/git/githistory/log/log.go#L162-L179
[2]: https://github.com/git-lfs/git-lfs/blob/v2.2.0/git/githistory/log/log.go#L128-L132
[3]: https://github.com/git-lfs/git-lfs/blob/v2.2.0/git/githistory/rewriter.go#L171",1988,True,en,1
2382,2,0,0,Internals,ttaylorr,2017-07-05T15:23:30Z,5,4,2,0,"This pull request prevents a [cross-volume link error][1] that can occur when committing objects to the object database when a repository is on a non-default volume. This was pointed out in: #2381.

In order to save an object to the database, we do these things:

1. Write a non-zlib compressed copy of the objects body into a temporary buffer (`*bytes.Buffer` for Trees, Commits, `*os.File` for blobs).
2. Create a new buffer on disk with the object header and length, still uncompressed.
3. Stream the above buffer through a `crypto/sha1` Hash to calculate the SHA1 of the object contents.
4. Compress the above.
5. Link the compressed file into the `.git/objects` directory of the repository.

The issue occurs in step 5. If we created a file on a different volume than the on the repository is stored in, and the operating system doesn't support cross-device linking, then an error will occur.

To prevent this from happening, we use `lfs.TempFile` instead of `io/ioutil.TempFile`, which stores temporary objects in `.git/lfs/tmp` instead of `/tmp`. This guarantees that we will always be linking files from a folder on the device that they are being linked into.

I'd like to take a further look at the process required to store objects (see: above), but I think this is a good small step in case I don't have a chance to look at the object committing process before 2.2.x.

Closes #2381.

---

/cc @git-lfs/core 

[1]: https://github.com/golang/go/blob/go1.8.3/src/syscall/zerrors_linux_amd64.go#L1399",1507,True,en,0
2377,1,0,0,Externals,ssgelm,2017-07-05T15:10:42Z,2,2,1,1,Newer versions of cheggaaa/pb no longer expose FormatBytes as a public function (see https://github.com/cheggaaa/pb/commit/104771963e724f4f3087d03be7ccd1e19b92ab84).  This presents a challenge when submitting git-lfs to debian as debian uses a newer version of some dependencies.  Given that this function was already copied to humanize it makes sense to me to just use that.,375,False,en,0
2374,1,3,2,Externals,asottile,2017-07-05T21:00:03Z,26,9,2,3,More from #2289,15,False,en,1
2371,2,0,0,Internals,technoweenie,2017-06-29T21:47:29Z,1,1,1,0,"This backports #2369.

Conflicting files:",41,True,en,0
2369,1,2,0,Internals,technoweenie,2017-06-29T21:14:16Z,1,1,1,0,"Running `git lfs clone` always passes the `--jobs` option to `git clone`. This won't fly if you have git < 2.9:

```
error: unknown option `jobs'
usage: git clone [<options>] [--] <repo> [<dir>]
```

Fixes #2366 by setting the flag default to -1.",246,True,en,0
2362,3,0,0,Internals,technoweenie,2017-06-27T16:29:06Z,106,4,6,0,,0,False,en,0
2358,1,0,0,Internals,ttaylorr,2017-06-26T17:36:16Z,1,1,1,0,"This pull request skips the `track (--no-modify-attrs)` test on Git versions earlier than 2.1.0, as the cause of failure is currently unknown.

I opened up https://github.com/git-lfs/git-lfs/issues/2357 to track.

---

/cc @git-lfs/core ",237,True,en,1
2356,1,0,0,Internals,ttaylorr,2017-06-26T18:03:13Z,40,3,3,0,"This pull request removes info entries in the `git lfs migrate info` command for entries that have no files above the given (or default) `--above` threshold.

For example, the following output would have been generated before this PR on a file a.txt whose size is 10 bytes.

```
$ git lfs migrate info
*.txt      0 B   0/1 files    0% 
```

Will now show:

```
$ git lfs migrate info
```

Giving `--above=0b` (or `--above=0`, as of #2355) will show the file again.

---

/cc @git-lfs/core 
/refs #2146 ",502,True,en,1
2355,1,0,0,Internals,ttaylorr,2017-06-26T17:46:38Z,8,6,2,0,"This pull request treats an empty unit suffix as having meant ""bytes"", so that `--above=3` can be parsed as `--above=3b`.

---

/cc @git-lfs/core 
/refs #2146 ",159,True,en,1
2353,19,1,0,Internals,ttaylorr,2017-06-26T21:56:01Z,587,16,12,3,"This pull request implements the `git-lfs-migrate(1)` 'import' subcommand.

The 'import' subcommand is designed to convert large blobs stored in Git history to LFS pointer files based on the `--include`, `--exclude`, and `--include-ref`, `--exclude-ref` flags. It works by calling the `commands.clean()` function with the blob loaded in memory, and then a) storing that blob's contents in `.git/lfs/objects` and b) writing out an LFS pointer file in its place in the githistory.

Regarding some of the notes from #2146 about when/where to insert .gitattributes changes @technoweenie:

> > When is `.gitattributes` built? I think it'd be cool to slip into the first commit or something.
> 
> Right now I'm adding a `.gitattributes` entry into the first commit that has any paths matching those in the `-I` or `-X` filter, but this could easily be changed to go anywhere before that point in history. I think my preference would be to delay adding the `.gitattributes` entry until the first commit at which that object appears, since that brings us closer to the 1:1 mapping of old history to new, and to me, is clearer in terms of not having a (potentially) huge `.gitattributes` entry up front.
> 

and @andyneff:

> I am actually more inclined to lean towards @ttaylorr's first implementation. I like the idea that the commits before the LFS files are still the same shas, and thus the graphs are topologically connected to each other. I don't know. I just feels good to me ;)

I initially implemented this according to my original suggestion of appending patterns to the `.gitattributes` file when a file of that kind was first rewritten. This is problematic for two reasons:

1. It involves duplicate work to figure out which pattern included/excluded a file (see: #2341).
2. It does _not_ work for `-X`, `--exclude` flags. The `BlobFn` (used to rewrite blobs) is only called on blobs that _do_ match the filter, not ones that don't. This prevents us from ever seeing tree entries that are excluded from the filterset, thus never presenting us an opportunity to add the negative matches to the `.gitattributes`.

Instead, I add the `.gitattributes` changes to the first commit that we migrate by writing lines like:

```gitattributes
pattern merge=lfs filter=lfs diff=lfs -text
```

and adding negative entries for `--exclude`'d patterns like:

```gitattributes
pattern text -merge -filter -diff
```

We keep track of these in a set of patterns that the LFS migrator has tracked, and merge them each time with the .gitattributes in the root tree therefore persisting any .gitattributes changes that exist in the original history. See:

```go
// Create a blob of the attributes that are optionally
// present in the ""t"" tree's .gitattributes blob, and
// union in the patterns that we've tracked.
//
// Perform this Union() operation each time we visit a
// root tree such that if the underlying .gitattributes
// is present and has a diff between commits in the
// range of commits to migrate, those changes are
// preserved.
blob, err := trackedToBlob(db, theirs.Clone().Union(ours))
```

Here's some example output:

1. Generate some commits ahead of the remote ref that contain data to be migrated to LFS:

```sh
~/g/git-lfs (migrate-demo) $ for i in $(seq 1 10); do
  base64 < /dev/urandom | head -c 64 > a.dat
  git add a.dat
  git commit -m ""a.dat: $i""
  done
# ...
```

2. Run `git lfs migrate info` on that data:

```
~/g/git-lfs (migrate-demo) $ git lfs migrate info --above=0b --include=""*.dat""
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (10/10), done
*.dat   640 B   10/10 files(s)  100%
```

3. Run `git lfs migrate import` to rewrite those commits such that the large files are tracked with LFS:

```
~/g/git-lfs (migrate-demo) $ git lfs migrate import --include=""*.dat""
migrate: Sorting commits: ..., done
migrate: Rewriting commits: 100% (11/11), done
  migrate-demo  f18bb746d44e8ea5065fc779bb1acdf3cdae7ed8 -> 35b0fe0a7bf3ae6952ec9584895a7fb6ebcd498b
migrate: Updating refs: ..., done
```

4. Observe the initial commit to show that a) original `.gitattributes` contents are persisted, b) new `.gitattributes` patterns are added accordingly, and c) the `*.dat` file was added to Git LFS.

```diff
~/g/git-lfs (migrate-demo) $ git show 3f65c4db7313e9f4fe0c546fcbba8d10593f2025
commit 3f65c4db7313e9f4fe0c546fcbba8d10593f2025
Author: Taylor Blau <me@ttaylorr.com>
Date:   Fri Jun 23 13:07:12 2017 -0600

    a.dat: 1

diff --git a/.gitattributes b/.gitattributes
index e4c71dbf..3716304e 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -1,3 +1,4 @@
 * text=auto
 * eol=lf
 *.bat eol=crlf
+*.dat filter=lfs diff=lfs merge=lfs -text
diff --git a/a.dat b/a.dat
new file mode 100644
index 00000000..ec26fbcd
--- /dev/null
+++ b/a.dat
@@ -0,0 +1,3 @@
+version https://git-lfs.github.com/spec/v1
+oid sha256:86df498e7a88666447e0c540defbef3f2b2091eecba3c0b7c9ac21962aaef576
+size 64
```

5. Observe an interdiff to show that changes are persisted through the migration and the diffs apply cleanly:

```diff
~/g/git-lfs (migrate-demo) $ git show 94a7b26a4260b04af84c7ce9c7fae6e6586345a6
commit 94a7b26a4260b04af84c7ce9c7fae6e6586345a6
Author: Taylor Blau <me@ttaylorr.com>
Date:   Fri Jun 23 13:07:12 2017 -0600

    a.dat: 2

diff --git a/a.dat b/a.dat
index ec26fbcd..b7fa3fba 100644
--- a/a.dat
+++ b/a.dat
@@ -1,3 +1,3 @@
 version https://git-lfs.github.com/spec/v1
-oid sha256:86df498e7a88666447e0c540defbef3f2b2091eecba3c0b7c9ac21962aaef576
+oid sha256:bb1df455c4d90dbc0c6903500c036096eeec78f1abc151997a80387c81ccd7e0
 size 64
```

6. Observe that `HEAD` contains a checked-out LFS object, a pointer file in the index, and a corresponding entry in `.git/lfs/objects`:

```
~/g/git-lfs (migrate-demo) $ git cat-file -p :a.dat
version https://git-lfs.github.com/spec/v1
oid sha256:b91016d0851cd677a9209a0c0d11c7e9b2d5654f2baeb6485579b899cf6ffa01
size 64
~/g/git-lfs (migrate-demo) $ cat a.dat
yVnUDK0PSDqmoSvY4W/zD/a3GD/rEuPEx/kbwnjFK4E9jMLp0xRiLzCqmwwkPROO%                                                          
~/g/git-lfs (migrate-demo) $ cat .git/lfs/objects/b9/10/b91016d0851cd677a9209a0c0d11c7e9b2d5654f2baeb6485579b899cf6ffa01 
yVnUDK0PSDqmoSvY4W/zD/a3GD/rEuPEx/kbwnjFK4E9jMLp0xRiLzCqmwwkPROO%                                                          
```

Closes: #2146.

---

/cc @git-lfs/core 
/refs #2146 ",6364,True,en,3
2348,4,0,0,Internals,ttaylorr,2017-06-22T00:17:29Z,30,25,2,0,"This pull request cleans up and makes more flexible the conventions for calling `migrate()` from inside the `commands` package. Here's what happened:

1. 186d916: invert `*githistory.Rewriter` so that callers can have a handle on the `Rewriter`'s `Filter()` function (see: https://github.com/git-lfs/git-lfs/pull/2347)
2. 0dde5c8: realize that `cmd` is no longer used, remove that.
3. 7f22ed9: pass in `*githistory.RewriteOptions` so that callers can control the `UpdateRefs` property (`false` in the 'info' command, `true` in the 'import' command)

---

/cc @git-lfs/core 
/refs #2146  ",587,True,en,0
2347,1,0,0,Internals,ttaylorr,2017-06-22T00:05:52Z,18,0,2,0,"This pull request teaches the `git/githistory.Rewriter` type to return a copy of the filepath filter it's using, or nil.

This is required by the 'import' subcommand of the `git-lfs-migrate(1)` which needs to do filepath pattern matching in order to determine which entries to add to the repository's `.gitattributes` file. Instead of constructing the filepathfilter twice, we use `Filter()` to return a reference.

---

/cc @git-lfs/core 
/refs #2146 ",452,True,en,1
2346,1,1,3,Internals,ttaylorr,2017-06-22T00:10:06Z,434,0,2,0,"This pull request introduces a new type in the `tools` package: `*tools.OrderedSet`.

An `*OrderedSet` is identical in interface to the `*tools.StringSet`, but maintains insertion order when asked for elements in the set.

This is required by the 'import' subcommand of the `git-lfs-migrate(1)` suite, which builds up a listing of tracked patterns over time and adds them to the root tree's `.gitattributes` entry. `tools.StringSet` does not allow for this behavior, since order is not guaranteed, therefore random diffs may appear throughout history on the `/.gitattributes` file.

---

/cc @git-lfs/core 
/refs #2146 ",619,True,en,1
2345,2,0,2,Internals,ttaylorr,2017-06-22T00:43:17Z,101,0,2,0,"This pull request teaches the `Merge(others ...*TreeEntry)` operation on `*git/odb.Tree`'s.

`Merge`-ing a tree with a set of other `*TreeEntry`'s involves one of two actions for each given `*TreeEntry`:

1. If given entry ""e"" already exists within the existing `*Tree` with the same name and filemode, replace the old `OID` with the one given by ""e"".
2. If the given entry ""e"" does not already exist within the existing `*Tree`, append it to the end of the tree and sort it into subtree order.

I debated between the `O(n*log(n))` `sort.Sort` operation vs. a linear pass to add the new elements in subtree order, and summarized my decision in a comment above the sort operation:

> ```go
> // Call sort afterwords, as a tradeoff between speed and spacial
> // complexity. As a future point of optimization, adding new elements
> // (see: above) could be done as a linear pass of the ""entries"" set.
> //
> // In order to do that, we must have a constant-time lookup of both
> // entries in the existing and new sets. This requires building a
> // map[string]*TreeEntry for the given ""others"" as well as ""t.Entries"".
> //
> // Trees can be potentially large, so trade this spacial complexity for
> // an O(n*log(n)) sort.
> ```

This is required by the 'import' subcommand of the `git-lfs-migrate(1)` suite in order to add/replace `.gitattributes` tree entries in the root `/` tree when new patterns become tracked.

---

/cc @git-lfs/core 
/refs #2146 ",1452,True,en,1
2344,4,0,2,Internals,ttaylorr,2017-06-22T00:43:00Z,92,0,2,0,"This pull request provides an implementation of `sort.Interface` that sorts `[]*TreeEntry`'s in subtree order, required to write valid trees to the object database.

Right now, there are no call sites in Git LFS that modify (append/delete/re-order) the set of `Entries` on the `*git/odb.Tree` instance.

However, the 'import' subcommand of the `git-lfs-migrate(1)` suite will conditionally append a `.gitattributes` tree entry into the root tree. In doing so, we may potentially create an out of order tree, which causes Git to behave in undefined ways. (I found this out during some testing today where Git would persistently mark a file as modified even though it wasn't. `git-fsck(1)` gave further details).

The following pull request will introduce an `Append(entries ...*TreeEntry)` method to append arbitrary tree entries. This has the potential to create out-of-order tree entries. To mitigate this, introduce a way to sort that will be called after appending new tree entries to guarantee that we always write valid (sub-)trees.

---

/cc @git-lfs/core 
/cc #2146  ",1074,True,en,1
2343,1,0,0,Internals,ttaylorr,2017-06-21T23:16:46Z,68,41,4,0,"This pull request removes the `Type git/odb.ObjectType` member field from `*git/odb.TreeEntry` and replaces it with `git/odb.TreeEntry.Type() git/odb.ObjectType`.

This is done because the type is not a top-level property of the `*TreeEntry` type. `Type()` is a property inferred from the value of `Filemode`. Type can be determined by examining the bits underneath `syscall.S_IFMT` by `entry.Filemode & syscall.S_IFMT`.

This is dependent work for the following pull request, which introduces an implementation of `sort.Interface` that sorts `[]*TreeEntry`'s in subtree order. [source](https://github.com/git/git/blob/v2.13.0/fsck.c#L492-L525)

To avoid relying on an optional property, we move `Type` into a function so we can call that function instead.

---

/cc @git-lfs/core 
/cc #2146   ",794,True,en,2
2341,12,1,0,Internals,ttaylorr,2017-06-21T23:09:41Z,134,56,2,0,"This pull request teaches a new function to the `filepathfilter.Filter` type: `AllowsPattern()`. `AllowsPattern()` has the same semantics as `Allows()`, but also returns the pattern that caused the given filename to be accepted or rejected.

The `git-lfs-migrate(1)` 'import' subcommand needs to modify `.gitattributes` with the pattern(s) that matched a given filename, i.e.: if we cleaned `a.dat` and `*.dat` was given as a pattern, make sure we add `*.dat` to the `.gitattributes`, not `a.dat`.

I'm not totally sold on the name `AllowsPattern()`: @technoweenie do you have ideas here?

---

/cc @git-lfs/core 
/refs #2146 ",626,True,en,1
2340,8,0,0,Internals,ttaylorr,2017-06-22T00:55:26Z,211,0,6,1,"This pull request introduces a new type and option: `*refUpdater` and `UpdateRefs bool`, respectively.

In normal migrations up to this point ('info', so far) no commits are re-written, therefore no references need to be moved. However, 'import' (and 'export') migration will rewrite commits, and therefore the references in the original graph must be moved to their corresponding locations in the new graph.

The `*refUpdater` performs this transition. Given:

- `Refs []*git.Ref`: A set of references to move (currently all references in the repository, see #2338 for discussion), and
- `CacheFn func(old []byte) ([]byte, bool)`: A function to return the migrated location of a given commit SHA1, or nil if the SHA1 was unmoved.

the `*refUpdater` iterates through all `Refs` given, and updates each reference if the SHA1 that reference is pointing to has moved. If the reference has moved, the `*RefUpdater` will create a reflog entry, as well as log to the `*git/githistory/log.Logger` instance (if one was given).

A few notes:

- `CacheFn` is given from the `*HistoryRewriter`, since copying the map would be expensive `(20*2*N(commits))`, and using the existing map allows us to maintain the `*sync.Mutex` locking guarantees.
- `Refs` is given to be all references in a repository, since displaying which refs point at a given commit in the output of `git-rev-list(1)` is difficult without using `git-log(1)`, which isn't machine-readable. Git would be doing the same operation in the background (if `--format=""%D""` is given to `git-rev-list(1)`), so the performance cost is that of spawning a new subprocess.

##

/cc @git-lfs/core 
/cc #2146 ",1651,True,en,3
2339,1,0,0,Internals,ttaylorr,2017-06-19T20:21:53Z,11,2,1,0,"This pull request teaches a variant of the `git.UpdateRef()` function that takes a custom working directory, different than `os.Getwd()`.

This is required for the `*git/githistory.Rewriter` tests, which move refs in a directory outside of the working directory.

---

/cc @git-lfs/core 
/cc #1497 ",298,True,en,0
2338,5,0,1,Internals,ttaylorr,2017-06-19T20:21:40Z,47,0,1,0,"This pull request teaches a new function to the `git` package, `AllRefs()` which returns a listing of all references in a repository.

This is required for the `import` subcommand of `git-lfs-migrate(1)` which needs a listing of all references in order to move references from the old graph onto the migrated one. Ideally this could come from `git-rev-list(1)` (which we already run to generate a listing of commits to migrate), but tricking the output to be machine readable is difficult to do without switching to `git-log`, which doesn't have great machine-readable output either.

---

/cc @git-lfs/core 
/cc #2146",618,True,en,0
2335,10,1,1,Internals,ttaylorr,2017-06-19T21:40:26Z,101,0,3,3,"This pull request provides a new `Task` implementation, `ListTask`, which is used to log line-delimited lists of data using the `git/githistory/log.Logger` type.

This is required work for the `import` subcommand of `git-lfs-migrate(1)` which will print out one line for each ref updated by the migrator.

--- 

/cc @git-lfs/core 
/refs #2146 #2329 #2334 ",355,True,en,1
2334,8,5,0,Internals,ttaylorr,2017-06-19T21:16:49Z,73,1,7,2,"This pull request teaches a new `Task` type to the `github.com/git-lfs/git-lfs/git/githistory/log` package: `DurableTask`.

A `DurableTask` ensures that all log `<-Update()` reads are logged to the `sink io.Writer`, regardless of throttling conditions. This required for multi-line log updates (like output from `git-ref-update(1)`) where all log lines are important.

---

/cc @git-lfs/core 
/refs #2146 #2329 ",411,True,en,3
2333,5,0,0,Internals,ttaylorr,2017-06-16T16:46:37Z,209,17,6,0,"This pull request teaches the `--unit` flag to the 'info' subcommand of `git-lfs-migrate(1)`.

Previously, the behavior of the command was to find the largest storage unit that could represent the number of bytes counted as a whole number. Now, if instead the `--unit` flag is given, that unit is used to format the bytes with at most one decimal place.

Here's a summary of what happened:

- 06fde60 & 40e833d: implement and use `ParseByteUnit` so that we can parse the string `--unit` given.
- cb5baef & 8d09c7e: implement and use `ForamtBytesUnit` so that we can format storage quantities with arbitrary units.
- d1037fc: use the above two utilities to format the bytes accordingly.

Here's a sample from the manpage:

> ```
> * `--unit=<unit>`
>     Format the number of bytes in each entry as a quantity of the storage unit
>     provided. Valid units include:
>       * b, kib, mib, gib, tib, pib - for IEC storage units
>       * b, kb, mb, gb, tb, pb - for SI storage units
> 
>     If a --unit is not specified, the largest unit that can fit the number of
>     counted bytes as a whole number quantity is chosen.
> ```

---

/cc @git-lfs/core 
/cc #2146 ",1164,True,en,2
2332,1,0,0,Internals,ttaylorr,2017-06-16T16:46:19Z,9,9,2,0,"This pull request inverts the argument order for the `*git/odb.ObjectDatabase` argument so that it can be passed into the `migrate()` function.

This is required so that we can add arbitrary blobs to the object database, such that they are valid tree entries (for instance, adding/modifying a tree's `.gitattributes`).

---

/cc @git-lfs/core 
/refs #2146 ",356,True,en,0
2331,1,0,0,Internals,ttaylorr,2017-06-16T16:45:56Z,25,1,2,0,"This pull request introduces a new `*git/odb.Blob` constructor that returns a blob whose contents is equal to the give `[]byte`.

---

/cc @git-lfs/core  
/ref #2146 ",166,True,en,1
2329,15,0,4,Internals,ttaylorr,2017-06-19T21:16:28Z,591,12,10,4,"This pull request introduces a new package, `github.com/git-lfs/git-lfs/git/githistory/log` for Git-style progress based logging, like this:

![](https://user-images.githubusercontent.com/443245/27157106-4df5e11a-511d-11e7-88c9-9e192ec47202.gif)

This pull request is based off the `migrate-subcommand-info` branch, since I wanted to use the `info(1)` subcommand to test out the logger in a real-world setting. Once #2313 is merged, I'll change the base of this pull request to `master`.

The API works as follows: given a `*log.Logger` with a `sink io.Writer`, ask for one of two types of logging tasks:

- `*WaitingTask` (via `(*log.Logger) Waiter()`): a task for which the upper bound of items to process is not known. Logged as `message: ...` and `message: ..., done`. 
- `*PercentageTask` (via `(*log.Logger) Percentage()`): a task for which the upper bound of items is known. Logged as `message:   1% (1/100)` and `message: 100% (100/100), done`.

When a new task is created (via either `Waiter()` or `Percentage()`) that task is queued by the logger and becomes the primary task being logged. Only one task may be logged at a time, though new tasks can be created before the existing task is completed. This, together, creates the two axioms of `*log.Logger`:

1. Only one task may be logged at once, and that task is logged until completion.
2. ""Infinite"" tasks may be created before the current task is finished logging, creating a pseudo-infinite channel buffer.

The finer details of how this works are described in the `consume()` logger function.

One other note: this was originally designed as a utility for the `githistory` package, but I think that it could have other uses throughout LFS. I'd like to eventually consider what making this a top-level `github.com/git-lfs/git-lfs/log` package could look like.

---

/cc @git-lfs/core 
/ref #2146, #2313 ",1869,True,en,4
2327,1,1,0,Externals,gurugray,2017-06-14T15:32:56Z,2,2,2,0,"the are some strange messages when we fetching objects (not pushing them).
fixed this misunderstanding",102,False,en,0
2324,5,3,0,Internals,ttaylorr,2017-06-13T20:39:51Z,229,23,4,0,"This pull request introduces a new package: `github.com/git-lfs/git-lfs/tools/humanize` designed to format and parse byte amounts as human readable text.

This will be used in #2313 in order to parse the `--above=<size>` flag, as well as the output of the command (ref: #2146).

---

/cc @git-lfs/core ",302,True,en,1
2322,1,0,0,Internals,ttaylorr,2017-06-12T17:11:43Z,31,10,1,0,"This pull request teaches the `*git/githistory.Rewriter` type how to eagerly generate an in-memory cache of commits to migrate according to the given `*git/githistory.RewriterOptions`. 

We maintain an in-memory cache so that we can log more informative statistics about migrate progress with an upper bound of total commits to migrate. Maintaining this cache in-memory is relatively inexpensive, since each commit is 20 bytes long, plus an additional platform-specific amount of bytes to store a pointer to the underlying `[20]byte` array. The output of a `--topo-order`-ed `git-rev-list(1)` is also stored in memory. Git's builtin also stores this data in memory: [[source][1], [source][2], & [source][3]]

This is required work for the `git-lfs-migrate(1)` command (see discussion: #2146).

---

/cc @git-lfs/core 

[1]: https://github.com/git/git/blob/v2.13.0/builtin/rev-list.c#L281
[2]: https://github.com/git/git/blob/v2.13.0/Documentation/technical/api-revision-walking.txt#L18-L26
[3]: https://github.com/git/git/blob/v2.13.0/revision.c#L1338-L1374",1057,True,en,0
2313,42,6,14,Internals,ttaylorr,2017-06-16T16:45:15Z,977,1,9,6,"This pull request adds documentation and an implementation for the 'info' subcommand of the `git-lfs-migrate(1)` suite.

The 'info' subcommand is designed to gather statistics regarding the size of data stored in Git per filepath extension. The output of the command looks as follows:

```
~/g/git-lfs (migrate-subcommand-info) $ git-lfs migrate info \
  --include-ref=refs/heads/migrate-subcommand-info \
  --exclude-ref=refs/heads/master \
  --top=3
*.go 2.0 MB
*.sh 325.3 KB
*.md 225.6 KB
``` 

The following arguments are permitted:

- `--include-ref`: a set of references of which commits reachable by those refs are included in the traversal.
- `--exclude-ref`: a set of references of which commits reachable by those refs are excluded in the traversal.
- `--include`: a filepath filter include set
- `--exclude`: a filepath filter exclude set
- `<branch ...>`: an optional set of branches to include, defaulting to the currently checked out branch, or those references given in `--{include,exclude}-ref`.

Here's a summary of the changes:

- fd837f4...11b8d1f: document and specify command arguments in the man pages
- b47255d: add scaffolding for subcommands to `git-lfs-migrate(1)`.
- 58fda2d...1a67cec: helper functions necessary to complete a migration.
- d2c6b0c: teach `tools.ClampInt`.
- 1612c44: add test fixtures for the `info` subcommand
- af3871b: implement and test the `info` subcommand

---

This is the first command to be implemented as described in the `git-lfs-migrate(1)` proposal issue: (see discussion: #2146).

---

/cc @git-lfs/core ",1563,True,en,4
2312,4,0,8,Externals,jakub-m,2017-06-14T15:37:44Z,50,0,2,5,"git-lfs could fail randomly on ""i/o timeout"" error. This is especially
annoying with very long running transfers. This change recognises
Timeout or Temporary errors and retries them.

---

Tested by doing git lfs smudge on a file in lfs repository, where `lfs.url=http://localhost:9000` and  `nc -v -l 9000` was listening locally.

Without the fix git-lfs client aborted instantly, with the fix it retried.
",407,False,en,1
2311,1,0,10,Externals,asottile,2017-06-09T20:40:25Z,72,1,3,0,"Admittedly, I'm a total golang noob :) (my only other real project being a [bridge to python](https://github.com/asottile/setuptools-golang))

This is for #2289, I'd love some feedback.",185,True,en,1
2310,2,0,0,Internals,ttaylorr,2017-06-08T21:24:54Z,71,7,18,0,"This pull request teaches the `*git/githistory.Rewriter` to use an original parent ID if a rewritten one could not be found.

This occurs in scenarios where only a partial migration is taking place (i.e., between a tag and a HEAD) and therefore where not all parents have been seen. Previously this would generate a commit with an empty parent and would fail the test I added as follows:

```
~/g/git-lfs (githistory-migrate-partial-parents!) $ go test -v ./git/githistory -run TestHistoryRewriterUseOriginalParentsForPartialMigration
=== RUN   TestHistoryRewriterUseOriginalParentsForPartialMigration
--- FAIL: TestHistoryRewriterUseOriginalParentsForPartialMigration (0.03s)
panic: runtime error: index out of range [recovered]
        panic: runtime error: index out of range

goroutine 5 [running]:
testing.tRunner.func1(0xc42006ed00)
        /usr/local/Cellar/go/1.8.3/libexec/src/testing/testing.go:622 +0x29d
panic(0x12b0520, 0x145f9f0)
        /usr/local/Cellar/go/1.8.3/libexec/src/runtime/panic.go:489 +0x2cf
github.com/git-lfs/git-lfs/git/odb.(*Commit).Decode(0xc420088080, 0x1438ca0, 0xc42000c240, 0xb2, 0x0, 0x0, 0x0)
        /Users/ttaylorr/go/src/github.com/git-lfs/git-lfs/git/odb/commit.go:116 +0xa51

# ...
```

and would generate commits as:

```
~/g/git-lfs (migrate-cmd) $ g cat-file -p e43c85828d1f1b0631352c773bf89c8f244dd270
tree 726298a5c3089197146367704b2270a62f8a9be5
parent
author Taylor Blau <me@ttaylorr.com> 1496857378 -0600
committer Taylor Blau <me@ttaylorr.com> 1496953008 -0600

docs/man: add entry for `git-lfs-migrate(1)`
```

This is required work for the `git-lfs-migrate(1)` command (see discussion: #2146).

---

/cc @git-lfs/core ",1672,True,en,1
2308,1,0,0,Internals,ttaylorr,2017-06-08T20:13:04Z,91,58,5,0,"This pull request makes the signature(s) of `*git.RevListScanner` mirror more closely the behavior described by `git-rev-list(1)`:

> ```
> GIT-REV-LIST(1)                   Git Manual                   GIT-REV-LIST(1)
>
> NAME
>        git-rev-list - Lists commit objects in reverse chronological order
>
> SYNOPSIS
>        git rev-list [ --max-count=<number> ]
>                     # ...
>                     <commit>... [ -- <paths>... ]
> ```

Where instead of including `left` and `right` commitish's (indicating that rev-list will scan between those two boundaries), this pull request changes that behavior to `Include, Exclude []string`. Each entry in each slice represents a reference to include, or exclude, respectively.

In other words, from the documentation:

```go
// NewRevListScanner instantiates a new RevListScanner instance scanning all
// revisions reachable by refs contained in ""include"" and not reachable by any
// refs included in ""excluded"", using the *ScanRefsOptions ""opt"" configuration.
//
// ...
func NewRevListScanner(include, excluded []string, opt *ScanRefsOptions) (*RevListScanner, error) { ... }
```

This is required work for the `git-lfs-migrate(1)` command (see discussion: #2146).

---

/cc @git-lfs/core ",1247,True,en,2
2303,2,0,0,Internals,ttaylorr,2017-06-07T00:04:24Z,34,11,2,0,"This pull request fixes a bug caused by parsing commits with a message that begins with either `tree` or `parent`.

The issue is that we still allow `tree` or `parent` as the first field to indicate a commit header, so we try and parse the remaining substring as ASCII-encoded hex. In the overwhelming majority of cases, this is possible, and therefore causes a panic.

For instance, the test added in this pull request fails before 7fa88dc:

```
=== RUN   TestCommitDecodingWithMessageKeywordPrefix
--- FAIL: TestCommitDecodingWithMessageKeywordPrefix (0.00s)
        Error Trace:    commit_test.go:104
        Error:          Received unexpected error ""encoding/hex: invalid byte: U+003C '<'""

        Error Trace:    commit_test.go:110
        Error:          Not equal: ""tree <- initial commit"" (expected)
                                != """" (actual)
```

This is required work for the `git-lfs-migrate(1)` command (see: #2146).

---

/cc @git-lfs/core ",959,True,en,1
2302,2,0,0,Internals,ttaylorr,2017-06-06T22:59:54Z,26,1,2,0,"This pull request fixes a bug when reading loose trees longer than 4096 bytes.

The issue is caused by reading a tree entry whose SHA lies across a multiple of 4096 bytes (the buffer size of `*bufio.Reader`. When reading, we do the following:

```go
var sha [20]byte
if _, err := buf.Read(sha[:]); err != nil {
        // ...
}

// ...
```

The issue lies in the fact that `*bufio.Reader.Read()` will make _at most_ one call to the underling `io.Reader.Read()`<sup>[[1](https://golang.org/pkg/bufio/#Reader.Read)]</sup>:

> Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF.

If the buffer is exhausted part of the way through reading a SHA, it will stop, and return `0`'s for the remaining bytes. Since we don't check `n`, this behavior goes unnoticed, and causes us to be `20-n` bytes behind the desired reader position in the tree when we make subsequent reads, resulting in corrupted filenames, modes, etc.

To solve this, use `io.ReadFull`, which will make as many calls as needed to `io.Reader.Read()`<sup>[[2](https://golang.org/pkg/io/#ReadFull)]</sup>:

> ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil.

Since this is the only spot that we read into a byte slice directly in `git/odb`, this is a complete fix for the entire package.

This is required work for the `git-lfs-migrate(1)` subcommand (see discussion: #2146).

---

/cc @git-lfs/core  ",1805,True,en,1
2301,1,0,0,Internals,ttaylorr,2017-06-06T20:09:17Z,21,25,3,0,"This pull request fixes some behavior where objects that already exist would cause the `*MemoryStorer` and `*FileStorer` to `panic()` and return an error, respectively.

Except in the case of SHA1 collisions, these calls should be an effective no-op.

Required work for the `git-lfs-migrate(1)` command (see discussion: #2146), and to unblock the work ongoing in #2300.

---

/cc @git-lfs/core ",394,True,en,1
2300,6,3,2,Internals,ttaylorr,2017-06-06T21:00:24Z,33,4,2,0,"This pull request fixes two instances where we closed the underlying file descriptor feeding the `*git/odb.Blob` type incorrectly.

1. 1d5ef4c: when decoding a loose object, the `git/odb` package expected (prior to 1d5ef4c) the implementing `Object` type to exhaust the `io.Reader` feeding it, so that it could safely call `Close()`. This is the case in `*git/odb.Tree`'s `*git/odb.Commit`'s, where the `io.Reader` is drained completely in order to decode the object.

In `*git/odb.Blob`'s, however, the reader is _not_ drained completely, as the blob may be too large to fit in memory. Instead, a `*bufio.Reader` is used to buffer the file contents, and the `Close()` is delayed. If the Blob's `Size` is less than 4096 (the amount buffered by default in the `*bufio.Reader`), this problem does not occur. If the file size is greater than 4096, then the `*bufio.Reader` will exhaust its own buffer before then polling the underlying `*os.File`, which is closed, and therefore does not allow `Read()`'s.

To solve this, delay closing the blob until `*git/odb.Blob.Close()` is called.

2. 9ec9686 & 8631e3e: A natural point to close the blob being modified is after `*git/odb.ObjectDatabase.WriteBlob()` has been called. This change is implemented in 9ec9686, which takes affect on the rewritten blobs. If, however, the `BlobFn` given to the `*git/githistory.Rewriter` returns the _same_ Blob as both ""rewritten"" and ""original"", then the file will have already been closed (the two are using the same underlying `*os.File`), and therefore a `os.ErrInvalid` will be returned. To solve this, only close the original blob if it is _different_ than the rewritten blob. (8631e3e).

This is required work for the `git-lfs-migrate(1)` command (see discussion: #2146).

---

/cc @git-lfs/core ",1783,True,en,0
2299,3,0,0,Internals,technoweenie,2017-06-16T15:21:55Z,3,3,2,10,"As suggested by @vtbassmatt in https://github.com/git-lfs/git-lfs/issues/2258#issuecomment-306466502:

> Another option is to switch all the examples/docs to use double quotes. I'm not in front of my Mac right now, but I think bash strips both double and single quotes. cmd.exe strips double quotes, so this would be relatively cross-platform.",343,True,en,0
2297,3,0,0,Internals,ttaylorr,2017-06-05T22:12:18Z,124,4,2,0,"This pull request teaches the `*git/githistory.Rewriter` type to accept a `TreeCallbackFn`, which allows for customizing each re-assembled subtree beyond calling `BlobRewriteFn` on each entry. 

For instance:

```go
_, err := rewriter.Rewrite(&RewriteOptions{Left: ""master"",
        TreeCallbackFn: func(path string, t *odb.Tree) (*odb.Tree, error) {
                return &odb.Tree{
                        Entries: append(t.Entries, &odb.TreeEntry{
                                // ...
                        }),
                }, nil
        },
})
```

which would append any amount of additional entries into the rewritten tree _before_ saving to disk. The caveat of this is twofold:

1. The callers must save new objects to the object database before marking them as reference-able from the rewritten `*odb.Tree` instance.
2. The callers must persist changes to the respective `*odb.Tree`s, as the original history is not modified during rewrite, only mapped.

While the second choice may be inconvenient for callers to implement (it should be relatively easy for the migrate command: see #2146 for discussion) this decision is intentional to make it easy to map existing history to new history, since changes don't have to be propagated through (and the process can be parallelized without much additional overhead).

This is required work for the migrator command (see: #2146 for discussion). The `TreeCallbackFn` will append new tree entries for the `.gitattributes` to the tree as it reassembles history.

---

/cc @git-lfs/core ",1543,True,en,1
2296,1,1,0,Internals,ttaylorr,2017-06-05T21:32:15Z,21,11,2,0,"This pull request improves the path qualification for the `BlobCallbackFn` when using the `*git/githistory.Rewriter` to be `""/""` instead of `""""` for the root tree in a repository.

This is done in order to improve the path for the next PR in this series, which includes a `TreeCallbackFn`. Instead of recognizing an empty string `""""` as the root tree, it will now be the OS's path separator (`os.PathSeparator`).

---

/cc @git-lfs/core ",437,True,en,1
2295,4,0,0,Internals,ttaylorr,2017-06-05T19:31:18Z,74,4,15,0,"This pull request teaches the `*git/githistory.Rewriter` type how to cull out subtrees and blobs that won't be modified by the BlobRewriteFn by first checking each tree entry's absolute path against a `*filepathfilter.Filter` instance.

This is required work to boost the performance of the proposed `git-lfs-migrate(1)` command (see discussion: #2146). Since the migrate command will take an `-I` and `-X` flag, we can precompute a `*filepathfilter.Filter` instance that is passed to the rewriter, which will avoid calling the `BlobCallbackFn` on blobs whose paths don't match the filter.

Instead of calling the `BlobRewriteFn` to generate a new object (and therefore, a new tree entry) we copy over the existing tree entry that we are trying to rewrite, and use the same reference to an existing object present in the object database. This ensures that performance for subtrees and blobs that don't match the given `*filepathfilter.Filter` is ⚡️.

To pass the filter to the `NewRewriter()` function, I used Dave Cheney's ""option"" funcs [[source](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis)].

---

/cc @git-lfs/core  ",1153,True,en,1
2294,2,0,0,Internals,ttaylorr,2017-06-05T19:30:57Z,54,52,63,0,"This pull request moves the `*git/odb.HistoryRewriter` type into a new package: `*git/githistory.Rewriter`.

Tracking: #2146.

---

/cc @git-lfs/core ",150,True,en,2
2292,13,1,4,Internals,ttaylorr,2017-06-05T15:37:35Z,735,0,63,2,"This pull request introduces a new type, `*git/odb.HistoryRewriter` that is capable of assembling a topologically equivalent DAG by remapping unique blobs through a `BlobRewriteFn`.

Essentially, the API that I'd like to provide, and the one needed by the migrator command (see: #2146 discussion) is:

```go
history := odb.NewHistoryRewriter(odb.FromFilesystem(""...""))

tip, err := history.Rewrite(&odb.HistoryRewriteOptions{Left: ""master"",
        BlobFn: func(path string, b *odb.Blob) (*odb.Blob, error) {
                // ...
        },
})
```

Where:

- `Left`: is the range of commits to include
- `BlobFn`: is the map function to apply to each blob
- and `tip` is the new tip of that revision set.

To accomplish this, the `*HistoryRewriter` has three functions, `Rewrite`, `rewriteTree`, and `rewriteBlob`:

- [`rewriteBlob`][1]: at the lowest level, takes a given blob and applies the mapping function to it, propagating errors or saving the new blob to the object database.
- [`rewriteTree`][2]: at a higher level, enumerates each entry in a tree, calling `rewriteBlob` if the entry is a blob, or recursing if a subtree exists.
- [`Rewrite()`][3]: walks the commits (output from `*git.RevListScanner` via `git-rev-list(1)`, reassembling history by linking commit parents and moving the old trees to the new trees by first calling `rewriteTree()`, essentially performing:

[1]: https://github.com/git-lfs/git-lfs/pull/2292/files#diff-e438306fed436a78cbb097311f55f909R188
[2]: https://github.com/git-lfs/git-lfs/pull/2292/files#diff-e438306fed436a78cbb097311f55f909R149
[3]: https://github.com/git-lfs/git-lfs/pull/2292/files#diff-e438306fed436a78cbb097311f55f909R75

```go
for scanner.Scan() {
        commit, err := odb.Commit(scanner.OID())
        if err != nil {
                return err
        }

        commit.TreeID = rewriteTree(commit.TreeID)
        for i := 0; i < len(commit.Parents); i ++ {
                commit.Parents[i] = uncache(commit.Parents[i])
        }

        return odb.WriteCommit(commit)
}
```

To test this behavior, I first approached the problem by creating an in-memory ""repository"" with blobs and trees and commits that linked against one another. I found that while in theory this seemed like a good idea for immutability and speed concerns, in practice this required a lot of hard-to-read setup code. The `git/odb` package wasn't designed for this sort of level of repository stubbing.

Instead, I added four bare `.git` repositories that have the state that I'd like within them. When loaded using the `FixtureDatabase` helper, their contents are copied to `/var/tmp` where they can be mutated and asserted on without setup. This has a cost of reduced transparency, but ends up making the tests a lot easier to grok.

Here's a summary of what happened in this pull request:

- https://github.com/git-lfs/git-lfs/compare/0f2b8ea...4094ea6: introduce four fixture repositories.
- Scaffolding to be able to test the `*git/odb.HistoryRewriter`:
  - c91865f: teach `DatabaseFixture` helper, to create a `*git/odb.ObjectDatabase` against a copied version of a given fixture repository.
  - b1a5a1f: teach `HexDecode(t, sha)` to convert ASCII-encoded hexadecimal `string`s to `[]byte`s, or call `t.Fatal()`.
  - 5014390: teach `AssertBlobContents` to assert that a given tree entry has the expected blob contents.
  - 84a7d2b: teach `AssertCommitParent` to assert that a commit has a given parent.
  - 472b87c: teach `AssertCommitTree` to assert that a commit has a given tree.
- 748378b: introduce and test the `*git/odb.HistoryRewriter`.
- https://github.com/git-lfs/git-lfs/compare/748378b...4023333: cleanup unneeded parts of bare repository (`COMMIT_EDITMSG`, `info`, `hooks` examples, etc).

And some things that I'd like to think about going forward:

1. Teach the `*HistoryRewriter` how to use a `filepathfilter.Filter` to cull out subtrees that wont be rewritten.
2. Teach the `*HistoryRewriter` to accept a `TreeCallbackFn` which will visit a whole subtree once before writing it (e.g., to add an entry to `.gitattributes`).

---

/cc @git-lfs/core ",4104,True,en,2
2287,1,0,0,Internals,ttaylorr,2017-06-02T15:37:29Z,37,0,3,0,"This pull request teaches the `*git/odb.ObjectDatabase()` to return the `Root()` path on disk (fully-qualified) that it is operating in. It depends on 23173cf from https://github.com/git-lfs/git-lfs/pull/2286.

This is required work for testing a new type I'm working on `*git/odb.HistoryRewriter`, which requires that the `*git.RevListOperator` (used by the `*HistoryRewriter` to determine which commits to rewrite) work in a directory outside of `os.Getwd()`. This is a result of using bare repositories as fixture data on disk in a different path than the current working directory.

In pursuit of the `git-lfs-migrate(1)` command (see discussion: #2146).

From the documentation:

> ```go
> // Root returns the filesystem root that this *ObjectDatabase works within, if
> // backed by a fileStorer (constructed by FromFilesystem). If so, it returns
> // the fully-qualified path on a disk and a value of true.
> //
> // Otherwise, it returns empty-string and a value of false.
> ```

---

/cc @git-lfs/core ",1011,True,en,1
2286,2,0,0,Internals,ttaylorr,2017-06-02T15:37:21Z,21,0,2,0,"This pull request teaches two minor options to the `*git.RevListScanner`: `WorkingDir` and `Reverse`.

- `WorkingDir`: this option is given to provide a working dir not equal to `os.Getwd()`, in case we're operating on a Git repository that isn't in the current working directory. This isn't the case for `git lfs migrate` usage, but when testing using bare `.git` fixtures, this is required instead of stubbing out `git-rev-list(1)`.
- `Reverse`: this option is one I missed in #2263, and is needed for the `migrate` command (see discussion: #2146). In order to rewrite commits, we must see parents before children when visiting a repository's history in topological ordering. By default `--topo-order` gives us _children_ first, but we want _parents_ first. `--reverse` does that via the `Reverse` option. Since this is a `bool`, the zero-value doesn't change the default behavior of this command.

These two are both required for the migrate command.

---

/cc @git-lfs/core ",978,True,en,1
2283,7,1,2,Internals,ttaylorr,2017-05-31T22:25:46Z,146,18,5,0,"This pull request teaches the `*git/odb.ObjectDatabase` type to read ""missing,"" or (more accurately) packed objects from the Git object database.

When an object becomes packed by Git (before a push, after a `git-pack-objects(1)`, or `git-gc(1)`) they are no longer accessible inside of `.git/objects/xx/yyyy`. Instead, they are delta compressed and stored inside of `.git/objects/pack/pack-nnn.pack` (and the corresponding `.git/objects/pack/pack-nnn.idx`).

Since the `git/odb` package doesn't currently know how to read packed objects, this pull request teaches it to fallback to the `*git.ObjectScanner` (which internally uses `git-cat-file(1) --batch` to ""unpack"" the objects before streaming their contents back to `git/odb`.

Here's a quick breakdown of what happened:

- 70818eb: Introduce an `open()` function which will be the home for reassembling the object from `git-cat-file` output.
- e8b24aa: Since `git-cat-file(1) --batch` yields objects without zlib compression applied, a new set of ""uncompressed"" `*git/odb.ObjectReader`'s are introduced to support reading uncompressed data. This is done to avoid recompressing the data just to immediately decompress it. 
- 4ac2ece: Prepare to test this new behavior by returning an error which satisfies `os.IsNotExist`.
- aaf8a45: Store and provide utilities to `Close()` a `*git.ObjectScanner` on the `*git/odb.ObjectDatabase`.
- 39d387a: Fallback to the `*git.ObjectScanner` when objects are missing by reassembling their object contents.

Some other thoughts to keep in mind after merging: Increasing the number of code paths for reading an object is intentional for two reasons.

I'm primarily concerned about the speed of reading large blobs through a pipe on Windows, which I think is kept faster by opening a file descriptor instead of a pipe.

The second is that I'd eventually like to teach the migrator how to parallelize history recreation. Right now, the cost of parallelization scales linearly with the number of parallel ""workers"" as a function of the cost of open file descriptors. If we moved the primary object reading path to go through `git-cat-file(1)`, we'd have to run multiple invocations of the command in order to read multiple objects at once. In addition to more pipe throughput (which is already slower), we also have to pay the cost as a linear function of the overhead caused by spawning a new process. 

---

/cc @git-lfs/core ",2416,True,en,2
2278,1,0,0,Internals,ttaylorr,2017-05-30T21:58:04Z,3,0,1,0,"This pull request disables the locks verification check if `lfs.<url>.locksverify` is set to a false-y value, as per discussion in https://github.com/git-lfs/git-lfs/issues/2269.

For servers that send a 401 instead of a 403 for invalid credentials against the locks verification endpoint, this can cause an infinite loop when requesting locks verification. Prior to this pull request, disabling locks verification would _still_ make the request, causing an infinite loop in the credential helper.

Closes: https://github.com/git-lfs/git-lfs/issues/2269.

---

/cc @git-lfs/core 
/cc https://github.com/git-lfs/git-lfs/issues/2269",630,True,en,0
2277,1,1,0,Externals,raleksandar,2017-05-30T15:12:56Z,1,1,1,0,"Git LFS commands like `git lfs track` hang forever on MSYS2 setup on Windows because of `git --git-dir` returning cygwin path which `ioutil.ReadFile()` can't handle.

This is related to #865 issue which is fixed by #1820. Although the fix in #1820 does not work under MSYS2 as `uname` there returns `MSYS_NT-10.0` (and the code only checks for `CYGWIN`).

So this fix just adds check for `MSYS` string inside of `tools.isCygwin()`.",431,True,en,0
2272,1,0,0,Internals,ttaylorr,2017-05-26T20:55:57Z,23,0,1,0,"This pull request teaches the `git` package how to execute a `git-checkout(1)` command via a new helper, `git.Checkout()`.

Although `git-checkout(1)` accepts a wide range of arguments and flags, this pull request starts with the most essential options for the work required by the `migrate` command (see discussion: #2146).

While working on the migrate command, the issue is that as changes get propagated into the `HEAD` ref, the working copy does not get checked out, which causes the file to show as modified. This will allow the migrate command to force a manual checkout after updating a ref (using `git.UpdateRef`) and will leave the repository in a clean state.

---

/cc @git-lfs/core ",695,True,en,0
2268,3,0,0,Internals,ttaylorr,2017-05-25T22:05:30Z,77,0,2,0,"This pull request implements both `git.UpdateRef` and `git.UpdateRefReason` to perform an execution of `git-update-ref(1)`.

This is required work to update changes out to the ref tips for the migrate command (see discussion: #2146).

---

/cc @git-lfs/core ",258,True,en,1
2267,4,1,4,Internals,ttaylorr,2017-05-25T21:04:19Z,11,3,1,0,"This pull request fixes an issue in the `git/odb` package that caused a panic when new objects are written to directories that don't have a prefix that has been created.

This is due to how Git partitions objects in the `.git/objects` directory. For instance:

```
~/g/git-lfs (master) $ tree .git/objects | head
.git/objects
├── 00
│   └── 21dd014660145da7cb00c2477359b82cf98dd3
├── 01
│   ├── 091f55ffa8b31575f351e1ede0549cea86058d
```

For an object with the OID `0021dd014660145da7cb00c2477359b82cf98dd3`, Git first places that in a directory called `00`, and then takes the remaining 38 ASCII-encoded hex SHA1 characters as the filename for that object.

Prior to this pull request, if the `git/odb` package tried to write an object that began with a two character combination that did _not_ yet exist in the `.git/objects` directory, it would panic after trying to rename a file as a child node of a directory that didn't exist. https://github.com/git-lfs/git-lfs/commit/0db751e7f8384749d83fd0e6930c4c19912f51c0 addresses this by first `stat()`-ing the directory that will contain the file and running an `os.MkdirAll()` if the error returned from `os.Stat` matches `os.IsNotExist()`.

While in here, I also updated the file storer code to close the temporary buffer earlier, to increase the readability of that code in: e731785.

This is required work for the migrate command (see discussion: #2146).

---

/cc @git-lfs/core ",1464,True,en,0
2266,1,0,0,Internals,ttaylorr,2017-05-25T20:57:46Z,3,0,1,0,"This pull requests fixes an issue where no data would be copied to disk when writing loose objects from the `*git.ObjectDatabase` type.

Here's a brief overview of what was going on: In order to create a ""full"" Git object, you need:

1. The object type
2. The object's encoded contents
3. The length of the encoded contents (zlib inflated)

In order to determine the third item, we write a temporary buffer containing the encoded contents. Once this is done, we then take the length and the object type, write a header, and then rename the object into place in your `.git/objects` directory.

To do this, however, we were using an `*os.File`, since we may encounter large blobs which exceed the available RAM on a computer running `git-lfs-migrate(1)`. The problem is that since `*os.File` implements `io.Seeker`, we were writing and advancing the seek index, so that when we copied the file into place, we were copying from the end (no remaining data), and not from the beginning. This pull request fixes that by first rewinding to the start of the temporary file.

This pull request is required work for the `git-lfs-migrate(1)` command (see discussion: #2146).

---

/cc @git-lfs/core ",1188,True,en,0
2265,1,0,0,Internals,ttaylorr,2017-05-25T20:57:36Z,15,1,2,0,"This pull request teaches the `*git.RevListScanner` the ability to not traverse the object graph if asking for `CommitsOnly`.

This is needed for the `migrate` command (see: #2146 for discussion), which requires a topologically ordered list of just commits, not objects.

Since the default value of `bool` is `false`, this imposes no behavior changes on existing code.

---

/cc @git-lfs/core ",393,True,en,1
2263,5,0,0,Internals,ttaylorr,2017-05-24T23:21:55Z,71,0,2,0,"This pull request expands the `RevListOptions` type to include an `Order` field, and teaches the `RevListScanner` type how to add flags to `git-rev-list(1)` accordingly.

We require a `--topo-order`-sorted list of commits in order to create a parallel DAG efficiently when performing a migrate (see: #2146 for discussion), so this pull request is required for that.

When I first implemented this, I instead added a `TopoOrder bool` field to the `RevListOptions` type, but felt that this approach was too fragile in case we need to add support for other orderings. Git allows for `--date-order`, `--author-date-order`, and `--topo-order` (in addition to its default with none of these flags given), so I added a constant type to represent this and have support for all four. Since the zero-values of the `RevListOrder` type is `DefaultRevListOrder` (which is purposefully ignored), none of the existing code requires any change to keep its behavior.

---

/cc @git-lfs/core ",974,True,en,1
2262,2,3,0,Internals,ttaylorr,2017-05-25T14:47:35Z,2,2,2,0,"This pull request upgrades our CI services to build using Go 1.8.3, which was released today on the golang-announce mailing list [[source]](https://groups.google.com/forum/#!topic/golang-announce/q8Ddz0ZgAQw).

Similar to our discussion in https://github.com/git-lfs/git-lfs/issues/2141, I would like to stay on the latest version of Go to minimize the change between versions if we ever were affected by a security vulnerability and needed to upgrade.

Here's a breakdown of our different CI services and how they're affected:

- CircleCI: uses Homebrew to install Go, so it's always on the latest of what's offered on `homebrew-core`. That repo was updated today in https://github.com/Homebrew/homebrew-core/pull/13905.
- TravisCI: uses the `.travis.yml`, which was updated in this pull request via fc7f6a1.
- AppVeyor: which uses Chocolatey (via `cinst`) to install Go v1.8.3. 1.8.3 isn't on Chocolatey yet, so we can either take an approach similar to 4acff49aea7253413a4382f8d7507324eadb1c59, or wait. I don't think we have a release scheduled anytime soon, so I'm fine to let this sit for until Chocolatey gets updated and then merge. @sschuberth: I'd be curious to hear your thoughts on this and defer to your judgement.

The corresponding build-dockers PR is here: https://github.com/git-lfs/build-dockers/pull/17.

---

/cc @git-lfs/core ",1347,True,en,0
2261,4,1,4,Internals,ttaylorr,2017-05-24T20:24:28Z,462,84,3,0,"This pull request extracts the internal `lfs.revListShas()` function into a new type, `*git.RevListScanner` capable of scanning revision ranges for objects and commits.

This work is required for the migrate command (proposed in #2146) in order to avoid implementing a topological sorting algorithm in Go that is functionally equivalent to a [`sort_in_topological_order` call](https://github.com/git/git/blob/v2.13.0/commit.c#L646-L758). Instead, we will opt to use the builtin `git-rev-list(1)` given a `--topo-order` flag and a left/right refspect.

As a first step, we extract that type from its original home in `lfs.revListShas()` so that it can be expanded in a follow-up pull request in order to support the use-case above.

---

/cc @git-lfs/core ",755,True,en,1
2252,6,1,0,Internals,ttaylorr,2017-05-22T19:26:21Z,36,0,2,0,"This pull request updates our wrapped clone command to include new flags added since Git 2.9, namely:

<details>
<summary><code>--reference[-if-able] <repository></code></summary>
<pre>
--reference[-if-able] <repository>
    If the reference repository is on the local machine, automatically setup
    .git/objects/info/alternates to obtain objects from the reference repository. Using an already
    existing repository as an alternate will require fewer objects to be copied from the repository
    being cloned, reducing network and local storage costs. When using the --reference-if-able, a
    non existing directory is skipped with a warning instead of aborting the clone.

    NOTE: see the NOTE for the --shared option, and also the --dissociate option.
</pre>
</details>

<details>
<summary><code>--shallow-since<=date></code></summary>
<pre>
--shallow-since=<date>
    Create a shallow clone with a history after the specified time.
</pre>
</details>

<details>
<summary><code>--shallow-exclude=<revision></code></summary>
<pre>
--shallow-exclude=<revision>
    Create a shallow clone with a history, excluding commits reachable from a specified remote
    branch or tag. This option can be specified multiple times.
</pre>
</details>

<details>
<summary><code>-[no-]shallow-submodules</code></summary>
<pre>
-[no-]shallow-submodules
   All submodules which are cloned will be shallow with a depth of 1.
</pre>
</details>

<details>
<summary><code>-j <n>, --jobs <n></code></summary>
<pre>
-j <n>, --jobs <n>
    The number of submodules fetched at the same time. Defaults to the submodule.fetchJobs option.
</pre>
</details>

</br>

Closes https://github.com/git-lfs/git-lfs/issues/2250.

---

/cc @git-lfs/core ",1723,True,en,0
2251,2,2,0,Internals,ttaylorr,2017-05-22T19:26:10Z,2,2,2,0,"This pull request closes https://github.com/git-lfs/git-lfs/issues/2249 by adding the shorthand `-v` flag to be the equivelant of `--verbose` when calling `git lfs clone`.

This more closely matches the behavior of the builtin `git-clone(1)`:

> ```
> --verbose, -v
>    Run verbosely. Does not affect the reporting of progress status to the standard error stream.
> ```

While looking through the man pages for `git-clone(1)`, I double checked to make sure that none of the other wrapped clone flags that we provide were missing shorthand, single `-` flags.

Closes https://github.com/git-lfs/git-lfs/issues/2249.

---

/cc @git-lfs/core ",639,True,en,1
2248,1,0,0,Externals,dpursehouse,2017-05-21T04:49:53Z,5,5,1,0,"- Add missing trailing periods

- Add quotes around ""locked"" for consistency
",77,True,en,0
2246,1,1,2,Internals,ttaylorr,2017-05-19T21:00:37Z,34,4,5,0,"---

/cc @git-lfs/core @git-lfs/releases ",41,True,en,0
2245,1,0,0,Internals,ttaylorr,2017-05-19T19:34:31Z,37,2,3,0,This backports #2237.,21,False,en,1
2244,4,0,0,Internals,ttaylorr,2017-05-19T18:55:21Z,15,3,3,0,"This pull request is a manual backporting of the 4 pull requests involved in supporting building/releasing on Debian 9:

- https://github.com/git-lfs/git-lfs/pull/2203 (@ssgelm): fix building on Debian 9
- https://github.com/git-lfs/git-lfs/pull/2205 (@ttaylorr): publish Debian 9 packages
- https://github.com/git-lfs/git-lfs/pull/2211 (@ttaylorr): add Debian 9 to release notes
- https://github.com/git-lfs/git-lfs/pull/2212 (@andyneff): fix broken publishing rules

---

/cc @git-lfs/core ",492,True,en,0
2243,1,0,0,Internals,ttaylorr,2017-05-19T18:15:56Z,96,3,2,0,This backports #2235.,21,False,en,1
2242,1,0,0,Internals,ttaylorr,2017-05-19T16:59:42Z,221,18,7,0,This backports #2241.,21,False,en,5
2241,1,3,0,Internals,technoweenie,2017-05-19T16:32:05Z,221,18,7,0,"This fixes an issue where SSH options can be parsed out of `ssh://` urls. For example, the url `ssh://-oProxyCommand=gnome-calculator` will exec the following command:

```sh
$ ssh -p 12345 -oProxyCommand=gnome-calculator git-lfs-authenticate ...
```

SSH will run the command from the `-oProxyCommand` flag, which is not what we want.

This PR fixes it by inserting `--`, which disables SSH options after it.

```sh
$ ssh -p 12345 -- -oProxyCommand=gnome-calculator git-lfs-authenticate ...
```

LFS does support `plink` and `tortoiseplink`, which don't have anything like `--`. So instead, LFS will remove any leading `-`'s from the `user@host` components of the `ssh://` url.",678,True,en,5
2240,1,0,0,Internals,ttaylorr,2017-05-19T16:19:14Z,6,0,1,0,This backports #2232.,21,False,en,0
2238,1,0,0,Internals,technoweenie,2017-05-19T14:15:50Z,246,48,5,0,This backports #2233.,21,False,en,3
2237,6,4,0,Externals,seth2810,2017-05-19T19:33:43Z,37,2,3,0,https://github.com/git-lfs/git-lfs/issues/2236,46,False,en,1
2235,7,1,5,Internals,ttaylorr,2017-05-19T17:08:36Z,96,3,2,0,"This pull request addresses https://github.com/git-lfs/git-lfs/issues/2185, and supports cross-scheme redirects in the `*lfsapi.Client` type.

The issue is that, even though Go's `*net/http.Client` supports redirects (in response to a 3xx status code) directly, we explicitly disable that as<sup>[[1](https://github.com/git-lfs/git-lfs/blob/v2.1.0/lfsapi/client.go#L251-L253)]</sup>:

```go
httpClient := &http.Client{
  Transport: tr,
  CheckRedirect: func(*http.Request, []*http.Request) error {
    return http.ErrUseLastResponse
  },
}
```

So we're forced to handle HTTP requests ourselves in the `lfsapi.Client.doWithRedirects` function. This is fine, since we already have logic to rewind the body and copy the headers over.

As an aside, ideally we could hook into the `net/http.Client.CheckRedirect` field to hand this responsibility over to the `net/http` package, but the HTTP client follows an older RFC (which it maintains for backwards compatibility reasons) that _prevents_ the client from copying the HTTP verb the request was sent with when a 301, 302, or 303 response code is given: (see: https://github.com/golang/go/blob/go1.8.1/src/net/http/client.go#L423-L429). We cannot work around this, so we must handle it ourselves.

This pull request expands the list of 3xx response codes that we will redirect from and increases the permissiveness of HTTP header copying to only check that the from->to host transition is the same, without checking the scheme.

Closes: https://github.com/git-lfs/git-lfs/issues/2185

---

/cc @git-lfs/core @larsxschneider ",1571,True,en,1
2233,10,2,0,Internals,technoweenie,2017-05-19T13:56:18Z,246,48,5,1,"Attempt 2 to fix #2221. The first attempt is in https://github.com/git-lfs/git-lfs/pull/2231, which slowed pattern matching for basic path patterns without wildcards (ex: `dir/`).

```
BenchmarkFilterNoWildcard-8              	3000	    335559 ns/op # MASTER
BenchmarkFilterNoWildcard-8              	 200	   7115666 ns/op # #2231
```

## Commit 1

Added benchmark for the basic path patterns:

```sh
$ script/test filepathfilter -bench BenchmarkFilter
BenchmarkFilterNoWildcard-8              	    5000	    300797 ns/op
BenchmarkFilterIncludeWildcardOnly-8     	    2000	    834590 ns/op
BenchmarkFilterIncludeDoubleAsterisk-8   	     500	   3792667 ns/op
PASS
ok  	github.com/git-lfs/git-lfs/filepathfilter	5.622s

$ script/test tools -bench BenchmarkFastWalk
BenchmarkFastWalkGitRepoChannels-8   	       1	2936944220 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:67: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2919239983 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:90: files: 20008, errors: 0
PASS
ok  	github.com/git-lfs/git-lfs/tools	5.971s
```

## Commit 2 

`FastWalkGitRepo` was building the patterns based on the absolute path to the repository files. So, instead of matching `(\A|/)obj(/|\z)` against `a/b/obj/...`, it was matching `(\A|/)/Users/rick/foo/obj(/|\z)` against `/Users/rick/foo/a/b/obj/...`. 

9be8214 updated the private functions to pass around the absolute root and relative working directories around, so that the pattern matching is performed on the relative working directory path instead.

```
$ script/test tools -bench BenchmarkFastWalk
BenchmarkFastWalkGitRepoChannels-8   	       1	2877363023 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:67: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2782929616 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:90: files: 20008, errors: 0
PASS
ok  	github.com/git-lfs/git-lfs/tools	5.766s
```

## Commit 3

Updates `basicPattern` to use `HasPrefix`, `HasSuffix`, or `Contains`. _Much_ faster than a regex.

Also, the benchmark tests were renamed to reflect the type of pattern they're matching, not what underlying pattern type is being used.

* SimplePath = NoWildcard
* SimpleExtension = WildcardOnly with `*.go`
* ComplexExtension = WildcardOnly with `*.travis.yml`

```sh
$ script/test filepathfilter -bench BenchmarkFilter
BenchmarkFilterSimplePath-8         	    3000	    357515 ns/op
BenchmarkFilterSimpleExtension-8    	    2000	    864717 ns/op
BenchmarkFilterComplexExtension-8   	    2000	    925933 ns/op
BenchmarkFilterDoubleAsterisk-8     	     500	   3865904 ns/op
PASS
ok  	github.com/git-lfs/git-lfs/filepathfilter	7.254s

$ script/test tools -bench BenchmarkFastWalk
BenchmarkFastWalkGitRepoChannels-8   	       1	2761156938 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:67: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2797957957 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:90: files: 20008, errors: 0
PASS
ok  	github.com/git-lfs/git-lfs/tools	5.663s
```

## Commit 4

Optimized the `*.ext` patterns by using a simple `HasSuffix` call. This dramatically speeds up a very common pattern:

```sh
$ script/test filepathfilter -bench BenchmarkFilter
BenchmarkFilterSimplePath-8         	    3000	    392130 ns/op
BenchmarkFilterSimpleExtension-8    	    5000	    288184 ns/op
BenchmarkFilterComplexExtension-8   	    2000	    974143 ns/op
BenchmarkFilterDoubleAsterisk-8     	     300	   4049675 ns/op
PASS
ok  	github.com/git-lfs/git-lfs/filepathfilter	6.396s

$ script/test tools -bench BenchmarkFastWalk
BenchmarkFastWalkGitRepoChannels-8   	       1	2764673582 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:67: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2810678948 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:90: files: 20008, errors: 0
PASS
ok  	github.com/git-lfs/git-lfs/tools	5.677s
```

## Commit 5

Added a missing test.",4127,True,en,3
2232,3,3,0,Externals,dpursehouse,2017-05-19T13:59:53Z,6,0,1,1,,0,False,en,0
2230,1,0,0,Internals,ttaylorr,2017-05-18T16:42:06Z,2,2,1,0,This backports #2228.,21,False,en,0
2229,1,0,0,Internals,ttaylorr,2017-05-18T16:42:12Z,1,1,1,0,This backports #2227.,21,False,en,0
2228,2,1,0,Internals,ttaylorr,2017-05-17T22:43:05Z,2,2,1,0,"This pull request fixes an error I noticed in our `LoggedError` and `logPanic` functions that format variables like `""%+v""` weren't being formatted correctly when viewing the output of `git lfs logs last`.

This problem was introduced in https://github.com/git-lfs/git-lfs/pull/2178.

---

/cc @git-lfs/core ",308,True,en,0
2227,1,0,0,Internals,ttaylorr,2017-05-17T21:19:54Z,1,1,1,0,"This pull request fixes a potential nil-pointer dereference as described in https://github.com/git-lfs/git-lfs/issues/2222.

The issue is that when the `basic_download` adapter tries to issue a ""resume download"" request to the server and there was an error sending or receiving that request, the client tries to clean up the resources that it held _if_ the response code is 416.

However, this check occurs in an `if err != nil { ... }` block, meaning that the `*http.Request`, `req` can be nil. To solve this, first guard that `res != nil && ...` to prevent a nil-pointer dereference.

My additional concern when I wrote this was that other transfer adapters were affected. I checked all of our transfer adapters, and found that the only time that `req` is ever referenced inside an `if err != nil { ... }` after an `a.doHTTP()` call is in `tq/basic_download.go`, so this is safe. `a.doHTTP()` will never return `(nil, nil)`. One _or_ the other can be `nil`, but not both.

Closes: https://github.com/git-lfs/git-lfs/issues/2222.

---

/cc @git-lfs/core",1054,True,en,0
2224,1,0,0,Internals,ttaylorr,2017-05-17T17:56:45Z,101,33,2,0,This backports #2216.,21,False,en,1
2220,37,2,42,Internals,ttaylorr,2017-05-22T21:55:52Z,1875,0,21,6,"This pull request introduces a new package, `git/odb` and implements loose object reading and writing necessary for the work described in #2146.

Here's a breakdown of the core concepts:

- An `*odb.ObjectDatabase` capable of reading and writing `Object`s from a `Storer`.
- An `Object` interface which specifies a type, and a encode/decode method.
- A `Storer` interface, which abstracts the filesystem away from the object database.
- Several implementations of `Object` for `Blob`, `Tree` and `Commit`.

The documentation in this package is authoritative, and it will be a good place to look for details beyond the broad overview provided above.

---

/cc @git-lfs/core for review
/cc @peff for thoughts on Git-specific details",730,True,en,9
2216,3,0,2,Internals,ttaylorr,2017-05-16T20:58:28Z,101,33,2,4,"This pull request allows the ability to use multiple environments given an ordering when calling `config.Configuration.Unmarshal`.

For instance, the following code _would_ have `panic()`'d in previous versions of LFS:

```go
type T struct {
        X string `os:""X"" git:""lfs.x""`
}
```

In this pull request, calling `config.Configuration.Unmarshal()` on the above code will produce the following behavior:

1. Try and find a value of `X` in the OS environment.
2. If the above value could not be found, try and find it in the Git environment.
3. If the above value is still missing, use the value of X itself (to allow for defaults).

Unfortunately, this required parsing struct tags ourselves, because the `reflect.StructTag` type does not specify an ordering, and rather is defined as: `type reflect.StructTag string`. A simple regexp was written to accomplish this goal.

This is used for work done in a following PR to satisfy looking for the `GIT_SSH_COMMAND` variable in either the OS environment, or Git's own `core.sshCommand`.

---

/cc @git-lfs/core  ",1062,True,en,1
2212,1,0,0,Externals,andyneff,2017-05-10T15:18:31Z,3,3,1,0,"Apparently I misspoke in #2205

While Mint 18 Sarah and 18.1 Serena are based on Ubuntu Xenial 16.04, it turns out Xenial is actually based on Debian Stretch 9[[1](https://askubuntu.com/a/445496)]. And I use Mint 18...

/cc @git-lfs/core ",238,True,en,0
2211,2,0,0,Internals,ttaylorr,2017-05-11T15:06:12Z,1,0,1,1,"This pull request adds a ""Debian 9"" entry to the list we generate at the end of running `script/packagecloud.rb`. I noticed that I missed this from #2205.

---

/cc @git-lfs/core ",179,True,en,0
2210,2,0,0,Internals,ttaylorr,2017-05-09T17:39:09Z,2,2,1,0,"This pull request resolves https://github.com/git-lfs/git-lfs/issues/2207 by printing command help text/manpages to `os.Stdout` instead of `os.Stderr` for consistency with the behavior of Git.

For instance:

```
~/g/git-lfs (help-to-stdout) $ git help 2>/dev/null
usage: git [--version] [--help] [-C <path>] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]
```  

and before:

```
~/g/git-lfs (master) $ git lfs help 2>/dev/null
```

after:

```
~/g/git-lfs (help-to-stdout) $ git lfs help 2>/dev/null
git lfs <command> [<args>]

# ...
```

Closes: https://github.com/git-lfs/git-lfs/issues/2207

---

/cc @git-lfs/core @lyosha https://github.com/git-lfs/git-lfs/issues/2207",893,True,en,0
2206,2,1,0,Internals,technoweenie,2017-05-09T15:35:20Z,4,4,2,0,"The quoted syntax doesn't work on Windows. Probably a bash vs Windows cmd thing.

/cc https://github.com/git-lfs/git-lfs/issues/2204#issuecomment-299907812",155,True,en,1
2205,4,2,0,Internals,ttaylorr,2017-05-09T20:49:03Z,9,3,2,1,"This pull request expands on #2203 to include Debian 9 in the build matrix, and distribute packages to Linux distributions built on/with Debian 9.

---

/cc @git-lfs/core ",171,True,en,0
2203,1,1,0,Externals,ssgelm,2017-05-08T15:47:03Z,5,0,1,0,"Sorry for the delay on this - I've had it on my todo list for months but hadn't gotten around to it.

The fix was to skip the `dh_golang` step which is used to add the `Built-using` field to the resulting deb.  The field is only used to track the version of go used to build a package so omitting it shouldn't be a problem.  In the commit at https://anonscm.debian.org/cgit/collab-maint/dh-golang.git/commit/script/dh_golang?id=7c3fbec6ea92294477fa8910264fe9bd823f21c3 the dh-golang maintainers changed the logic used to determine the version of go used to check the installed package.  This fails because git-lfs gets built using a manually installed version of go.

This fixes #1472.",685,True,en,0
2199,7,1,4,Internals,ttaylorr,2017-05-04T19:14:17Z,120,6,4,2,"This pull request allows the uploader to push ranges with incomplete or missing/corrupt LFS objects as given by the `lfs.allowincompletepush` configuration value.

Closes: #2063.

---

/cc @git-lfs/core @allaryin https://github.com/git-lfs/git-lfs/issues/2193 https://github.com/git-lfs/git-lfs/issues/2063",306,True,en,2
2198,3,3,0,Externals,jiangxin,2017-05-04T22:58:48Z,20,10,2,2,"When push to a scp style url, like:

    git push git@github.com:git-lfs/git-lfs.git HEAD

Git-lfs will complain about bad url.  This is because golang 1.8 has
changed the implement of `url.Parse` method.  It will fail with a nil
pointer and an error if the remote url is a scp style URL.

Make a golang compatible test, I.E. check null pointer, then check u.Scheme.

Signed-off-by: Jiang Xin <xin.jiang@huawei.com>",415,True,en,1
2192,1,1,0,Internals,technoweenie,2017-05-01T22:50:33Z,87,20,3,0,"LFS 2.1.0 added the ability to specify some `lfs.*` and `http.*` values with a URL. You can set `lfs.*.access` based on the Endpoint URL:

```sh
$ git lfs env
git-lfs/2.2.0-pre (GitHub; darwin amd64; go 1.8.1; git 68340281)
git version 2.11.0

Endpoint=https://github.com/git-lfs/git-lfs.git/info/lfs (auth=none)

# enables basic auth for this repo
$ git config lfs.https://github.com/git-lfs/git-lfs.git/info/lfs.access basic
```

Most Git hosts don't require the `.git` extension, so you'd _think_ you could use that url in the config:

```sh
$ git remote get-url origin
https://github.com/git-lfs/git-lfs

$ git config lfs.https://github.com/git-lfs/git-lfs.access basic

$ git lfs env
git-lfs/2.2.0-pre (GitHub; darwin amd64; go 1.8.1; git 68340281)
git version 2.11.0

Endpoint=https://github.com/git-lfs/git-lfs.git/info/lfs (auth=none)
```

It fails here because it's checking the following git config keys:

* `lfs.https://github.com/git-lfs/git-lfs.git/info/lfs.access`
* `lfs.https://github.com/git-lfs/git-lfs.git/info.access`
* `lfs.https://github.com/git-lfs/git-lfs.git.access`
* `lfs.https://github.com/git-lfs.access`

It totally skips `https://github.com/git-lfs/git-lfs`! 

This PR adds an extra check if the url has `.git/info/lfs` in it.


* `lfs.https://github.com/git-lfs/git-lfs.git/info/lfs.access`
* `lfs.https://github.com/git-lfs/git-lfs.git/info.access`
* `lfs.https://github.com/git-lfs/git-lfs.git.access`
* `lfs.https://github.com/git-lfs/git-lfs.access`
* `lfs.https://github.com/git-lfs.access`

/cc https://github.com/git-lfs/git-lfs/issues/2190",1579,True,en,2
2188,1,0,0,Internals,ttaylorr,2017-05-01T18:03:13Z,3,3,3,3,"This pull request bumps the version identifier to be `Git LFS v2.2.0-pre` in all places that we can.

Since we [released v2.1.0](https://github.com/git-lfs/git-lfs/releases/tag/v2.1.0), the next major version on master will be 2.2.0.

---

/cc @git-lfs/core ",258,True,en,0
2187,1,1,0,Internals,ttaylorr,2017-04-28T16:30:51Z,95,4,5,0,"---

/cc @git-lfs/core @git-lfs/releases ",41,True,en,0
2184,24,2,0,Internals,technoweenie,2017-04-28T15:43:57Z,309,161,14,0,"This updates the http logging enabled by `GIT_LOG_STATS=1`:

* Updated the format to include more relevant info, including connection, dns, and tls timings. Uninteresting things like header sizes are left out.
* Instead of tracking requests in per-client slices protected by a mutex, the `*httpTransfer` types are passed around in the request context.
* The log is written to in real time, instead of at the end of the command.",427,True,en,1
2183,4,0,0,Internals,ttaylorr,2017-04-27T22:35:22Z,24,0,5,0,"This pull request represents a complete audit of all calls to the `exec` standard library package as well as the `github.com/git-lfs/git-lfs/subprocess` package to ensure that no subcommands are orphaned when LFS quits.

There are two cases where we can leak processes:

1. Forgetting to call (or not having) a `(*T) Close() error` function to free resources and kill commands.
2. `defer`-ing that call, and not having the defer execute because of a `commands.Exit` or `commands.Panic`.

The issue with calling those `commands.*` helpers is that they use `os.Exit()` calls underneath, which causes an immediate termination of all goroutines, which prevents the calling function from returning thus the scheduler never executes the deferred function calls. From the documentation<sup>[[1](https://golang.org/pkg/os/#Exit)]</sup>: 

> The program terminates immediately; deferred functions are not run.

There are a few potential solutions to this, but by far the simplest is to just ensure that deferred function calls are executed imperatively before a `commands.ExitWithError()`. In other words, that turns this:

```go
defer s.Close()

if err := s.Err(); err != nil {
        ExitWithError(err)
}
```

into:

```go
defer s.Close()

if err := s.Err(); err != nil {
        s.Close()
        ExitWithError(err)
}
```

With those conditions set out, I identified all call-sites into the `exec` and `github.com/git-lfs/git-lfs/subprocess` packages. Those are outlined here:

<ul>
<li><details>
<summary><code>exec</code> package call-sites:</summary>
<pre>
commands/command_pointer.go:120:	cmd := exec.Command(""git"", ""hash-object"", ""--stdin"")
commands/commands.go:266:	cmd := exec.Command(name, args...)
commands/pull.go:88:	cmd    *exec.Cmd
commands/pull.go:100:		i.cmd = exec.Command(""git"", ""update-index"", ""-q"", ""--refresh"", ""--stdin"")
git/object_scanner.go:56:	cmd := exec.Command(""git"", ""cat-file"", ""--batch"")
lfs/extension.go:36:	cmd    *exec.Cmd
lfs/extension.go:62:		cmd := exec.Command(name, args...)
lfs/gitscanner_cmd.go:16:	*exec.Cmd
lfs/gitscanner_cmd.go:23:	cmd := exec.Command(command, args...)
lfsapi/creds.go:104:	cmd := exec.Command(""git"", ""credential"", subcommand)
lfsapi/creds.go:121:	if _, ok := err.(*exec.ExitError); ok {
lfsapi/ssh.go:81:	cmd := exec.Command(exe, args...)
subprocess/cmd.go:43:func newCmd(cmd *exec.Cmd) *Cmd {
subprocess/pty.go:13:	cmd    *exec.Cmd
subprocess/pty_nix.go:14:func NewTty(cmd *exec.Cmd) *Tty {
subprocess/pty_windows.go:7:func NewTty(cmd *exec.Cmd) *Tty {
subprocess/subprocess.go:16:// SimpleExec is a small wrapper around os/exec.Command.
subprocess/subprocess_nix.go:11:	cmd := exec.Command(name, arg...)
subprocess/subprocess_windows.go:12:	cmd := exec.Command(name, arg...)
</pre>
</details>
</li>
<li>
<details>
<summary><code>github.com/git-lfs/git-lfs/subprocess</code> call-sites:</summary>
<pre>
commands/command_clone.go:114:	cmd := subprocess.ExecCommand(""git"", ""submodule"", ""foreach"", ""--recursive"",
commands/path_windows.go:50:		cmd := subprocess.ExecCommand(""pwd"")
git/git.go:67:		return subprocess.SimpleExec(""git"", ""ls-remote"", remote)
git/git.go:70:	return subprocess.SimpleExec(""git"", ""ls-remote"", remote, remoteRef)
git/git.go:74:	outp, err := subprocess.SimpleExec(""git"", ""rev-parse"", ref, ""--symbolic-full-name"", ref)
git/git.go:177:	cmd := subprocess.ExecCommand(""git"", ""remote"")
git/git.go:199:	cmd := subprocess.ExecCommand(""git"", ""show-ref"", ""--heads"", ""--tags"")
git/git.go:311:	_, err := subprocess.SimpleExec(""git"", ""update-index"", ""-q"", ""--refresh"", file)
git/git.go:324:	output, _ := subprocess.SimpleExec(""git"", ""config"", val)
git/git.go:330:	output, _ := subprocess.SimpleExec(""git"", ""config"", ""--global"", val)
git/git.go:336:	output, _ := subprocess.SimpleExec(""git"", ""config"", ""--system"", val)
git/git.go:342:	output, _ := subprocess.SimpleExec(""git"", ""config"", ""--local"", val)
git/git.go:348:	return subprocess.SimpleExec(""git"", ""config"", ""--global"", key, val)
git/git.go:353:	return subprocess.SimpleExec(""git"", ""config"", ""--system"", key, val)
git/git.go:358:	return subprocess.SimpleExec(""git"", ""config"", ""--global"", ""--unset"", key)
git/git.go:363:	return subprocess.SimpleExec(""git"", ""config"", ""--system"", ""--unset"", key)
git/git.go:368:	return subprocess.SimpleExec(""git"", ""config"", ""--global"", ""--remove-section"", key)
git/git.go:373:	return subprocess.SimpleExec(""git"", ""config"", ""--system"", ""--remove-section"", key)
git/git.go:378:	return subprocess.SimpleExec(""git"", ""config"", ""--local"", ""--remove-section"", key)
git/git.go:389:	return subprocess.SimpleExec(""git"", args...)
git/git.go:400:	return subprocess.SimpleExec(""git"", args...)
git/git.go:405:	return subprocess.SimpleExec(""git"", ""config"", ""-l"")
git/git.go:410:	return subprocess.SimpleExec(""git"", ""config"", ""-l"", ""-f"", f)
git/git.go:419:		v, err := subprocess.SimpleExec(""git"", ""version"")
git/git.go:446:	cmd := subprocess.ExecCommand(""git"", ""for-each-ref"",
git/git.go:549:	cmd := subprocess.ExecCommand(""git"", ""show"", ""-s"",
git/git.go:584:	cmd := subprocess.ExecCommand(""git"", ""rev-parse"", ""--git-dir"", ""--show-toplevel"")
git/git.go:619:	cmd := subprocess.ExecCommand(""git"", ""rev-parse"", ""--show-toplevel"")
git/git.go:635:	cmd := subprocess.ExecCommand(""git"", ""rev-parse"", ""--git-dir"")
git/git.go:904:	cmd := subprocess.ExecCommand(""git"", cmdargs...)
git/git.go:928:	cmd := subprocess.ExecCommand(""git"", ""show-ref"")
git/git.go:957:	cmd := subprocess.ExecCommand(""git"", ""ls-remote"", ""--heads"", ""--tags"", ""-q"", remoteName)
git/git.go:995:	cmd := subprocess.ExecCommand(""git"",
git/git.go:1054:	cmd := subprocess.ExecCommand(""git"", args...)
git/git.go:1085:	cmd := subprocess.ExecCommand(""git"", args...)
lfsapi/certs_darwin.go:22:	cmd := subprocess.ExecCommand(""/usr/bin/security"", ""list-keychains"")
lfsapi/certs_darwin.go:57:	cmd := subprocess.ExecCommand(""/usr/bin/security"", ""find-certificate"", ""-a"", ""-p"", ""-c"", name, keychain)
tools/cygwin_windows.go:40:	cmd := subprocess.ExecCommand(""uname"")
tools/filetools_test.go:107:	subprocess.SimpleExec(""git"", ""init"", mainDir)
tools/os_tools.go:30:	cmd := subprocess.ExecCommand(""cygpath"", ""-w"", path)
tq/custom.go:54:	cmd         *subprocess.Cmd
tq/custom.go:127:	cmd := subprocess.ExecCommand(a.path, a.args)
</pre>
</details>
</li>
</ol>

The union of the above lists represents all available locations where we could leak processes. I performed a manual audit of each (and all call-site parents) throughout the entire codebase and made the following notes:

<details>
<summary>Notes</summary>
<pre>
github.com/git-lfs/git-lfs/subprocess:
  SAFE: subprocess.SimpleExec: uses ExecCommand().Output()

github.com/git-lfs/git-lfs/commands:
  SAFE: gitHashObject: uses exec.Command().Output()
  SAFE: PipeCommand: uses exec.Command().Run()
      : *gitIndexer: holds reference to *exec.Cmd (cmd)
                   : calls start
   ->              : ExitWithError unsafe! (commands/command_pull.go:94)

github.com/git-lfs/git-lfs/git:
  SAFE: *ObjectScanner: closed via closeFn()
                      : used via *lfs.PointerScanner, called by Close()
                          - safe in lfs.catFileBatchTree
                          - unsafe via commands/command_status.go:{40,47}
                          - unsafe via lfs/gitscanner_tree.go:51

github.com/git-lfs/git-lfs/lfs:
  UNSAFE: pipeExtensions leaks processes in the case of early returns
  NOOP: startCommand... uses wrappedCmd, calls Start(). callers must be aware
    SAFE: scanUnpushed -> parseScannerLogOutput
    SAFE: refListShas -> closed via goroutine
    SAFE: runCatFileBatchCheck -> closed via goroutine
      NewDiffIndexScanner UNSAFE! added closeFn to help
    SAFE: lsTreeBlobs -> closed via goroutine
    SAFE: runCatFileBatchCheck -> closed via goroutine
    SAFE: scanUnpushed -> parseScannerLogOutput -> closed via goroutine

github.com/git-lfs/git-lfs/lfsapi:
  SAFE: *commandCredentialHelper.exec -> closed via cmd.Wait()
  SAFE: *sshAuthClient.Resolve() -> closed via cmd.Wait()

github.com/git-lfs/git-lfs/subprocess:
  SAFE: newCmd -> called everywhere (safe if corresp. Close() call exists)
    SAFE: ExecCommand (from subprocess_nix.go), if corresp. Close() call exists
      SAFE: git.RootDir() -> closed via cmd.Output()
      SAFE: customAdapter.WorkerStarting -> closed via abort
      SAFE: tools.translateCygwinPath -> closed via cmd.Output()
      SAFE: git.GitDir() -> closed via cmd.Output()
      SAFE: git.RecentBranches() -> closed via deferred cmd.Wait()
      SAFE: git.CloneWithoutFilters() -> closed cmd.Wait()
      SAFE: git.postCloneSubmodules() -> closed via cmd.Run()
      SAFE: git.GitAndRootDirs() -> closed via cmd.Output()
      SAFE: git.RemoteRefs() -> closed via cmd.Wait()
      SAFE: git.appendRootCAsFromKeychain() -> closed via cmd.Output()
      SAFE: git.appendRootCAsFromHostFromPlatform() -> closed via cmd.Output()
      SAFE: git.GetCommitSummary() -> closed via cmd.CombinedOutput()
      SAFE: git.RemoteList() -> closed via deferred cmd.Wait()
      SAFE: git.IsFileModified() -> closed via cmd.Wait()
      SAFE: git.CachedRemoteRefs() -> closed via cmd.Wait()
      SAFE: subprocess.SimpleExec() -> closed via cmd.Output()
      SAFE: git.LocalRefs() -> closed via cmd.Wait()
      SAFE: git.GetTrackedfiles() -> closed via cmd.Wait()

### AXIOMS:
  SAFE: *exec.Command: Output() is blocking and waits for termination
  SAFE: *exec.Command: Wait() is blocking and waits for termination
</pre>
</details>

---

/cc @git-lfs/core ",9458,True,en,0
2181,2,0,0,Internals,ttaylorr,2017-04-27T16:22:05Z,1,1,1,0,"This pull request updates the `git-rev-list(1)` command used to generate release changelogs to only visit the `--first-parent` of each merge.

This way, we avoid inner-merges when merging master back into a feature branch before merging _that_ back into master.

---

/cc @git-lfs/core ",286,True,en,0
2180,2,0,0,Internals,ttaylorr,2017-04-26T23:28:28Z,26,6,3,0,"This pull requests expands the amount of information we trace (`GIT_TRACE=1`) when transferring objects and dealing with failed/retried transfers.

There are two occasions upon which the `*tq.TransferQueue` will retry transfers:

1. Failed/un-parseable batch API request/response<sup>[[1](https://github.com/git-lfs/git-lfs/blob/v2.0.2/tq/transfer_queue.go#L341-L345)]</sup>.
2. Error(s) during upload/download itself (or faked transfers results for missing objects)<sup>[[2](https://github.com/git-lfs/git-lfs/blob/v2.0.2/tq/transfer_queue.go#L490)]</sup>.

This pull requests follows the same thought pattern as #2179 and adds the shorthand error to the trace output via the `%s` format string.

This should help surface underlying transfer issues like those occurring in https://github.com/git-lfs/git-lfs/issues/2030. Previously, these issues would only be surfaced when transfers exceeded their retry budget, or encountered a non-retriable error. This leaves a debugger to have to manually inspect the output with `GIT_TRACE=1` and/or `GIT_CURL_VERBOSE=1` to determine the underlying cause. 

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2030",1167,True,en,2
2179,6,0,0,Internals,ttaylorr,2017-04-26T16:06:57Z,10,5,4,0,"This pull request resolves the first concern raised in https://github.com/git-lfs/git-lfs/issues/2076:

> (1) Requiring the user to check the logfile before seeing the full text of an error seems like an unnecessary extra step that prevents quick troubleshooting. This slight obfuscation of underlying cause of errors also likely leads to vague issue reports, which is harder on the maintainers.

I was looking into the cause of this and found that the callsites in question were using the function `commands.LoggedError()`, which has the signature:

```go
func LoggedError(err error, format string, args ...interface{}) { /* ... */ }
```

What this does is effectively:

1. `fmt.Fprintf(os.Stderr, format, args...)`, (write the format string to stderr) and
2. `LogError(os.File, err)` (log the error to `git lfs logs last`)

Notably, this function does not print the error to stderr unless specified with the format string and arguments. Something like this would look like:

```go
LoggedError(err, ""%s"", err)
```

I think this is good behavior, since different functions will want to format errors differently. That being said, I looked at all of the callers of `LoggedError` and updated them to include the error that they are logging using the `%s` format, which is `cause: error` without a stacktrace. This should better surface errors that were previously only accessible via a `git lfs logs last`, and will resolve #2076.

Closes https://github.com/git-lfs/git-lfs/issues/2076.

---

/cc @git-lfs/core @JarrettR https://github.com/git-lfs/git-lfs/issues/2076",1565,True,en,0
2178,2,0,0,Internals,ttaylorr,2017-04-25T19:51:02Z,17,16,1,0,"This pull request addresses the second and third points of https://github.com/git-lfs/git-lfs/issues/2076:

> (2) On Windows, checking this logfile with an application that does not support Linux-style line endings results in this, which is unusual even for cross-platform systems:

This one required some investigation. I originally thought that the goal here was to replace all instances of printing LF (`\n`) characters sent to the terminal, but the actual fix is to just print platform-specific line ending sequences to _files on disk_, not the terminal.

To determine this, I wrote two files to my `~/github/share` directory, which is accessible via my Windows VM. Each had the words ""foo"" and ""bar"". One was separated by a LF character, and the other by a CRLF, as follows:

```
~/g/git-lfs (x-platform-logs-formatting) $ echo -n ""foo\nbar"" > ~/github/share/example_lf
~/g/git-lfs (x-platform-logs-formatting) $ hexdump -C < ~/github/share/example_lf
00000000  66 6f 6f 0a 62 61 72                              |foo.bar|
00000007
~/g/git-lfs (x-platform-logs-formatting) $ echo -n ""foo\r\nbar"" > ~/github/share/example_crlf
~/g/git-lfs (x-platform-logs-formatting) $ hexdump -C < ~/github/share/example_crlf
00000000  66 6f 6f 0d 0a 62 61 72                           |foo..bar|
00000008
```

On Windows, they render in the terminal as expected independent of the line ending sequences (tested via cmd.exe, and reproducible in Git Bash):

```
C:\Users\ttaylorr>type ""\\vmware-host\Shared Folders\share\example_crlf""
foo
bar
C:\Users\ttaylorr>type ""\\vmware-host\Shared Folders\share\example_lf""
foo
bar
```

So the fix in https://github.com/git-lfs/git-lfs/commit/43ec8e9a0d44ab04b4352d8376a2eb42d9f3a55b involved:

- Adding a `lineEnding` argument to the `logPanicToWriter()` func. This function is used to print to both `os.Stderr`, as well as `*os.File` instances, so it needs to be able to handle either `LF` or `CRLF`s.
- Picking the right line ending sequence for each. For this, we can lean on the existing `gitLineEnding` func, which prefers your `core.autocrlf` setting, or defaults to the platform correct sequence instead.

> (3) After converting the line endings, the relevant error message is way out on the right side of the screen, which significantly hinders reading comprehension for a user trying to parse these for the first time.

This is a larger problem with my (perhaps) excessive use of error-wrapping, but is easily solved by formatting errors with `%+v` instead of `%s`. Here's a before and after:

- With `%s` (old):

```
e3: e2: e1
<stacktrace>
```

- With `%+v` (new): 

```
e1
<snip>
github.com/git-lfs/git-lfs/errors.newWrappedError
        /Users/ttaylorr/go/src/github.com/git-lfs/git-lfs/errors/types.go:166: e2
github.com/git-lfs/git-lfs/errors.newWrappedError
        /Users/ttaylorr/go/src/github.com/git-lfs/git-lfs/errors/types.go:166: e3
```

---

Closes: https://github.com/git-lfs/git-lfs/issues/2076.

---

/cc @git-lfs/core @JarrettR https://github.com/git-lfs/git-lfs/issues/2076",3030,True,en,0
2175,3,1,0,Internals,ttaylorr,2017-04-25T21:13:08Z,95,42,3,1,"This pull request adds a `--no-modify-attrs` flag to the `git lfs track` command to ""touch"" matched tree entries while leaving `.gitattributes` unchanged.

The motivation (which has additional background in https://github.com/git-lfs/git-lfs/issues/2065) is that for files that you wish to ""convert"" to LFS, this should be a lightweight alternative to the destructive `migrate` command proposed in #2146.

Closes: https://github.com/git-lfs/git-lfs/issues/2065

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2065",531,True,en,1
2171,7,0,0,Externals,sprohaska,2017-04-24T01:17:20Z,46,49,1,0,,0,False,en,0
2170,1,0,0,Externals,sprohaska,2017-04-24T01:17:02Z,1,1,1,1,Signed-off-by: Steffen Prohaska <prohaska@zib.de>,49,False,no,0
2168,11,3,8,Internals,technoweenie,2017-04-27T22:19:40Z,58,27,2,6,"Fixes #2166, and reverses #1885 (which was needed because users were inadvertently running on a pre-release version of LFS, which blocked their pushes because no File Locking API implementations existed in the wild yet.

Question: should `locksverify` [automatically be enabled](https://github.com/git-lfs/git-lfs/blob/ab50944e2632844770c4cbf4ef8b79d5ffcfaa81/commands/uploader.go#L141-L145) if it's currently `NULL`, and the locks verify api call returned a valid result? I'm leaning towards ""yes."" I think our approach in LFS v2.0 is a bit too cautious. I think #2162 is a good step towards improving this situation for public LFS servers that implement the file locking API. But I think auto-enabling after successful results will remove an explicit opt-in step when using internal or custom LFS servers.",807,True,en,1
2162,11,0,8,Internals,ttaylorr,2017-04-18T17:28:49Z,82,2,4,0,"This pull request implements support for URL-style lookups for the `lfs.{url}.locksverify` config value and resolves https://github.com/git-lfs/git-lfs/issues/2093.

When writing this, I was wondering if we should change the suggested `git config` commands to use a site's host, instead of the fully qualified path. @technoweenie wisely points out that we can't accurately determine whether or not the hostname is the ""root"" of the LFS API, so the messages were left unchanged.

To partially mitigate this, I added a `hostsWithKnownLockingSupport`, which skips printing out the suggested `git config` message if it's known that a host supports the LFS locking API. I skipped testing this in the integration suite since there's not an accurate way to do this without making a network call to one of the sites in the list.

At the time of writing, GitHub is the only host I know of that completely supports the File Locking API. As additional hosts add support, they should feel free to file a PR to add themselves to that list.

Closes: https://github.com/git-lfs/git-lfs/issues/2093.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2093",1154,True,en,2
2161,4,0,0,Internals,ttaylorr,2017-04-18T15:07:12Z,6,4,1,0,"This pull request replaces all call-sites for `lfs.{url}.access` with a call to `Get()` using the `*config.URLConfig` type.

---

/cc @git-lfs/core ",148,True,en,0
2160,1,0,0,Internals,ttaylorr,2017-04-17T20:55:12Z,8,16,1,0,"This pull request updates all remaining `http.{url}.*` key lookups to use the new `*config.URLConfig` type.

I did a search via:

```bash
~/g/git-lfs (master) $ find . -type f | grep -v ""\.\/vendor"" | grep ""\.go$"" | xargs ack 'http\.'
```

and trimmed those down which yielded the changes made in this pull request. The only other `http.*` key lookup we have is [here](https://github.com/git-lfs/git-lfs/blob/v2.0.2/lfsapi/proxy.go#L51) for the `http.proxy` config, but Git itself does not support per-host/url `http.proxy`-ing.

---

/cc @git-lfs/core ",553,True,en,0
2159,12,1,7,Internals,ttaylorr,2017-04-17T19:45:25Z,70,0,4,2,"This pull request resolves the proposal made in #1500 by implementing support for `http.<url>.extraHeader`.

This pull request is based off of https://github.com/git-lfs/git-lfs/pull/2158, and that should be merged before this one. In the meantime, __here's an inter-diff__: https://github.com/git-lfs/git-lfs/compare/url-config-prefix...lfsapi-extra-headers.

When making any HTTP(S) request from the lfsapi package, LFS will first look for matching `http.{url}.extraHeader` config entries, where `url` is the request URL. LFS currently adds one extra header to each request it makes, which is the `User-Agent: ` header. The `lfsapi` package looks for `extraHeaders` _before_ adding the User-Agent header, so it cannot be overridden.

As per https://github.com/git-lfs/git-lfs/pull/2152 & https://github.com/git-lfs/git-lfs/pull/2154, multiple extraHeaders can be added to a particular request. The following configuration is valid:

```bash
$ git config http.https://github.com/user/repo.git/info/lfs.extraHeader ""X-Foo: bar""
$ git config http.https://github.com/user/repo.git/info/lfs.extraHeader ""X-Non-Unique: bar2""
$ git config http.https://github.com/user/repo.git/info/lfs.extraHeader ""X-Non-Unique: bar3""
```

would send a request with the headers equal to:

```curl
> GET /user/repo.git/info/lfs HTTP/1.1
> Host: github.com
> X-Foo: bar
> X-Non-Unique: bar2
> X-Non-Unique: bar3
```

Closes: #1500.

---

/cc @git-lfs/core #1500 ",1439,True,en,1
2158,4,0,2,Internals,ttaylorr,2017-04-17T15:25:44Z,15,11,2,1,"This pull request fixes an oversight I made in https://github.com/git-lfs/git-lfs/pull/1912 where the prefix of a `*config.URLConfig` lookup wasn't passed correctly into the `getAll()` function.

This pull request is based off of #2156, which should be merged into master before this branch. __In the meantime, here's an inter-diff__: https://github.com/git-lfs/git-lfs/compare/lfsapi-config-cycle...url-config-prefix.

I snuck a second change in here, to reorder the arguments from:

```diff
-func (c *URLConfig) Get(prefix, key string, rawurl string) (string, bool) {
+func (c *URLConfig) Get(prefix, rawurl, key string) (string, bool) {
```

Which more closely matches the `{prefix}.{url}.{key}` ordering that is actually present in the config entry.

---

/cc @git-lfs/core ",778,True,en,1
2156,18,0,1,Internals,ttaylorr,2017-04-17T15:10:51Z,57,148,8,2,"This pull request removes a dependency drawn from the `github.com/git-lfs/git-lfs/config` package to the `github.com/git-lfs/git-lfs/lfsapi` package, where several of the `Endpoint()`-related functions returned `lfsapi.<T>` types.

This work supports the proposal in #1500, where I need to import the `config` package from `lfsapi` in order to maintain an instance of the `*config.URLConfig` type.

---

/cc @git-lfs/core ",422,True,en,1
2154,9,1,1,Internals,ttaylorr,2017-04-14T19:20:02Z,83,46,2,1,"This pull request teaches the `*config.URLConfig` type to fetch multiple values matching a given `prefix.<url>.key`.

This is supporting work for the http.extraHeaders support as defined in #1500.

Right now, it's based off the work done in https://github.com/git-lfs/git-lfs/pull/2152. Once that branch gets merged, this diff should become more readable. In the meantime, **here's an inter-diff**: https://github.com/git-lfs/git-lfs/compare/fetcher-get-all...url-config-many-headers.

To implement this, I changed the `get` function to `getAll`, which replaces the internal `c.git.Get()` with `c.git.GetAll()` calls, which will return _all_ matching values for a given config key, if any were found. What this means for behavior, is that the public `config.URLConfig.GetAll()` function will return more than one value _only_ if it's in the same keyspace.

For instance, given a git config:

```
http.http://example.com/foo.bar=baz
http.http://example.com/.bar=baz2
```

Only a value of `[]string{""baz""}` will be returned. I _think_ this is the right behavior, but we could turn those `return`s into `append`s and roll up the values of `baz` and `baz2`. Either would work.

Here's a quick breakdown of what happened:

1. https://github.com/git-lfs/git-lfs/commit/fdbf3041f965275419cee6a93063f121d81a3596, https://github.com/git-lfs/git-lfs/commit/0b95e7c8b52ceca93661babf6995aaf0455987b5 & https://github.com/git-lfs/git-lfs/commit/473ccb7a17634bfd3225219d4250c005d3852643: some light refactoring
2. https://github.com/git-lfs/git-lfs/commit/5936cf4f29a07272ede29ed8578097e56582b294: rename `get()` to `getAll()` and use that for multi-valued lookups.

---

/cc @git-lfs/core ",1676,True,en,1
2152,4,1,9,Internals,ttaylorr,2017-04-14T17:55:28Z,323,179,31,1,"This pull request expands the the `config.Environment` and `config.Fetcher` types to support multiple values being assigned to a single config key. As per the `.gitconfig` documentation, multiple config values are allowed<sup>[[1](https://git-scm.com/docs/git-config#_description)]</sup>:

> Multiple lines can be added to an option by using the `--add` option.

And as evidenced by:

```bash
~/g/git-lfs (fetcher-get-all) $ git --version
git version 2.12.0
~/g/git-lfs (fetcher-get-all) $ git \
  -c ""foo=bar"" \
  -c ""foo=baz"" \
  config -l | tail -n 2
foo=bar
foo=baz
```

This is needed to support multiple values for the `http.<url>.extraHeaders` config key. The change in the `*config.URLFetcher` will come in a subsequent PR, since this one is already on the large side.

This change is pretty gnarly, as I couldn't do it across multiple commits without breaking the compiler. Here's a quick overview:

1. The `config.Fetcher` type got a few behavior changes:

```diff
diff --git a/config/fetcher.go b/config/fetcher.go
index 24e0dfad..2d3bf660 100644
--- a/config/fetcher.go
+++ b/config/fetcher.go
@@ -6,8 +6,17 @@ package config
 type Fetcher interface {
 	// Get returns the string value associated with a given key and a bool
 	// determining if the key exists.
+	//
+	// If multiple entries match the given key, the first one will be
+	// returned.
 	Get(key string) (val string, ok bool)
 
-	// All returns a copy of all the key/value pairs for the current environment.
-	All() map[string]string
+	// GetAll returns the a set of string values associated with a given
+	// key. If no entries matched the given key, an empty slice will be
+	// returned instead.
+	GetAll(key string) (vals []string)
+
+	// All returns a copy of all the key/value pairs for the current
+	// environment.
+	All() map[string][]string
 }
```

which break down as:

- The `All()` function now returns a ""multi-map"" `map[string][]string`, instead of a `map[string]string`.
- The `Get()` function retains its original behavior by returning the first matching config entry.
- A new function, `GetAll()` was added to return a set of values that match the given key, if the caller wants multiple values.

I figured that this would be the least invasive way that we could make the change. `All()` _has_ to change, but retaining the original behavior of `Get()` seems to offer more flexibility, and is less annoying than `Get(key)[0]` everywhere.

2. The `GitFetcher` type was updated to support multiple keys, and the `OsFetcher` type was updated to return a 1-ary set of `[]string{os.Getenv(k)}`.
3. All `Env` ""copies"" changed to support the above interface changes.
4. All `MapEnvironment`-like helpers got a `UniqMapEnvironment` counter-part, which translates up from a `map[string]string` to a `map[string][]string`, where `n[k]=[]string{m[k]}`, like:

```go
type UniqMapFetcher map[string]string

func (u UniqMapFetcher) All() map[string][]string {
        m := make(map[string][]string, len(u))
        for k, v := range u {
                m[k] = []string{v}
        }

        return m
}
```

and so on. This made the unit test changes much more ergonomic for scenarios where a 1->1 config mapping was being tested.

5. Integration tests were updated where new `.git/config` values were being `--add`'ed to old ones.

---

/cc @git-lfs/core ",3332,True,en,19
2145,1,1,0,Internals,ttaylorr,2017-04-10T18:26:53Z,4,2,3,0,"This pull request resolves https://github.com/git-lfs/git-lfs/issues/2141 by building Git LFS on Go 1.8.1.

In terms of CI, we have:

1. Travis, which was upgraded in the `.travis.yml`.
2. CircleCI, which receives whatever the latest `golang` bottle is on Homebrew, which was updated in https://github.com/Homebrew/homebrew-core/pull/12201.
3. AppVeyor, which @sschuberth pointed out is 👍 to go via https://github.com/git-lfs/git-lfs/issues/2141#issuecomment-292698702.

I also noticed that our README recommends that you have a Go higher than 1.7.3. I think this is technically correct, since we don't use any of the latest Go APIs, but I think now is as good a time as any to bump that version.

Closes https://github.com/git-lfs/git-lfs/issues/2141.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2141",826,True,en,0
2140,3,0,0,Internals,ttaylorr,2017-04-10T17:30:35Z,7,6,2,2,"This pull-request expands the `tools.Smudge()` signature to include a temporary directory under which to create the spool file, and updates the call-site in the `smudge` plumbing command to use the localstorage directory and not the top-level `/tmp` directory.

Since we're still using the `io/ioutil.TempFile()` function, temporary files are created with the `os.O_EXCL` flag and are re-created with a re-seeded random number generator if a conflict exists, so files are guaranteed to be unique.

---

/cc @git-lfs/core ",521,True,en,0
2139,3,0,0,Internals,ttaylorr,2017-04-09T21:10:33Z,39,3,2,2,"This pull request normalizes the paths of locked files across platforms to fix the issue described in https://github.com/git-lfs/git-lfs/issues/2138.

Since Windows's `cmd.exe` [uses `\` as the path separator](https://github.com/golang/go/blob/go1.8/src/os/path_windows.go#L8) ([as opposed to `/` on non-Windows systems](https://github.com/golang/go/blob/go1.8/src/os/path_unix.go#L10)), all of the `path/filepath` operations worked as expected, except the output was a Windows-style path.

By using a `path/filepath.ToSlash()` call, we can normalize that away<sup>[[1](https://golang.org/pkg/path/filepath/#ToSlash)]</sup>:

> ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.

Where Go defines the ""separator character"" as the `os.PathSeparator` constant.

This pull request does not add support for Cygwin paths, but this is something that I think we should look into via a future pull request that we can land before 2.1.0.

Closes https://github.com/git-lfs/git-lfs/issues/2138.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2138",1161,True,en,1
2130,13,1,8,Internals,ttaylorr,2017-04-06T20:16:54Z,393,50,14,1,"This pull-request implements the idea proposed in #2125 to allow an optional `expires_in` property in both the SSH auth API and the batch API. It is introduced as a non-breaking change.

Both the SSH auth response and batch API response types have been expanded as described in https://github.com/git-lfs/git-lfs/issues/2125#issuecomment-291539131:

```go
type T struct {
        // ...
        ExpiresAt time.Time `json:""expires_at,omitempty""`
        ExpiresIn time.Duration `json:""expires_in,omitempty""` 
}
```

and have gained a new helper method:

```go
func (t *T) IsExpiredWithin(d time.Duration) (time.Time, bool) { ... }
```

which returns whether or not the action/SSH auth response is expired, and if so, when.

The behavior for the batch API remains the same, and the SSH auth behavior only changes when `lfs.cachecredentials` which will cause a cached SSH auth response to be invalidated if it is expired.

Closes #2125.

---

/cc @git-lfs/core #2125",963,True,en,4
2127,4,1,1,Internals,ttaylorr,2017-04-05T14:58:22Z,257,75,5,0,"This pull request makes the `*lfs.CatFileBatchScanner` type responsible for only parsing LFS-specific data, and defers reading Git object data to a new type called `*git.ObjectScanner.`

In particular, this is required for #2122 in order to read object contents without running the Git plumbing command: `git-checkout-index.1`.

---

/cc @git-lfs/core for review 👀 ",368,True,en,1
2112,1,0,0,Internals,ttaylorr,2017-03-29T23:09:10Z,36,4,5,0,/cc @git-lfs/core @git-lfs/releases ,36,False,en,0
2111,1,0,0,Internals,ttaylorr,2017-03-29T22:38:36Z,92,3,4,0,This backports #2110.,21,False,en,2
2110,3,0,0,Internals,ttaylorr,2017-03-29T22:17:33Z,92,3,4,0,"This pull request special-cases authentication errors when printing out the:

```
Remote ... does not support the LFS locking API. 
```

message.

When implementing this change, I started with a `errors.IsUserError(...)` helper function to separate the two cases:

1. The server doesn't support locking and returned an error, or...
2. The server returned an error because of a problem in the request at the client end.

`IsUserError()` felt overly generic, so I started narrowing down what cases could actually cause that, and found that authentication was the only one that came to mind. This check purposefully excludes 401s from the list of auth-based HTTP response codes.

It also checks for 404s when constructing an `errors.NewNotImplementedError(...)`, since that is a valid signal that the server doesn't support the locking API, according to [our most recent documentation](https://github.com/git-lfs/git-lfs/blob/v2.0.1/docs/api/locking.md#not-found-response).

Closes: https://github.com/git-lfs/git-lfs/issues/2104

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2104",1097,True,en,2
2109,1,0,0,Internals,ttaylorr,2017-03-29T21:54:56Z,2,3,2,0,This backports #2107.,21,False,en,1
2107,2,0,0,Internals,ttaylorr,2017-03-29T21:39:24Z,2,3,2,0,"This pull request attaches the client-specified limit of the number of locks it'd like returned to the LFS server.

This is in conjunction with the [client-side logic]() we have to prevent returning too many locks. These two behaviors work fine together, since the client limiting wont kick in until the server sends more than the expected number of locks.

Closes: https://github.com/git-lfs/git-lfs/issues/2106

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2106",483,True,en,1
2102,1,0,0,Internals,ttaylorr,2017-03-29T00:04:12Z,6,0,1,0,This backports #2020.,21,False,en,0
2101,1,0,0,Internals,ttaylorr,2017-03-28T23:46:56Z,2,2,1,0,This backports #2033.,21,False,en,0
2100,1,0,0,Internals,ttaylorr,2017-03-28T23:31:15Z,9,7,1,0,This backports #2019.,21,False,en,0
2099,1,0,0,Internals,ttaylorr,2017-03-28T22:59:52Z,3,3,1,0,This backports #2028.,21,False,en,0
2098,1,0,0,Internals,ttaylorr,2017-03-28T22:49:58Z,1,1,1,0,This backports #2021.,21,False,en,0
2097,1,0,0,Internals,ttaylorr,2017-03-28T22:44:20Z,5,0,1,0,This backports #1999.,21,False,en,0
2096,1,0,0,Internals,ttaylorr,2017-03-28T22:43:19Z,1,1,1,0,This backports #2081.,21,False,en,0
2095,2,0,0,Internals,ttaylorr,2017-03-28T23:00:15Z,2,2,2,0,"This backports #2087.

Conflicting files:
- config/version.go
- rpm/SPECS/git-lfs.spec
- versioninfo.json",105,True,en,0
2094,1,0,0,Internals,ttaylorr,2017-03-28T22:32:49Z,523,14,7,0,This backports #2080.,21,False,en,2
2092,1,0,0,Internals,ttaylorr,2017-03-28T17:19:23Z,67,1,2,0,This backports #2090.,21,False,en,1
2090,2,0,0,Internals,ttaylorr,2017-03-28T16:53:45Z,67,1,2,0,"This pull request fixes a regression where Git remote URLs were scheme-less and have a `:` in the first path segment. This behavior was allowed in Go prior to 1.8 (the first tag to include https://github.com/golang/go/commit/c5ccbdd22bdbdc43d541b7e7d4ed66ceb559030e), but was since corrected in order to comply with [RFC 3986 §3.3](https://www.ietf.org/rfc/rfc3986.txt):

> In addition, a URI reference (Section 4.1) may be a relative-path reference, in which case the first path segment cannot contain a colon ("":"") character.

Since Git hosts use the `git@host.com:repo.git` convention, this is an illegal URL according to that section of the RFC.

In Go 1.7, this used to be parsed as:

```bash
~/g/git-lfs (parse-git-remotes!) $ go version
go version go1.7.5 darwin/amd64
~/g/git-lfs (parse-git-remotes!) $ go run schemeless.go
Scheme: """", URL: git@github.com:git-lfs/git-lfs.git
```

But as of Go 1.8, this is not parse-able as a `*net/url.URL`, and an error is returned instead:

```bash
~/g/git-lfs (parse-git-remotes!) $ go version
go version go1.8 darwin/amd64
~/g/git-lfs (parse-git-remotes!) $ go run schemeless.go
2017/03/27 17:26:02 parse git@github.com:git-lfs/git-lfs.git: first path segment in URL cannot contain colon
exit status 1
```

using this Go program:

```go
package main

import (
	""fmt""
	""log""
	""net/url""
)

func main() {
	u, err := url.Parse(""git@github.com:git-lfs/git-lfs.git"")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf(""Scheme: %q, URL: %v\n"", u.Scheme, u)
}
```

This pull request introduces a `prependEmptySchemeIfAbsent` to turn non-compliant URLs like `git@github.com:repo.git` into `//git@github.com:repo.git` instead. This is semantically equivalent to the behavior prior to https://github.com/golang/go/commit/c5ccbdd22bdbdc43d541b7e7d4ed66ceb559030e.

---

/cc @git-lfs/core #2029 ",1829,True,en,1
2089,1,0,0,Internals,ttaylorr,2017-03-27T16:30:54Z,4,0,1,0,This backports #2088.,21,False,en,0
2088,1,3,0,Externals,p12tic,2017-03-27T15:48:10Z,4,0,1,1,This PR fixes debian package build errors when building on an ARM machine. Tested on armhf architecture. ,105,False,en,0
2087,1,1,0,Externals,ZaninAndrea,2017-03-27T15:47:29Z,1,1,1,1,,0,False,en,0
2085,1,0,0,Internals,ttaylorr,2017-03-25T04:38:38Z,179,6,7,0,This backports #2082.,21,False,en,4
2084,1,0,0,Internals,ttaylorr,2017-03-25T04:14:05Z,21,10,6,0,This backports #2083.,21,False,en,2
2083,4,0,0,Internals,ttaylorr,2017-03-24T22:07:41Z,21,10,6,0,"This pull request authenticates verify requests from `tq.verifyUpload()` if the transfer is not already authenticated.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2016
Closes: https://github.com/git-lfs/git-lfs/issues/2016",244,True,en,2
2082,9,1,2,Internals,ttaylorr,2017-03-25T04:13:50Z,179,6,7,0,"This pull request is a continuation of https://github.com/git-lfs/git-lfs/pull/2078 following up on https://github.com/git-lfs/git-lfs/pull/2078#issuecomment-289071404 with https://github.com/git-lfs/git-lfs/pull/2078#issuecomment-289078761.

Turns out that our `*tq.TransferQueue` already had some early returns built in for objects that are a) missing or b) corrupt. I taught the `*tq.TransferQueue` and the `*commands.uploader` types to recognize and log them appropriately.

From https://github.com/git-lfs/git-lfs/pull/2078#issuecomment-289078761, this allows:

> - All of the LFS objects that do exist to travel to the remote as early as possible
> - A user to see all of the missing objects in one push instead of getting one error at a time
> - A user to ""fix"" the missing object later, and have a smaller push size when they complete the fix.

With three files, `missing.dat`, `corrupted.dat`, and `present.dat`, the output looks like this:

```bash
~/g/git-lfs-test (master) $ git push origin master
Locking support detected on remote ""origin"". Consider enabling it with:
  $ git config 'lfs.http://127.0.0.1:61507/push-missing-objects.git/info/lfs.locksverify' true
Git LFS: (1 of 3 files) 7 B / 21 B
Push completed with missing objects:
  (missing) missing.dat (ffa63583dfa6706b87d284b86b0d693a161e4840aad2c5cf6b5d27c3b9621f7d)
  (corrupt) corrupt.dat (11d510e067d2cdcd7559bd86d27a2f4c20babd43670346b97af99b522c1f0075)
error: failed to push some refs to 'http://127.0.0.1:61507/push-missing-objects'
```

- `missing.dat` & `corrupted.dat` are not uploaded
- `present.dat` is uploaded to the LFS server
- No Git blobs are uploaded to the Git server

---

/cc @git-lfs/core @shana",1690,True,en,4
2081,2,0,1,Internals,technoweenie,2017-03-24T21:47:20Z,1,1,1,0,Adds a little more detail to the error message. Fixes #2060,59,False,en,0
2080,12,0,3,Internals,technoweenie,2017-03-28T22:15:53Z,523,14,7,4,"This is another approach to #2045. It adds implementations of `lfsapi.CredentialHelper` and `lfsapi.SSHResolver` that cache the results in-memory to prevent multiple calls over the span of a single `git lfs` call. While this is the same idea as #2045, it's implemented by wrapping some go interfaces, instead of changing `lfsapi.Client` call signatures. This is more idiomatic go, and doesn't require any changes to callers.

In the interest of testing this out for v2.0.2, the cachers are disabled until `git config lfs.cachecredentials 1` is run.

To highlight the difference, I hacked the batch size to just 1 to simulate multiple batches. Output has important lines in bold to show the difference.

## HTTP REMOTE

Here's the uncached output for an HTTP remote `fetch`:

> $ git config --unset lfs.cachecredentials
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch
...
**trace git-lfs: creds: git credential fill (""https"", ""github.com"", ""github/git-lfs-test"")**
**trace git-lfs: Filled credentials for https://github.com/github/git-lfs-test**
trace git-lfs: HTTP: POST https://github.com/github/git-lfs-test.git/info/lfs/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
**trace git-lfs: api: batch 1 files**
**trace git-lfs: creds: git credential fill (""https"", ""github.com"", ""github/git-lfs-test"")**
**trace git-lfs: Filled credentials for https://github.com/github/git-lfs-test**
trace git-lfs: HTTP: POST https://github.com/github/git-lfs-test.git/info/lfs/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON

Here's the cached output:

> $ git config lfs.cachecredentials 1
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch
...
**trace git-lfs: creds: git credential fill (""https"", ""github.com"", ""github/git-lfs-test"")**
**trace git-lfs: Filled credentials for https://github.com/github/git-lfs-test**
trace git-lfs: HTTP: POST https://github.com/github/git-lfs-test.git/info/lfs/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
**trace git-lfs: api: batch 1 files**
**trace git-lfs: creds: git credential cache (""https"", ""github.com"", ""github/git-lfs-test"")**
**trace git-lfs: Filled credentials for https://github.com/github/git-lfs-test**
trace git-lfs: HTTP: POST https://github.com/github/git-lfs-test.git/info/lfs/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON

Notice the `git credential cache` call here ^

## SSH REMOTE

Here's the uncached output for an SSH remote:

> $ git config --unset lfs.cachecredentials
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch
...
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/atom-undo.gif [b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71]
**trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test.git download**
trace git-lfs: api: batch 1 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
**trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test.git download**
trace git-lfs: api: batch 1 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON

And the cached output:

> $ git config lfs.cachecredentials 1
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch
...
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/atom-undo.gif [b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71]
**trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test.git download**
trace git-lfs: api: batch 1 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 6 files) 0 B / 818.95 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
**trace git-lfs: tq: sending batch of size 1**
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
**trace git-lfs: ssh cache: git@github.com git-lfs-authenticate github/git-lfs-test.git download**
trace git-lfs: api: batch 1 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON

Notice the  `ssh cache:` message ^",8602,True,en,2
2079,1,0,0,Internals,ttaylorr,2017-03-24T18:06:49Z,154,89,26,0,This backports #2077.,21,False,en,24
2077,8,2,1,Internals,ttaylorr,2017-03-24T17:34:43Z,154,89,26,0,"This pull request extracts two functions: `escapeTrackPattern()` and `unescapeTrackPattern()` which correctly handles both spaces (`"" ""` -> `""[[:space]]""`) and the pound symbol (`""#""` -> `""\#""`).

It also fixes an incorrect regex in `assert_attributes_count` and un-escapes patterns when calling `git lfs untrack`, so that instead of:

```bash
$ git lfs untrack "" ""
Untracked [[:space:]]
```

you get instead:

```bash
$ git lfs untrack "" ""
Untracked  
```

I'm thinking that we should quote the pattern that comes out to make it clear what's going on with whitespace-only patterns.

This PR also fixes https://github.com/git-lfs/git-lfs/issues/2041.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2041",721,True,en,24
2075,1,0,0,Internals,ttaylorr,2017-03-24T17:13:27Z,3,3,3,0,"This pull-request bumps the version on master to `v2.1.0-pre`, which should remain in place until we release `v2.1.0`, at which point we should remove the `-pre` suffix.

---

/cc @git-lfs/core ",194,True,en,0
2074,1,0,0,Internals,ttaylorr,2017-03-23T19:01:37Z,58,0,4,0,This backports #2073.,21,False,en,2
2073,1,0,1,Internals,ttaylorr,2017-03-23T18:43:09Z,58,0,4,0,"This pull request closes #2064 by installing repo-level hooks after a `git lfs clone` command. It respects the `--separate-git-dir` and `--skip-repo` (from: https://github.com/git-lfs/git-lfs/pull/1868) flags.

If/when this merges, I'll backport this PR to the `release-2.0` tree for release with v2.0.2.

---

/cc @git-lfs/core ",329,True,en,2
2072,3,0,0,Internals,technoweenie,2017-03-23T19:36:30Z,40,27,6,0,"I'm tired of seeing these detailed transfer queue trace messages. Most of these are only relevant if you're debugging a transfer queue bug. This PR disables most of it (unless it's reporting an error) unless `GIT_TRANSFER_TRACE` is set.

## CURRENT v2.0.1 trace

```
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch --all
10:31:09.552814 git.c:600               trace: exec: 'git-lfs' 'fetch' '--all'
10:31:09.553235 run-command.c:350       trace: run_command: 'git-lfs' 'fetch' '--all'
trace git-lfs: run_command: 'git' config -l
Scanning for all objects ever referenced...
trace git-lfs: run_command: git rev-list --objects --all --
trace git-lfs: run_command: git cat-file --batch-check
trace git-lfs: run_command: git cat-file --batch
✔ 7 objects found
Fetching objects...
trace git-lfs: run_command: 'git' rev-parse HEAD --symbolic-full-name HEAD
trace git-lfs: run_command: 'git' config branch.master.remote
trace git-lfs: tq: running as batched queue, batch size of 100
trace git-lfs: fetch bin/b.bin [0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f]
trace git-lfs: fetch bin/hi.bin [98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4]
trace git-lfs: fetch gif/atom-undo.gif [b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71]
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
trace git-lfs: fetch jpg/kabuki-tattoo-left.JPG [e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7]
trace git-lfs: fetch png/render.png [55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0]
trace git-lfs: fetch render.png [124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3]
trace git-lfs: tq: sending batch of size 7
trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test download
trace git-lfs: api: batch 7 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
trace git-lfs: xfer: adapter ""basic"" Begin() with 15 workers
trace git-lfs: xfer: adapter ""basic"" started
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: xfer: adapter ""basic"" worker 8 starting
trace git-lfs: xfer: adapter ""basic"" worker 8 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 9 starting
trace git-lfs: xfer: adapter ""basic"" worker 9 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 0 starting
trace git-lfs: xfer: adapter ""basic"" worker 3 starting
trace git-lfs: xfer: adapter ""basic"" worker 3 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 0 processing job for ""b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71""
trace git-lfs: xfer: adapter ""basic"" worker 7 starting
trace git-lfs: xfer: adapter ""basic"" worker 10 starting
trace git-lfs: xfer: adapter ""basic"" worker 7 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 10 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 6 starting
trace git-lfs: xfer: adapter ""basic"" worker 6 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 1 starting
trace git-lfs: xfer: adapter ""basic"" worker 13 starting
trace git-lfs: xfer: adapter ""basic"" worker 13 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 1 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 2 starting
trace git-lfs: xfer: adapter ""basic"" worker 5 starting
trace git-lfs: xfer: adapter ""basic"" worker 2 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 12 starting
trace git-lfs: xfer: adapter ""basic"" worker 5 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 14 starting
trace git-lfs: xfer: adapter ""basic"" worker 4 starting
trace git-lfs: xfer: adapter ""basic"" worker 14 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 12 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 4 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 11 starting
trace git-lfs: xfer: adapter ""basic"" worker 11 waiting for Auth
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/b9/f8/b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 13 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 13 processing job for ""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7""
trace git-lfs: xfer: adapter ""basic"" worker 14 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 12 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 14 processing job for ""124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3""
trace git-lfs: xfer: adapter ""basic"" worker 12 processing job for ""55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0""
trace git-lfs: xfer: adapter ""basic"" worker 1 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 1 processing job for ""d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3""
trace git-lfs: xfer: adapter ""basic"" worker 11 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 11 processing job for ""98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4""
trace git-lfs: xfer: adapter ""basic"" worker 2 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 2 processing job for ""0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f""
trace git-lfs: xfer: adapter ""basic"" worker 7 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 8 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 9 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 4 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 6 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 5 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 10 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 3 auth signal received
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/e1/73/e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/55/d5/55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/d1/c8/d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/98/ea/98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/12/47/124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 7 files) 220.63 KB / 879.11 KB                                                                                                                                                                                                                                                                                                                              trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 2 finished job for ""0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f""
trace git-lfs: xfer: adapter ""basic"" worker 11 finished job for ""98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4""
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 1 finished job for ""d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3""
trace git-lfs: xfer: adapter ""basic"" worker 14 finished job for ""124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3""
trace git-lfs: xfer: adapter ""basic"" worker 12 finished job for ""55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0""
trace git-lfs: xfer: adapter ""basic"" worker 0 finished job for ""b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71""
Git LFS: (6 of 7 files) 873.22 KB / 879.11 KB                                                                                                                                                                                                                                                                                                                              trace git-lfs: xfer: adapter ""basic"" worker 13 finished job for ""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7""
trace git-lfs: xfer: adapter ""basic"" End()
trace git-lfs: xfer: adapter ""basic"" worker 7 stopping
trace git-lfs: xfer: adapter ""basic"" worker 4 stopping
trace git-lfs: xfer: adapter ""basic"" worker 2 stopping
trace git-lfs: xfer: adapter ""basic"" worker 9 stopping
trace git-lfs: xfer: adapter ""basic"" worker 6 stopping
trace git-lfs: xfer: adapter ""basic"" worker 8 stopping
trace git-lfs: xfer: adapter ""basic"" worker 13 stopping
trace git-lfs: xfer: adapter ""basic"" worker 3 stopping
trace git-lfs: xfer: adapter ""basic"" worker 14 stopping
trace git-lfs: xfer: adapter ""basic"" worker 10 stopping
trace git-lfs: xfer: adapter ""basic"" worker 0 stopping
trace git-lfs: xfer: adapter ""basic"" worker 1 stopping
trace git-lfs: xfer: adapter ""basic"" worker 12 stopping
trace git-lfs: xfer: adapter ""basic"" worker 11 stopping
trace git-lfs: xfer: adapter ""basic"" worker 5 stopping
trace git-lfs: xfer: adapter ""basic"" stopped
Git LFS: (7 of 7 files) 879.11 KB / 879.11 KB
```

## THIS PR WITH GIT_TRACE

```
$ rm -rf .git/lfs/objects && GIT_TRACE=1 git lfs fetch --all
10:32:42.028891 git.c:600               trace: exec: 'git-lfs' 'fetch' '--all'
10:32:42.029409 run-command.c:350       trace: run_command: 'git-lfs' 'fetch' '--all'
trace git-lfs: run_command: 'git' config -l
Scanning for all objects ever referenced...
trace git-lfs: run_command: git rev-list --objects --all --
trace git-lfs: run_command: git cat-file --batch-check
trace git-lfs: run_command: git cat-file --batch
✔ 7 objects found
Fetching objects...
trace git-lfs: run_command: 'git' rev-parse HEAD --symbolic-full-name HEAD
trace git-lfs: run_command: 'git' config branch.master.remote
trace git-lfs: tq: running as batched queue, batch size of 100
trace git-lfs: fetch bin/b.bin [0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f]
trace git-lfs: fetch bin/hi.bin [98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4]
trace git-lfs: fetch gif/atom-undo.gif [b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71]
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
trace git-lfs: fetch jpg/kabuki-tattoo-left.JPG [e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7]
trace git-lfs: fetch png/render.png [55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0]
trace git-lfs: fetch render.png [124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3]
trace git-lfs: tq: sending batch of size 7
trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test download
trace git-lfs: api: batch 7 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP:  LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/b9/f8/b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/12/47/124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/d1/c8/d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/98/ea/98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/55/d5/55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/e1/73/e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7
Git LFS: (0 of 7 files) 118.63 KB / 879.11 KB                                                                                                                                                                                                                                                                                                                              trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
Git LFS: (7 of 7 files) 879.11 KB / 879.11 KB
```

## THIS PR WITH GIT_TRANSFER_TRACE

```
$ rm -rf .git/lfs/objects && GIT_TRANSFER_TRACE=1 git lfs fetch --all
trace git-lfs: run_command: 'git' config -l
Scanning for all objects ever referenced...
trace git-lfs: run_command: git rev-list --objects --all --
trace git-lfs: run_command: git cat-file --batch-check
trace git-lfs: run_command: git cat-file --batch
✔ 7 objects found
Fetching objects...
trace git-lfs: run_command: 'git' rev-parse HEAD --symbolic-full-name HEAD
trace git-lfs: run_command: 'git' config branch.master.remote
trace git-lfs: tq: running as batched queue, batch size of 100
trace git-lfs: fetch bin/b.bin [0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f]
trace git-lfs: fetch bin/hi.bin [98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4]
trace git-lfs: fetch gif/atom-undo.gif [b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71]
trace git-lfs: fetch gif/droidtocat.gif [d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3]
trace git-lfs: fetch jpg/kabuki-tattoo-left.JPG [e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7]
trace git-lfs: fetch png/render.png [55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0]
trace git-lfs: fetch render.png [124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3]
trace git-lfs: tq: sending batch of size 7
trace git-lfs: ssh: git@github.com git-lfs-authenticate github/git-lfs-test download
trace git-lfs: api: batch 7 files
trace git-lfs: HTTP: POST https://lfs.github.com/github/git-lfs-test/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: LOTS OF JSON
trace git-lfs: tq: starting transfer adapter ""basic""
trace git-lfs: xfer: adapter ""basic"" Begin() with 15 workers
trace git-lfs: xfer: adapter ""basic"" started
trace git-lfs: xfer: adapter ""basic"" worker 2 starting
trace git-lfs: xfer: adapter ""basic"" worker 2 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 1 starting
trace git-lfs: xfer: adapter ""basic"" worker 1 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 9 starting
trace git-lfs: xfer: adapter ""basic"" worker 9 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 5 starting
trace git-lfs: xfer: adapter ""basic"" worker 5 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 8 starting
trace git-lfs: xfer: adapter ""basic"" worker 10 starting
trace git-lfs: xfer: adapter ""basic"" worker 8 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 10 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 3 starting
trace git-lfs: xfer: adapter ""basic"" worker 3 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 6 starting
trace git-lfs: xfer: adapter ""basic"" worker 13 starting
trace git-lfs: xfer: adapter ""basic"" worker 6 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 13 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 14 starting
trace git-lfs: xfer: adapter ""basic"" worker 11 starting
trace git-lfs: xfer: adapter ""basic"" worker 14 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 11 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 4 starting
trace git-lfs: xfer: adapter ""basic"" worker 4 waiting for Auth
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: xfer: adapter ""basic"" worker 12 starting
trace git-lfs: xfer: adapter ""basic"" worker 12 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 0 starting
trace git-lfs: xfer: adapter ""basic"" worker 7 starting
trace git-lfs: xfer: adapter ""basic"" worker 7 waiting for Auth
trace git-lfs: xfer: adapter ""basic"" worker 0 processing job for ""b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71""
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/b9/f8/b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71
Git LFS: (0 of 7 files) 0 B / 879.11 KB                                                                                                                                                                                                                                                                                                                                    trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 3 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 3 processing job for ""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7""
trace git-lfs: xfer: adapter ""basic"" worker 14 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 14 processing job for ""124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3""
trace git-lfs: xfer: adapter ""basic"" worker 4 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 4 processing job for ""55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0""
trace git-lfs: xfer: adapter ""basic"" worker 6 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 7 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 7 processing job for ""98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4""
trace git-lfs: xfer: adapter ""basic"" worker 6 processing job for ""d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3""
trace git-lfs: xfer: adapter ""basic"" worker 12 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 13 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 12 processing job for ""0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f""
trace git-lfs: xfer: adapter ""basic"" worker 9 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 2 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 1 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 11 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 8 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 10 auth signal received
trace git-lfs: xfer: adapter ""basic"" worker 5 auth signal received
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/e1/73/e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/55/d5/55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/12/47/124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/d1/c8/d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/98/ea/98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4
trace git-lfs: HTTP: GET https://github-cloud.s3.amazonaws.com/alambic/media/111976139/02/63/0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f
Git LFS: (0 of 7 files) 67.63 KB / 879.11 KB                                                                                                                                                                                                                                                                                                                               trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 12 finished job for ""0263829989b6fd954f72baaf2fc64bc2e2f01d692d4de72986ea808f6e99813f""
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: 200
trace git-lfs: xfer: adapter ""basic"" worker 7 finished job for ""98ea6e4f216f2fb4b69fff9b3a44842c38686ca685f3f55dc48c5d3fb1107be4""
trace git-lfs: HTTP: 200
Git LFS: (2 of 7 files) 643.52 KB / 879.11 KB                                                                                                                                                                                                                                                                                                                              trace git-lfs: xfer: adapter ""basic"" worker 6 finished job for ""d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3""
trace git-lfs: xfer: adapter ""basic"" worker 4 finished job for ""55d51edb307ed7bf4a1bbca3867d132a07f76828d57f37e0f31f712c02ceafe0""
trace git-lfs: xfer: adapter ""basic"" worker 14 finished job for ""124733b36d098353ad16bb11646643709e87c4746e0d97913a9826829e0477a3""
trace git-lfs: xfer: adapter ""basic"" worker 0 finished job for ""b9f86fab477109565871ced361ba69f2425a91fbe6057fa7a9629a8d536d7c71""
trace git-lfs: xfer: adapter ""basic"" worker 3 finished job for ""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7""
trace git-lfs: xfer: adapter ""basic"" End()
trace git-lfs: xfer: adapter ""basic"" worker 12 stopping
trace git-lfs: xfer: adapter ""basic"" worker 13 stopping
trace git-lfs: xfer: adapter ""basic"" worker 14 stopping
trace git-lfs: xfer: adapter ""basic"" worker 5 stopping
trace git-lfs: xfer: adapter ""basic"" worker 4 stopping
trace git-lfs: xfer: adapter ""basic"" worker 10 stopping
trace git-lfs: xfer: adapter ""basic"" worker 0 stopping
trace git-lfs: xfer: adapter ""basic"" worker 8 stopping
trace git-lfs: xfer: adapter ""basic"" worker 6 stopping
trace git-lfs: xfer: adapter ""basic"" worker 3 stopping
trace git-lfs: xfer: adapter ""basic"" worker 11 stopping
trace git-lfs: xfer: adapter ""basic"" worker 7 stopping
trace git-lfs: xfer: adapter ""basic"" worker 2 stopping
trace git-lfs: xfer: adapter ""basic"" worker 1 stopping
trace git-lfs: xfer: adapter ""basic"" worker 9 stopping
trace git-lfs: xfer: adapter ""basic"" stopped
Git LFS: (7 of 7 files) 879.11 KB / 879.11 KB
```",24624,True,en,2
2070,10,0,6,Internals,ttaylorr,2017-03-23T19:06:24Z,392,68,5,0,"This pull-request makes it easier to diagnose why certain files are modified by LFS by adding blob info to each status line entry in the `git lfs status` command.

Here's what the output looks like:

```
On branch master

Git LFS objects to be committed:

    file2.dat (LFS: eeaf82b)
    file3.dat (LFS: a12942e)

Git LFS objects not staged for commit:

    file1.dat (LFS: 1307990 -> Git: 8735179)
    file3.dat (Git: 0dc8537)
```

The `()` shows some meta information about each entry's source and destination. For each end, it shows whether the file is tracked by Git or LFS, and the contents SHA of each. The contents SHA is either the `shasum -a 256` of the blob's contents (NB: _not_ the blob SHA itself), or the pointer's OID (if the file is tracked by LFS).

The extra info contained between the `()` comes from the following rules:

1. If the file is new (marked as `A` for addition), show a) the source (either `Git:` or `LFS:`) & the blob contents SHA.
2. If the file is not new, is a copy, a modification, or etc., show both the source and destination (either: `Git:` or `LFS:`) as well as the blob contents SHA for each.

The blob contents SHA is defined as:

- If the file is handled by LFS and is _currently_ parse-able as an LFS pointer, mark it as LFS. A file is parse-able as an LFS pointer if it wasn't checked out (using the `-I` or `-X` flags), or is staged into the index and tracked with the LFS `filter` in your repository's `.gitattributes`.
- If the file is not tracked by LFS, or is tracked by LFS and is not yet staged into the index (meaning the LFS has not yet `clean`-ed the file) the file is tracked by Git. If the file is tracked by LFS, but isn't parse-able as an LFS pointer (meaning the `clean`/`smudge` filters were skipped, or the file was already committed as a large object into the Git history), show the file as having a `Git:` source. 

A few things that I'd like to address beyond this pull-request:

1. Since #2042, we're showing _all_ files (not just those tracked by LFS) in the status output. I think this makes sense since we want to show files that are supposed to be tracked by LFS but aren't. One thing we could do is only show files which match the patterns in `.gitattributes`, but I like the complete-ness of what we have right now.
2. Files are shown as coming from `Git:` if they are tracked by LFS and not yet staged. This is technically correct, but we could show a better prefix, or try and figure out if they _would_ be tracked by LFS. I don't know offhand of a complete way to do this, since we not only have to check the contents of the repository's `.gitattributes` file(s), but also whether or not the user has a valid LFS clean/smudge/process filter installed.
3. `diff-index` doesn't show new, untracked files. This may have always been a problem with the status command, but deserves investigation nonetheless. 

---

/cc @git-lfs/core ",2905,True,en,2
2067,2,0,0,Internals,ttaylorr,2017-03-22T20:15:32Z,91,29,2,0,"This pull request updates our unique-ness check in the `git lfs status` command to correctly display partially staged files.

Here's an example. When `git status` shows:

```bash
~/g/git-lfs-test (master!) $ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use ""git reset HEAD <file>..."" to unstage)

        modified:   gif/droidtocat.gif

Changes not staged for commit:
  (use ""git add <file>..."" to update what will be committed)
  (use ""git checkout -- <file>..."" to discard changes in working directory)

        modified:   gif/droidtocat.gif
```

`git lfs status` used to show:

```bash
~/g/git-lfs-test (master!) $ git lfs status
On branch master
Git LFS objects to be pushed to origin/master:


Git LFS objects to be committed:


Git LFS objects not staged for commit:

        gif/droidtocat.gif
```

but now shows:

```bash
~/g/git-lfs-test (master!) $ git lfs status
On branch master
Git LFS objects to be pushed to origin/master:


Git LFS objects to be committed:

        gif/droidtocat.gif

Git LFS objects not staged for commit:

        gif/droidtocat.gif
```

The term ""partially staged"" doesn't often apply in the traditional sense when talking about large files. A much more likely scenario, however, is:

1. Modify (or add) an LFS-tracked file
2. Stage that file
3. Add or replace contents of staged LFS-tracked
4. Have both staged and unstaged changes

Since the staged changes are already reflected as an LFS pointer in the index, it is technically correct to say that the file is both staged and un-staged. In addition, this makes the proposed `status` changes of displaying `(Git: sha1 -> LFS: sha2)` much more clear when we can see both halves of ""staged"" and ""un-staged"". 

A bit of background: Since https://github.com/git-lfs/git-lfs/pull/137 (the introduction of the `status` command), we've taken the set-intersection of `git diff-index -M --cached` and `diff-index -M` by _file name_. This gets us around showing the same file twice in the status list, but isn't quite right.

Since we now partition into staged and un-staged changes as of #2042, we can show the same file twice if that file is both staged and un-staged. The way that we do this is by generating a unique key as:

```go
func KeyForEntry(e *lfs.DiffIndexEntry) string {
        var name string = e.DstName
        if len(name) == 0 {
                name = e.SrcName
        }

        return strings.Join([]string{e.SrcSha, e.DstSha, name}, "":"")
}
```

which makes files unique by their _diff of their contents_ when they were marked staged or un-staged.

---

/cc @git-lfs/core",2634,True,en,1
2049,1,0,0,Externals,TheJare,2017-09-07T19:13:21Z,1,1,1,172,"I am not clear on the goal of fsck, but when I ran it on my repo it complained about missing objects that were old revisions of lfs-stored files. It then tried to move the offending objects' files to the ""bad"" folder and, since the files of course did not exist, it complained again.

I found this looked like a reasonable fix, and then saw #953 which seems to agree.",367,True,en,0
2048,2,1,0,Internals,ttaylorr,2017-03-24T17:34:29Z,14,11,4,6,This backports #2047.,21,False,en,2
2047,4,1,0,Internals,ttaylorr,2017-03-17T19:37:19Z,14,11,4,0,"This pull request fixes a bug introduced in https://github.com/git-lfs/git-lfs/commit/0677bdd06a97b60455dac2cfa19d54ff697a1e17 (via: [this blame view][1]) where un-initialized `lfsapi.Client` instances were used in place of the [real one][2].

Previously, this wasn't a problem, but since I added #1971 (which uses the API client), this caused a nil pointer de-reference `panic()` on pushes with verify actions using the Tus and custom transfer adapters.

@git-lfs/releases I think that this warrants being backported and released as v2.0.2. In the interim, or if we decided that this isn't worth it, we can always have users set the `lfs.basictransfersonly`. What do you think?

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/2046

[1]: https://github.com/git-lfs/git-lfs/blame/v2.0.1/tq/custom.go#L318-L323
[2]: https://github.com/git-lfs/git-lfs/blob/v2.0.1/tq/adapterbase.go#L67-L67",904,True,en,2
2042,6,0,2,Internals,ttaylorr,2017-03-22T16:56:33Z,117,64,4,5,"This pull-request brings us another step closer to adding additional information to the output of the `status` command by using the new `*lfs.DiffIndexScanner` instead of the `gitscanner`.

By doing so, we give the status command direct access to the `*lfs.DiffIndexScanner` instance, which will eventually receive methods that can answer and provide additional information about why certain files are modified. 

---

/cc @git-lfs/core ",437,True,en,1
2035,10,5,14,Internals,ttaylorr,2017-03-16T18:46:38Z,219,45,2,1,"This pull request extracts a `DiffIndexScanner` type that will be used by the `status` command to yield more helpful information about why certain files are modified.

Since both the proposed changes to the status command _and_ the `ScanIndex()` operation of the new gitscanner require scanning the output of the `diff-index` command, this PR is only mean to extract that common functionality.

---

/cc @git-lfs/core ",418,True,en,0
2033,2,0,0,Externals,dpursehouse,2017-03-15T16:21:24Z,2,2,1,0,,0,False,en,0
2028,3,1,0,Externals,dpursehouse,2017-03-14T15:08:13Z,3,3,1,0,,0,False,en,0
2023,2,16,3,Externals,bozaro,2017-07-12T15:44:34Z,92,20,9,124,**Motivation**: use single shared directory for multiple working copies on build farm. Sharing LFS storage directory allow reduce disk space usage and downloading time.,168,False,en,2
2021,3,6,0,Externals,grimreaper,2017-03-09T23:53:19Z,1,1,1,0,,0,False,en,0
2020,3,0,0,Internals,terrorobe,2017-03-10T17:38:41Z,6,0,1,1,The only example I found was in the [LFS wiki](https://github.com/git-lfs/git-lfs/wiki/Tutorial#lfs-url). I think it's prudent to at least provide one example showing how to create the config file in the man page as well.,221,False,en,0
2019,2,0,0,Internals,terrorobe,2017-03-10T17:32:38Z,9,7,1,1,"Followup to #1999 to work in @technoweenie's feedback. ❤️ 

I hope that covers the intention  & status quo well enough.",123,True,en,0
2008,1,0,1,Internals,ttaylorr,2017-03-06T23:30:28Z,16,4,5,0,/cc @git-lfs/core ,18,False,en,0
2007,1,0,0,Internals,ttaylorr,2017-03-06T22:50:08Z,114,58,11,0,,0,False,en,4
2004,10,1,12,Internals,ttaylorr,2017-03-06T22:20:12Z,114,58,11,0,"This pull-request teaches the `tq` package how to fallback to the deprecated `_links` property if it is given instead of `actions` in a batch response. It is intended to address https://github.com/git-lfs/git-lfs/issues/2003.

This functionality is implemented through a new, private type: `multiActionSet`, which behaves like `io.Multi{Reader,Writer}`, except that it instead implements the `ActionSet` interface. When the `HybridActions()` function is called, a `multiActionSet` is composed together, making both `actions` and `_links` accessible.

Unfortunately, the public interface for `tq.Transfer` now includes:

- `tq.Transfer.Actions`
- `tq.Transfer.Links`
- `tq.Transfer.HybridActions()`

Which, to me, feels bloated. `Actions` and `Links` are necessarily left public so as to allow the `encoding/json` package to modify those fields via the `reflect` package.  

EDIT: One thing we could do is make the `HybridActions()` function private in the interim, until this behavior is no longer supported.

Once this merges, I'll go ahead and backport this into the `release-2.0` branch, and schedule a release of v2.0.1.

---

/cc @git-lfs/core 
/xref https://github.com/git-lfs/git-lfs/issues/2003",1202,True,en,4
1999,1,2,3,Internals,terrorobe,2017-03-03T19:02:15Z,5,0,1,0,Seems like this isn't mentioned anywhere else except in the git-lfs tutorial. Feel free to nit on the wording.,110,False,en,0
1990,2,1,3,Internals,technoweenie,2017-03-01T16:27:39Z,179,5,5,0,,0,False,en,0
1989,1,0,0,Internals,technoweenie,2017-03-01T01:29:00Z,59,57,5,0,"This is the only way I could get the rpm docker builds to pass :( These tests have been working in CI for weeks, but the first attempt to build with `./docker/run_dockers.bsh centos_6` failed:

```
test: post-merge ...                                               FAILED
-- stdout --
    set up remote git repository: test-post-merge
    Initialized empty Git repository in /tmp/docker_run/src/github.com/git-lfs/git-lfs/rpm/BUILD/git-lfs-2.0.0/test/remote/test-post-merge.git/
    clone local git repository test-post-merge to test-post-merge
    Cloning into 'test-post-merge'...
...
    Downloading file1.dat (23 B)
    Downloading file2.dat (23 B)
    Downloading file3.big (15 B)
    Downloading file4.big (15 B)
-- stderr --
    + set -e
    ++ basename test/test-post-merge.sh .sh
    + reponame=test-post-merge
    + setup_remote_repo test-post-merge
    + local reponame=test-post-merge
    + echo 'set up remote git repository: test-post-merge'
    + repodir=/tmp/docker_run/src/github.com/git-lfs/git-lfs/rpm/BUILD/git-lfs-2.0.0/test/remote/test-post-merge.git
    + mkdir -p /tmp/docker_run/src/github.com/git-lfs/git-lfs/rpm/BUILD/git-lfs-2.0.0/test/remote/test-post-merge.git
    + cd /tmp/docker_run/src/github.com/git-lfs/git-lfs/rpm/BUILD/git-lfs-2.0.0/test/remote/test-post-merge.git
    + git init --bare
    + git config http.receivepack true
    + git config receive.denyCurrentBranch ignore
    + clone_repo test-post-merge test-post-merge
    + cd /tmp/tmp.WbUxi0lPQl/test-post-merge.sh-28893
    + local reponame=test-post-merge
    + local dir=test-post-merge
    + echo 'clone local git repository test-post-merge to test-post-merge'
    ++ git clone http://127.0.0.1:46217/test-post-merge test-post-merge
...
    + echo 'Cloning into '\''test-post-merge'\''...
    Downloading file1.dat (23 B)
    Downloading file2.dat (23 B)
    Downloading file3.big (15 B)
    Downloading file4.big (15 B)'
    ++ cat file1.dat
    + '[' 'file 1 updated commit 2' == 'file 1 updated commit 2' ']'
    ++ cat file2.dat
    + '[' 'file 2 updated commit 3' == 'file 2 updated commit 3' ']'
    ++ cat file3.big
    + '[' 'file 3 creation' == 'file 3 creation' ']'
    ++ cat file4.big
    + '[' 'file 4 creation' == 'file 4 creation' ']'
    + '[' '!' -e file5.dat ']'
    + '[' '!' -e file6.big ']'
    + '[' '!' -w file1.dat ']'
    + test_status=1
```

This is clearly a hack, but at least now all of the calls are in helper functions that can be fixed once we find the underlying cause.",2502,True,en,5
1987,3,1,0,Internals,technoweenie,2017-02-28T00:00:25Z,51,51,5,0,"Three small things:

1. I thought printing the doc url and request id for every error was too noisy. Especially, when some are common errors like attempting to unlock someone else's file.
2. Added IDs to the `git lfs locks` output.

        $ git lfs locks
        collabocats.txt	ttaylorr	ID:1
        supportocat.txt	technoweenie   	ID:2

3. `git lfs unlock --id={id}` was causing Go to panic since `args` is nil. Fixed that, and updated the test that let the error slide by piping the contents to `tee`.",506,True,en,1
1986,1,0,0,Internals,technoweenie,2017-02-27T18:49:14Z,2,11,1,0,"Some of the new lock commands return 403 for legitimate reasons:

* Attempt to unlock someone else's lock.
* Attempt to create lock that already exists.
* Attempt to force unlock without proper privileges to do so.

This can also happen with the batch api, if you only have read, but not write, access to a repository.

These cases shouldn't force you to log in again. Typically, users have to confirm their settings on their git host.",435,True,en,0
1983,5,2,0,Internals,technoweenie,2017-02-27T16:40:09Z,57,12,8,2,"This adds `error.Cause()`, which removes all those error wrap prefixes when printing messages to stderr.

```
# BEFORE
$ git lfs lock path/to/file
Lock failed: api: http: http: Lock exists

# AFTER
$ git lfs lock path/to/file
Lock failed: Lock exists
```",254,True,en,2
1982,1,0,0,Externals,sschuberth,2017-02-24T20:54:33Z,1,0,1,0,,0,False,en,0
1980,1,0,0,Externals,sschuberth,2017-02-24T16:41:06Z,2,0,1,0,"This should solve build errors like the one in

https://circleci.com/gh/git-lfs/git-lfs/1012",92,True,en,0
1979,3,0,0,Externals,sschuberth,2017-02-24T17:07:01Z,9,7,3,0,"Please have a look at the individual commit messages for the details.

Depends on PR #1980.",91,True,en,0
1978,4,0,1,Internals,technoweenie,2017-02-24T00:21:02Z,89,77,8,0,"This improves (IMO) some of the lock messages:

1. Use active voice for lock and unlock
2. Line up `locks` output columns

## OLD

```sh
$ git lfs lock gif/dupe.gif

'gif/dupe.gif' was locked (272)

$ git lfs locks
jpg/kabuki-tattoo-left.JPG	technoweenie
gif/atom-undo.gif	technoweenie
gif/dupe.gif	technoweenie

3 lock(s) matched query.
```

## NEW

```
$ git lfs lock lock.json
Locked lock.json

$ git lfs locks
jpg/kabuki-tattoo-left.JPG	technoweenie
gif/atom-undo.gif         	technoweenie
gif/dupe.gif              	technoweenie
```",537,True,en,5
1971,7,7,2,Internals,ttaylorr,2017-02-22T23:00:06Z,209,10,6,0,"This pull-request implements `lfs.transfer.maxverifies`, a `.gitconfig` setting to retry verify requests at the end of an upload a configurable number of times.

Closes: #1781.

---

/cc @git-lfs/core ",201,True,en,3
1968,1,0,0,Externals,sschuberth,2017-02-21T20:38:51Z,1,1,1,0,This is nicer than removing the system Go directory.,52,False,en,0
1966,5,18,2,Externals,sschuberth,2017-02-23T18:22:37Z,23,11,1,2,Please have a look at the individual commit messages for the details.,69,False,en,0
1965,7,10,0,Internals,ttaylorr,2017-02-28T22:46:57Z,118,30,6,8,"This pull-request expands on #1820 by spiking out some functions in the `tools` package to convert Windows paths to Cygwin paths. 

This was prompted by https://github.com/git-lfs/git-lfs/issues/865#issuecomment-281044331, which was comparing the Windows path from `os.Getwd()` with the Git working dir in Cygwin format from `config.LocalWorkingDir`.

Since we don't have integration tests on Cygwin (though we should look into that) I'm leaving this as a [WIP] until we can verify that it works as expected.",508,True,en,0
1962,8,1,0,Internals,ttaylorr,2017-02-21T21:23:30Z,132,1,4,2,"This pull-request fixes #1895 by implementing `tools.QuotedFields`, an alternative to `strings.Fields` that respects balanced pairs of quotes.

The problem in #1895 is that a `GIT_SSH_COMMAND` with spaces inside a balanced pair of quotes would be truncated across multiple ""fields"", causing the arguments to be passed incorrectly.

For instance, the following string:

```
foo bar 'baz ""etc""'
```

given to `strings.Fields` would return:

```go
[]string{""foo"", ""bar"", ""'baz"", ""\""etc\""'""}
```

whereas given to `tools.QuotedFields`, it instead returns:

```go
[]string{""foo"", ""bar"", ""'baz \""etc\""'""}
```

When trying to figure out the best way to implement this, I considered a few options:

- Instantiate the `exec.Cmd` in such a way that we wouldn't need to de-quote the input string.
- Write a `func(c rune) bool` that could be given to `strings.FieldsFunc`
- Use a regexp.

My findings were that the first and second options were both not possible. In particular, the second option seemed more attractive to me, since it would be a more easily approachable implementation. However, according to the docs of `strings.FieldsFunc`<sup>[[1]](https://golang.org/pkg/strings/#FieldsFunc)</sup>:

> FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.

In my testing, I was not able to make `FieldsFunc` crash, but since we can't rely on that behavior in the future, I chose to implement this with a regular expression instead. It turns out the regular expression isn't that complicated, so I'm fine going forward with this approach.

I also tried my hand at implementing this in a loop that scans each rune in the string and composes the string slice itself. I found this to be much more complicated than the regex, for not a significant performance gain:

```
~/g/git-lfs (fix-fields-with-quotes!) $ go test -bench='BenchmarkQuote' ./tools
BenchmarkQuoteWithRegex-4         500000              3482 ns/op
BenchmarkQuoteWithLoop-4         1000000              1025 ns/op
PASS
ok      github.com/git-lfs/git-lfs/tools        2.977s
```

As a side note, I used this PR as an opportunity to try out the new `testing.T.Run` method in Go 1.8.

---

/cc @git-lfs/core ",2254,True,en,2
1961,1,1,0,Internals,ttaylorr,2017-02-21T17:30:04Z,9,8,4,2,"This pull request bumps the default maximum retries LFS will make before failing an object transfer to eight, in conjunction with #1781.

---

/cc @git-lfs/core ",161,True,en,2
1959,2,4,0,Externals,sschuberth,2017-02-19T07:02:26Z,6,3,3,0,"This time for version 1.8.0, which is available now.",52,False,en,0
1958,4,1,8,Internals,ttaylorr,2017-02-18T00:49:48Z,67,6,3,0,"This pull-request fixes a bug that caused the progress meter to display that it had transferred more bytes than were included in the total push.

To set things up, I'm running a basic LFS server on my laptop that is configured to return an HTTP 400 when a client tries to upload more than 10 bytes. I've configured my repo to use that remote, and to push 502 files, the first 501 are less than 10 bytes.

```
~/D/pull-bug (master) $ git config lfs.transfer.maxretries
100
~/D/pull-bug (master) $ git lfs push local master
Git LFS: (501 of 502 files) 102.85 KB / 2.85 KB
LFS: Client error: http://[::]:55994/storage
```

The push is comprised of:

- 501 (less than 10b) files totaling a size of 1.85 KB
- 1 (1k) file

LFS uploads the first 1.85 KB successfully, and then tries 100 times (unsuccessfully) to upload the last file, but fails to decrement before it retries again, which is why the progress meter goes ""over"" the total count.

A more robust fix would expand the `tq.Adapter` interface to provide a flexible way for _all_ transfer adapter implementations to report if they ""lost"" progress, but I think that fixing the most common case with relatively low effort is a good first step.

I originally wanted to call `Seek(0, io.SeekCurrent)` on the open file descriptor, but I decided against this for two reasons:
1. This forces us to keep the file descriptor open.
2. It binds the underlying reader to implement `io.Seeker`, which may not always be the case.

Instead, I wrote a new type in the `tools` package, to implement `io.ReadSeeker` (and `io.Closer`, for usage with the `lfsapi` package) which atomically keeps track of the number of bytes read. Importantly, it also ""overrides"" the `Seek()` method, so any sort of seeking that we do will still yield correct updates to the total number of bytes read.

In conclusion:

```
~/D/pull-bug (master) $ git lfs push local master
Git LFS: (501 of 502 files) 1.85 KB / 2.85 KB
LFS: Client error: http://[::]:55994/storage
```

works as expected.

---

/cc @git-lfs/core ",2029,True,en,1
1957,1,0,0,Internals,technoweenie,2017-02-17T19:15:50Z,28,22,5,0,"I got tired of seeing this everywhere. Also, the `""()""` was breaking Atom's syntax highlighting and driving me nuts :)",118,False,en,5
1955,5,1,0,Internals,ttaylorr,2017-02-17T17:30:07Z,109,8,3,0,"This pull-requests fixes #1926, a bug which would cause push/pull operations with small objects to look like this:

```
~/Desktop $ git lfs clone git@github.com:larsxschneider/lfstest-manyfiles.git
Cloning into 'lfstest-manyfiles'...
remote: Counting objects: 15012, done.
remote: Total 15012 (delta 0), reused 0 (delta 0), pack-reused 15012
Receiving objects: 100% (15012/15012), 2.02 MiB | 2.25 MiB/s, done.
Checking out files: 100% (15001/15001), done.
Git LFS: (87 of 201 files) 0 B / 1.15 KB
                           ^
```

The issue lies in the fact that `io.Reader`s, when at the end of a stream, can either return 
- `([]byte, nil)` then `(nil, io.EOF)`, or
- `([]byte, io.EOF)`

From the Go documentation<sup>[[1](https://golang.org/pkg/io/#Reader)]</sup>:

> An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.

Particularly, the problem lied [here][1]:

```go
if err == nil && w.C != nil {
	err = w.C(w.TotalSize, w.ReadSize, n)
}
```

`err` could be `io.EOF` even when there was a positive number of bytes `n` to progress upon. This happens when the buffer ""p"" being read into is larger than the available data on the stream. In other words, small files make this incredibly common.

However, changing `err == nil` to `err == nil || err == io.EOF` isn't quite the right fix, since `(nil, io.EOF)` is a valid return value from io.Readers. Instead, let's check for positive values of `n`, and increment based on that. This is semantically equivalent to `err == nil || (err == io.EOF && n > 0)`, since the interface documentation specifies that non-nil errors should indicate zero bytes read.

I added an integration test to verify that we counted the bytes correctly for small files, and a unit test to prevent further regressions.

```
~/Desktop $ git lfs clone git@github.com:larsxschneider/lfstest-manyfiles.git
Cloning into 'lfstest-manyfiles'...
remote: Counting objects: 15012, done.
remote: Total 15012 (delta 0), reused 0 (delta 0), pack-reused 15012
Receiving objects: 100% (15012/15012), 2.02 MiB | 2.40 MiB/s, done.
Git LFS: (61 of 201 files) 366 B / 1.15 KB
```

---

/cc @git-lfs/core 

[1]: https://github.com/git-lfs/git-lfs/blob/c22c48bb6471499f57ffbbe5dbfbaa6c1a1e9e35/progress/copycallback.go#L57",2372,True,en,2
1954,1,0,0,Internals,ttaylorr,2017-02-17T01:54:18Z,42,5,2,0,"This pull request treats empty pointers as empty objects, and writes them out as such.

Previously, an empty pointer would be treated as malformed. An empty file _would_ get written out, but the file would also be marked as belonging to a malformed pointer.

With this change, LFS counts the number of bytes spooled out to Git. If there was no error in spooling, and the number of bytes written is zero (meaning that we successfully wrote zero bytes with the intent to do so), return a nil error, instead of marking it as a malformed pointer.

--- 

/cc @git-lfs/core 
/x-ref https://github.com/git-lfs/git-lfs/pull/1922",620,True,en,1
1953,6,0,0,Internals,technoweenie,2017-02-17T17:29:52Z,299,138,13,0,"This updates the pre-push hook to verify that any changes to non-lfs objects are not locked by other users. The Git Scanner will already ignore any blobs if they are over the size threshold, or if the contents are not parseable LFS pointers. So, this PR does the following:

1. Adds a `FoundLockable` callback on GitScanner. Since only the pre-push command cares, other Git Scanner uses don't need to bother setting this.
2. If `catFileBatchCheckScanner` encounters a file over the blob size cutoff, it gets the filename from the `ScanRefsOptions` (which the `revListScanner` fills), and then sees if that filename is locked by another user. If so, it writes to a chan that eventually calls the `FoundLockable` callback.
3. If `catFileBatchScanner` cannot parse a valid LFS pointer, it also gets the filename from the `ScanRefsOptions` and sees if that filename is locked by another user.
",889,True,en,2
1952,1,2,0,Internals,ttaylorr,2017-02-17T00:06:49Z,5,2,2,0,"This pull request upgrades our testing infrastructure to use Go 1.8.

- Travis: bumped in the `.travis.yml` to use 1.8.
- AppVeyor: Go 1.8 isn't in on `cinst` yet, so let's install it ourselves.
- CircleCI: upgrade through https://github.com/Homebrew/homebrew-core/pull/10048

---

/cc @git-lfs/core ",300,True,en,0
1951,9,1,6,Internals,ttaylorr,2017-02-17T00:13:37Z,299,48,6,0,"This pull-request allows the LFS client to be configured in such a way that makes lock verification a no-op for servers that don't yet support the new locking API.

At face value, this also makes it very easy for users to disable lock verification to push locked files to servers that don't block pushes not owned by the lock owner. However, there's really no change before/after this PR, since all of this logic is wrapped up in a Git hook anyway, you can still just delete the hook.

Here are the rules:

- If the `.locksverify` rule is unset, make the verify API call...
  - If it was successful, notify the user they should ""enable"" lock verification for that remote
  - If it failed...
    - AND the failure was a 501, disable the lock verification and move on
    - OR print a warning, but still push
- If the `.locksverify` config is true, make the verify API call...
  - If it was successful, move on
  - If it failed...
    - AND the failure was a 501, disable the lock verification and move on
    - OR print a warning and halt the push  
- If the `.locksverify` config was false, skip the verify API call.

Pushing to a sever that doesn't support locking:

```
~/g/git-lfs (optional-pre-push) $ git push origin master
[master (root-commit) edbdd87] initial commit
 2 files changed, 4 insertions(+)
 create mode 100644 .gitattributes
 create mode 100644 a.dat
Remote ""origin"" does not support the LFS locking API. Consider disabling it with:
  $ git config lfs.http://127.0.0.1:61354/lock-unset-verify-5xx.git/info/lfs.locksverify false
http: Fatal error: Unable to parse HTTP response for POST http://127.0.0.1:61354/lock-unset-verify-5xx.git/info/lfs/locks/verify: EOF
```

Pushing to a server that does support locking:
```
~/g/git-lfs (optional-pre-push) $ git push origin master
[master (root-commit) a4f4c34] initial commit
 2 files changed, 4 insertions(+)
 create mode 100644 .gitattributes
 create mode 100644 a.dat
Locking support detected on remote ""origin"". Consider enabling it with:
  $ git config lfs.http://127.0.0.1:61383/lock-unset-verify.git/info/lfs.locksverify true
Git LFS: (1 of 1 files) 7 B / 7 B
To http://127.0.0.1:61383/lock-unset-verify
 * [new branch]      master -> master
```

---

/cc @git-lfs/core ",2241,True,en,4
1950,1,0,0,Internals,technoweenie,2017-02-16T16:41:04Z,16,4,6,0,"Getting the deadlock fix from http://github.com/git-lfs/git-lfs/pull/1932 out to users.

/cc @git-lfs/core ",107,True,en,0
1947,1,0,0,Internals,ttaylorr,2017-02-16T17:22:44Z,0,199,2,0,"This pull-request removes the `lfs.Batcher` type, which is unused as of https://github.com/git-lfs/git-lfs/pull/1758.

It also removes my very first contribution to Git LFS (https://github.com/git-lfs/git-lfs/pull/613) 😢 .

---

/cc @git-lfs/core ",250,True,en,1
1946,2,0,0,Internals,technoweenie,2017-02-15T20:29:34Z,46,83,11,0,Final step of https://github.com/git-lfs/git-lfs/issues/1908,60,False,en,7
1940,2,1,0,Internals,technoweenie,2017-02-14T23:11:04Z,66,1,3,0,"This backports #1932.

Conflicting files:
- commands/command_smudge.go
- tools/iotools.go",89,True,en,1
1938,2,0,0,Externals,sschuberth,2017-02-14T16:34:15Z,2,6,1,0,Also refresh the environment properly so both Golang 1.7.4 and Inno Setup are found in PATH.,92,False,en,0
1937,5,11,5,Internals,ttaylorr,2017-02-14T18:13:00Z,10,4,1,0,"This pull-request adds the `--dwarf` flag to `script/bootstrap`, and excludes DWARF tables from the compiled binaries by default.

Here are some ✨  metrics comparing the sizes of our binaries before/after:

Building a single (compressed) binary with DWARF tables:

```
~/g/git-lfs (scratch/no-dwarf-tables) $ ./script/bootstrap --dwarf && gzip < ./bin/git-lfs | wc -c
commands/mancontent_gen.go
Using go1.8rc3
 3434387
```

Building a single (compressed) binary without DWARF tables:

```
~/g/git-lfs (scratch/no-dwarf-tables) $ ./script/bootstrap && gzip < ./bin/git-lfs | wc -c
commands/mancontent_gen.go
Using go1.8rc3
 2673122
```

This shaves 22% (761265 bytes -> .76 MB) off of the compressed binaries. I ran some tests against all of the platforms/architectures we build for, and the average size reduction of the compressed releases was 

| darwin-386 | darwin-amd64 | freebsd-386 | freebsd-amd64 | linux-386 | linux-amd64 | windows-386 | windows-amd64 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 3213504 | 3446603 | 3229616 | 3443504 | 3225807 | 3443145 | 3212684 | 3436845 |
| 2473611 | 2685306 | 2345922 | 2540355 | 2344751 | 2540280 | 2348202 | 2548085 |
| -23.02% | -22.09% | -27.36% | -26.23% | -27.31% | -26.22% | -26.91% | -25.86% |

With an average of a __-25.63% reduction in compressed size__.

A couple of notes:

1. I made omitting the DWARF tables the default behavior for `script/bootstrap`, since that's the way we'll build it for release, I think we should be as close to that as possible in development/test environments. I don't use `dlv` often with LFS, but if you need to have the debugger symbols, you can always re-run `script/bootstrap` with the `--dwarf` flag.
2. I chose to skip further compression with `upx`<sup>[[1]](https://upx.github.io/)</sup> which seems to yield an average compression of [about 15-25%][2]. Though this would further reduce the size, it would increase the startup time by anywhere from 15-160msec. A while ago, @technoweenie stated his concern in https://github.com/git-for-windows/build-extra/pull/110#issuecomment-211387162:

> I don't want to do anything that increases startup time (such as `upx` compression), since the default configuration using git clean/smudge filters can call the `git-lfs` binary many times on large repositories. But, we can probably live without debugging.

Before merging, I'd like to revisit this point to see if it's still the case with the `process` filter being more prominent and startup cost being less of a concern. Personally, I'd avoid further compression with `upx` or similar since even the minimum of 15ms extra to launch a command seems like too much to me. Additionally, for users still rocking the legacy single-process clean/smudge filters, the overhead would be much more noticeable during large checkouts.

[2]: https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/

---

/cc @git-lfs/core @dscho ",2938,True,en,0
1936,5,0,8,Internals,technoweenie,2017-02-15T21:04:03Z,140,67,11,1,"* Removes `lfs.batch` completely. I noticed it was listed in `git-config.5.ronn`.
* Adds the bare minimum docs for `lock/unlock/locks`.

I'll add more for the comments:

* [x] `lock` requires the file to exist
* [x] `unlock` requires a clean git history, and for the file to exist
* [x] `unlock --force` skips those requirements

Anything else?",344,False,en,3
1932,8,7,7,Internals,ttaylorr,2017-02-13T21:07:48Z,66,1,3,2,"This pull-request mitigates the pipe buffer problem described in https://github.com/git-lfs/git-lfs/pull/1922#issuecomment-279024324 by spooling the contents of malformed pointers to a temporary file on disk before writing them back out to Git.

# Background

LFS and Git have essentially three scenarios under which they exchange files:

1. Git sends a (valid) pointer file, LFS responds with a large object.
2. Git sends a large object (tracked with LFS), LFS responds with a (valid) pointer.
3. Git sends a (malformed) pointer file, LFS responds with the same contents.

The snag is that Git does all of its `write()`s before any `read()` occurs on the shared pipe. This is fine in scenarios 1 & 2, since LFS drains the incoming data from Git continually, allowing the outgoing `write()`s to not exceed the pipe buffer.

Prior to this pull-request, scenario three would cause Git/LFS to hang when the size of the malformed pointer was at least half of the maximum pipe buffer size. Since LFS is essentially `tail -f`-ing the incoming contents while Git is still `write()`-ing, so there are no corresponding `read()`s, and the pipe buffer fills up.

# Solution

A temporary solution for LFS is to [spool][1] the contents of the malformed pointer entirely _before_ writing any data back out to Git. This means that while Git is `write()`-ing to the pipe, LFS is continually `read()`-ing that data, and LFS delays it's `write()`s until after Git is done, thus unblocking the pipe.

I'd eventually like to see an upstream patch in `git.git` (cc @larsxschneider @peff) using `select()`-based I/O, which would prevent other implementations of the process filter from having to adopt this same behavior.

One other approach proposed by @larsxschneider was:

> If Git LFS detects a malformed pointer then we can just return an empty response with the status `error`. This would cause Git to use the file ""as-is"" and we wouldn't even waste any time to transfer this file over the pipe from Git LFS to Git, again.

This would work, but requires us to set `filter.lfs.required` to `false`, which prevents us from responding with ""real"" errors that are intended to halt the checkout.

## Implementation

I considered a few other approaches to the Go implementation:

1. An `io.Writer` that spooled internally, making it possible to write:

```go
io.Copy(Spool(to), pbuf)
```

but this requires the implementation of the writing end of ""to"" to know when it is done being written to, of which there is no reliable way to detect.

2. Creating a temporary buffer in memory of a fixed size that would be written to _before_ spooling out to disk.

This would prevent slower disk I/O in a few cases where the malformed pointer's size is less than half of the pipe buffer, but introduces complexity not only in implementation, but platform-specific bindings. The pipe buffer size varies among operating systems _and_ platforms, so the tradeoff didn't seem worthwhile to me, but if others feel differently I'm happy to implement this.  

---

/cc @git-lfs/core for review

[1]: https://en.wikipedia.org/wiki/Spooling",3098,True,en,1
1931,8,0,0,Internals,technoweenie,2017-02-13T20:52:34Z,1162,883,38,2,"This adds JSON schemas for the locking API, and tests with all of the schemas in the `locking` and `tq` packages.",113,False,en,5
1930,4,5,0,Externals,sschuberth,2017-02-11T12:14:33Z,10,2,1,0,Closes #1929.,13,False,en,0
1927,4,0,7,Internals,technoweenie,2017-02-13T18:26:32Z,31,5,3,3,Fixes #1925,11,False,en,1
1924,1,2,0,Internals,technoweenie,2017-02-09T17:20:19Z,4,1,2,0,"This makes it super clear that you're not on an official LFS release.

```
$ script/run version
git-lfs/2.0-pre (GitHub; darwin amd64; go 1.7.5; git a699d202)
```",162,True,en,0
1921,2,1,0,Internals,technoweenie,2017-02-07T20:46:00Z,23,7,2,0,Just got a report from a Visual Studio user that `git lfs track` blows up when parsing the default `.gitattributes` that VS sets up. This fixes a bug with handling blank lines.,176,False,en,1
1914,12,0,1,Internals,technoweenie,2017-02-13T21:19:57Z,200,22,7,9,"This updates `git lfs track` to end lines written to in `.gitattributes` with a CRLF (`\r\n`) IF:

1. The file currently uses CRLF.
2. OR the `core.autocrlf` is `true` or `input`
3. OR it's running on windows.

Should fix #1543",227,True,en,2
1913,1,0,0,Internals,technoweenie,2017-02-06T14:47:57Z,1,1,1,2,Really minor tweak that ensures that Git LFS will attempt to convert `lfs.pushurl` or `remote.{name}.pushurl` to build the LFS server url.,138,False,en,0
1912,5,13,1,Internals,technoweenie,2017-04-12T20:23:20Z,107,0,2,68,"This is an exploration of what it'd take to support `http.{url}.*` support (/cc #1500). The trick here is that [git-config's rules for `http.{url}.*` keys](https://git-scm.com/docs/git-config#git-config-httplturlgt) support a lot of rules for matching keys.

Given a url like `https://git-server.com/user/repo.git/info/lfs/objects/batch`, this code will look for these keys, where `suffix` is one of the [`http` config keys](https://git-scm.com/docs/git-config#git-config-httpproxy)

```
http.https://git-server.com/user/repo.git/info/lfs/objects/batch/.suffix
http.https://git-server.com/user/repo.git/info/lfs/objects/batch.suffix
http.https://git-server.com/user/repo.git/info/lfs/objects/.suffix
http.https://git-server.com/user/repo.git/info/lfs/objects.suffix
http.https://git-server.com/user/repo.git/info/lfs/.suffix
# ...
http.https://git-server.com/.suffix
http.https://git-server.com.suffix
http.suffix
```

One concern I have is that this is a lot of checks, even if it's mostly just building lots of strings, and doing lots of map lookups. Though, that's likely not much compared to actually making an http request.

Is my interpretation of the config rules correct? Should we use this as a basis for supporting `http.extraheader`?

TODO:

* [x] rename type from `httpconfig` to `urlconfig`
* [x] include property to specify the key prefix (typically `http` or `lfs`)
* [x] Use when accessing `http.<url>.extraheader`
* [x] Use when accessing `http.<url>.*`
* [ ] Use when accessing `lfs.<url>.access`
* [ ] Use when accessing `lfs.<url>.locksverify`
",1564,True,en,1
1910,2,0,0,Internals,technoweenie,2017-02-06T15:04:51Z,8,8,1,3,I think this is a better way to handle the feedback in https://github.com/git-lfs/git-lfs/pull/1905#discussion_r99072847.,121,False,en,0
1909,10,3,18,Internals,technoweenie,2017-02-09T16:17:23Z,591,150,13,7,"Here's the first draft of the locking api docs. I made a few drastic changes, but hopefully before the pitchforks need to come out :) 

1. Killed `lock.remote`, which is completely unnecessary.
2. Killed `lock.latest_remote_commit` and `lock.commit_sha` until we completely figure out how they should be used.
3. No more `commit_needed` response when trying to create a lock, since `lock.latest_remote_commit` is no longer part of the request.
4. The unlock request body no longer sends an `id` property, since it's already in the URL.
5. The big one: the `error` property was renamed to `message` to be more consistent with the Batch API error responses.
6. Remove `committer` from lock creations
7. Rename `committer` to `owner` when fetching locks. Remove `committer.email` too.

In addition to renaming `error` to `message`, this adds the optional `request_id` and `documentation_url` error properties that the Batch API error responses use. This extra info can help with troubleshooting. Hopefully a locking service will include their own `documentation_url` for user assistance, before users try posting an issue here. It's very possible that locking issues can be service related, and not client bugs.

If these changes look fine, I'll make the tweaks in the code before waiting on final reviews and merging.

* [x] Finish and merge #1905 (this PR documents that API)
* [x] Finalize API details
* [x] Update client code for the changes",1442,True,en,5
1905,4,1,6,Internals,technoweenie,2017-02-02T15:39:59Z,425,96,7,1,"This implements https://github.com/git-lfs/git-lfs/issues/1891

TODO:

* [x] Ship https://github.com/git-lfs/git-lfs/pull/1904
* [x] Write integration tests

Hit me up with any review comments on the go code though. I'm not crazy about the name `VerifiableLocks()`, and am open to suggestions there.",299,True,en,4
1904,4,0,5,Internals,technoweenie,2017-02-01T15:27:56Z,42,41,3,0,"This updates the lfs test gitserver to store locks per repo, instead of in a global slice.",90,False,en,3
1896,9,2,13,Externals,sinbad,2017-02-06T20:52:06Z,168,0,3,7,"A user should not have any uncommitted changes in their working copy when unlocking a file, since to relinquish the lock means that they've either finished making changes, or they don't want to keep their changes. It must be assumed that when relinquishing the lock other users are free to lock & begin making changes immediately which would clash with these outstanding changes.

`--force` overrides this check but with a warning.

This is only part of the overall solution; in future we'll also want to ensure they don't have any unpushed changes before allowing the unlock since those will have the same effect. However this will form part of #1844 which is a more complex proposal. This is an easy win in comparison and easy to understand.",743,True,en,1
1893,11,1,4,Internals,technoweenie,2017-01-26T19:53:10Z,290,10,8,1,"This is a continuation of #1869. It ignores a common error from git users on the mac when trying to send ssl client certs. This also lets me run the circleci builds, since they didn't on #1869 for some reason.",209,False,en,6
1890,4,0,1,Internals,technoweenie,2017-01-26T19:01:58Z,111,14,8,1,"I noticed a few inconsistencies with the completely rewritten API code:

1. Requests from Git LFS aren't sending a `Content-Length` request header.
2. ALL ssh auth requests send the `upload` operation, which interferes with the SSH command `ssh  user@githost.com git-lfs-authenticate user/repo {operation}`.

This PR fixes both.",328,True,en,4
1887,3,0,2,Internals,technoweenie,2017-01-25T16:19:09Z,85,28,6,0,Fixes #1753,11,False,en,1
1886,4,3,4,Internals,technoweenie,2017-01-26T16:52:01Z,12,3,4,1,"This is an attempt to fix #847. It pauses the progress meter before making the batch api request, and then starts it when it passing the batch api response to the transfer adapters. This works because:

* `(progress.Meter) Start()`, `Finish()`, and `Pause()` internally use channels and `atomic/sync`. No need for that `sync.Once` in `tq.TransferQueue`.
* The `tq.TransferQueue` only transfers items from a single batch concurrently. The sequence (Batch API -> _n_ transfer adapter workers) runs sequentially, so that the next batch (if needed) can process the retries from the previous batch.

Unfortunately, there isn't really a way to test this, since it requires interactive input.  Here's an example of this PR working (with a tiny hack to change the batch size to 2):

```
$ git lfs fetch --all 2>&1
Scanning for all objects ever referenced...
✔ 9 objects found
Fetching objects...
Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (0 of 9 files) 0 B / 1.03 MB                                                                                                                                                                                                        Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (3 of 9 files) 356.27 KB / 1.03 MB                                                                                                                                                                                                  Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (5 of 9 files) 886.59 KB / 1.03 MB                                                                                                                                                                                                  Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (7 of 9 files) 948.33 KB / 1.03 MB                                                                                                                                                                                                  Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (9 of 9 files) 1000.70 KB / 1.03 MB
```

Here's the same, without pausing:

```
$ git lfs fetch --all 2>&1
Scanning for all objects ever referenced...
✔ 9 objects found
Fetching objects...
Username for 'https://github.com': technoweenie
Password for 'https://technoweenie@github.com':
Git LFS: (1 of 9 files) 0 B / 1.03 MB                                                                                                                                                                                                        UGit LFS: (2 of 9 files) 0 B / 1.03 MB
```",2893,True,en,0
1885,3,1,2,Internals,ttaylorr,2017-01-23T23:14:02Z,10,17,2,0,"This pull-request temporarily makes failed lock searches and pushes containing modifications to un-owned locks non-fatal.

---

/cc @git-lfs/core ",146,True,en,1
1877,3,0,0,Internals,ttaylorr,2017-01-23T18:34:45Z,15,13,5,3,"This pull-request changes all references to the `Committer` type within the `locking` package to use `*Committer`, which implements `fmt.Stringer`.

It also adds integration tests to ensure that the committer is formatted correctly when asking for a list of locks.

---

/cc @git-lfs/core ",289,True,en,2
1870,36,0,0,Externals,sinbad,2017-01-19T12:08:45Z,1399,156,30,2,"This is really just #1822 brought up to date with master. I had quite a hassle resolving all the conflicts since quite a lot of structural changes are being made in master that overlapped with this and I'd rather not have to keep doing that, so would like to merge it.

",270,True,en,11
1868,2,1,0,Externals,sinbad,2017-01-19T11:41:45Z,29,2,4,2,"It's bugged me for a while that the integration tests keep creating the `pre-push` hook in my local `git-lfs` working copy repo whenever I run them; it gets much worse when you factor in the new hooks we're starting to add. This happens even if you use `GIT_LFS_TEST_DIR`, if you run the tests from within the working copy.

Seems useful to have a `--skip-repo` option in `git lfs install` which skips the local repo changes, for when you just want to install filters. This is how our tests need to use it. 

I could have just made the tests `cd` to a non-repo folder instead but being explicit seems better.",608,True,en,2
1863,2,0,2,Internals,ttaylorr,2017-01-13T20:49:56Z,24,19,4,0,"This pull-request reintroduces the `Committer` field on the `*locking.Lock` type.

This was the [original interface][1] of that type, but was removed in #1732 in favor of `Name` and `Email` top-level fields on the `Lock` type. Instead, let's bring back the original API which:

- has parity with how the data is sent over the network, and...
- is more direct in it's meaning. A lock has a committer, not a name and email. 

This pull-request also comes with some additional benefits:

1. Fix a bug where the `gitserver` was unable to find the fields to de-serialize the committer's name and email, thus making all locks have `""""` empty-string owners.
2. Implement `fmt.Stringer` on the `Committer` type, which yields the expected format: `First Last <email@example.com>`.

---

/cc @git-lfs/core 

[1]: https://github.com/git-lfs/git-lfs/blob/7f578a97cef74a2e7fef6723bfc6ce30e512e44b/api/lock_api.go#L113-L114",909,True,en,1
1861,4,9,10,Externals,monitorjbl,2017-01-23T18:15:36Z,118,7,6,9,,0,False,en,2
1857,1,2,0,Internals,ttaylorr,2017-01-12T20:45:38Z,16,4,6,0,cc @git-lfs/core ,17,False,en,0
1856,1,0,0,Internals,ttaylorr,2017-01-12T18:10:58Z,5,2,1,0,This backports #1852.,21,False,en,0
1852,2,0,0,Internals,ttaylorr,2017-01-12T17:19:11Z,5,2,1,0,"This pull-request fixes a bug where the entire contents of a malformed pointers would be buffered in memory, as reported in #1851.

Some backstory: in v1.5.4 I merged #1796 (via #1805) which re-added support to stream the entire contents of a malformed pointer though the filter-protocol added in Git v2.11. This involved a change to the signature of DecodeFrom where instead returning a `[]byte`, containing the data it buffered, it instead returned an `io.Reader` which contained the entire contents of the pointer and could be read from by the caller.

To bring the calling code up to speed, I introduced the following line to grab a `[]byte` of the data buffered from reading the pointer:

```go
by, rerr := ioutil.ReadAll(buf)
```

This is fine for small pointers, but will exhaust system memory when the malformed pointer is large. The original behavior was to only buffer _at most_ the first 1024 (see: `lfs.blobSizeCutoff`) bytes to return with the `NewCleanPointerError`, and this pull-request brings that back.

We only need to buffer the first 1k here, since when writing the data back via `NewCleanPointerError`, we're dealing with the case that the file is _already_ a pointer, and should be written back wholesale. More information about this code-path is in https://github.com/git-lfs/git-lfs/issues/1851#issuecomment-272028412.

The entire reader is still available if an error was not returned (i.e., if the `len(by) >= 512`), so that it can be copied to the writer, `writer`, on [L94](https://github.com/git-lfs/git-lfs/compare/buffer-blob-size-only?expand=1#diff-994fa3aaef34aea73bc14575fa685a83L94).

After some 👀 get a chance to take a look at this, I think we should release this patch as v1.5.5 (and hopefully the last patch in the 1.5.x series).

---

/cc @git-lfs/core #1851 ",1803,True,en,0
1850,1,0,0,Internals,technoweenie,2017-01-10T20:46:20Z,0,56,6,0,"This removes some deprecated functions in the `config.Environment` interface. This was used for the code that sets the `lfs.{url}.access` key, when an LFS endpoint requires authentication. Git LFS now handles this in the [`lfsapi.EndpointFinder`](https://github.com/git-lfs/git-lfs/blob/2e213cf9c4423c75f72cb9fbdf5acb16e11ea799/lfsapi/endpoint_finder.go#L180-L216) by caching the url in-memory when it's set. This is fine, since `git-lfs` is typically a short-lived command.

",476,True,en,0
1849,4,0,2,Internals,ttaylorr,2017-01-10T21:50:04Z,284,0,6,0,"This pull-request implements @technoweenie's idea in https://github.com/git-lfs/git-lfs/pull/1846#issuecomment-271621665 to introduce an `io.Reader` implementation: `schema.Reader`, capable of validating the data it's read against a JSON schema.

This will change our testing methodology a little bit, since instead of creating valid/invalid instances of request and response types, _then_ marshaling them to JSON, we have to valid data as it is sent and received. In other words, we'd be doing validation in `*net/http/httptest.Server`s against `req.Body`, which I think is a more appropriate level to test at, anyway.

---

/cc @git-lfs/core ",644,True,en,2
1847,3,0,0,Externals,sinbad,2017-01-10T16:19:07Z,7,3,3,0,"The message sent to terminate the custom adapter should have been named `event`, not `type`; this was left over from a terminology change and went unnoticed until it was pointed out in #1845 that it didn't conform to the docs.

This adds a test to check for that and fixes the problem. I've tested with our own Bitbucket custom adapter here and it's fine; like the test custom adapter it didn't notice this mistake because it was terminating when the I/O stream was closed anyway and there was no additional clean up.

Also includes a small tweak to the docs indicating the sequencing within a single adapter as ambiguity was pointed out in #1845.",647,True,en,1
1846,4,6,0,Internals,technoweenie,2017-01-10T20:14:42Z,28,6011,50,0,Bye old code :) See #1783 for discussion on the new `lfsapi` package that replaced all this.,92,False,en,17
1841,11,4,3,Internals,technoweenie,2017-01-09T23:26:13Z,171,143,9,3,This removes the last `api` dependency in `tq`.,47,False,en,3
1840,1,0,0,Internals,technoweenie,2017-01-07T03:23:34Z,83,7,3,0,Adds an NTLM integration test. Just rewrote #1836 on top of the API refactor #1839.,83,False,en,2
1839,117,0,0,Internals,technoweenie,2017-01-06T21:56:33Z,6004,1037,91,0,Fixes #1783,11,False,en,27
1838,7,0,0,Internals,technoweenie,2017-01-06T21:28:28Z,575,102,14,0,"This ports NTLM support from httputil to lfsapi, including the NTLM test added in #1836.  Some revelations:

1. NTLM support relies on your git credential helper to get the username (in the format `DOMAIN\USER`) and password. This is used to verify the server challenges, and generate client tokens.
2. Some things were still using `progress.CallbackReader`, which does not satisfy `lfsapi.ReadSeekCloser`. Fixed up the spots where this matters.",445,True,en,5
1837,4,0,1,Internals,technoweenie,2017-01-06T21:04:05Z,412,2,7,0,Ports SSH auth from the old httputil package. Uses the integration test added in #1825.,87,False,en,4
1835,1,0,0,Internals,ttaylorr,2017-01-06T16:53:19Z,10,7,3,0,"This pull-request updates the assertions added in #1814 (`assert_server_lock`, `refute_server_lock`) to include the `""$reponame""` argument, as added in #1818.

---

/cc @git-lfs/core #1820 ",189,True,en,3
1832,1,0,0,Internals,ttaylorr,2017-01-05T18:38:10Z,11,0,1,0,This backports #1801.,21,False,en,1
1827,24,1,7,Internals,technoweenie,2017-01-06T18:48:07Z,620,306,48,1,"This updates the `tq.TransferQueue` to use `lfsapi.Client` to make batch API requests, following the pattern set in #1824.

Changes:

* Removed the need for `access`, `operation`, or `remote` in `tq.Manifest`. I initially went with the approach described in https://github.com/git-lfs/git-lfs/pull/1826, but didn't like it. Now, a `*tq.Manifest` is fully immutable, and can be used across multiple transfer queues for different LFS servers. This was impossible before, since `access` was scoped to an LFS endpoint.
* The `tq.batchResponse` now stores the `lfsapi.Endpoint` used for the batch request. `tq.toAdapterCfg()` uses that Endpoint in conjunction with the transfer queue's `tq.Manifest` to provide the config for adapters. This is where the concurrency will be set to `1` for ntlm authenticated LFS services.
* `tq.NewTransferQueue()` now requires a `remote` argument, since it can't use `CurrentRemote` in `*config.Configuration`. 
* Updated all http transfer adapters to use `lfsapi.Client`.

TODO:

* [x] Review, merge (locking) #1824
* [x] Change base to `api-master`",1079,True,en,14
1825,3,1,0,Internals,technoweenie,2017-01-05T15:48:31Z,62,2,5,0,This adds a test for accessing the batch api on an ssh endpoint. The test sets `GIT_SSH` to a custom `ssh-echo` command so we don't have to set up a real ssh server.,165,False,en,3
1824,14,1,18,Internals,technoweenie,2017-01-06T18:15:07Z,666,229,18,2,"This updates the locking package to use the new `lfsapi.Client` from the `api-master` branch. As a result, this removes the dependencies on the `api` and `config` packages from `locking`, while adding `lfsapi` of course.",220,False,en,8
1822,32,11,32,Externals,sinbad,2017-01-16T11:32:57Z,1421,159,29,13,"This PR addresses the following locking user story points:

1. We want to avoid accidentally editing unmergeable files which have not been locked first
2. The best way to do that before any changes have been made is to make files read-only in the working copy, suggesting to the user that they shouldn't just edit them
3. Not all LFS files are unmergeable. Therefore we want to identify which file patterns this rule should apply to
4. Locking / unlocking a file should flip the read-only flag locally
5. We need to maintain that read-only flag across other git operations

To this end, this PR adds the following features:

1. Adds a `--lockable` option to `git lfs track`. This enables an additional attribute flag `lockable` which means files matching this pattern will be read-only when not locked.
2. Adds a `post-checkout` hook to make files read-only when checked out if needed
3. Adds a `post-commit` hook which makes added files read-only after they're committed. New files won't have been checked out but the locking rules should apply to them as soon as they enter git; `post-commit` is the event that needs to trigger that transition
4. Adds a `post-merge` hook which checks & fixes the read-only flag, which can be reset during merge (`post-checkout` unfortunately does not get called)

On this basis we can be reasonably confident that files marked as `lockable` will be kept read-only in the working copy unless the user locks them, or overrides this flag themselves.

There are a couple of caveats:

1. Some apps blatantly override read-only flags without asking. Some Apple tools do this. There's not a great deal we can do about this; this feature is mainly an advisory / reminder. Luckily it's not many tools.
2. `git reset <file>` can override the read-only flag and there's no hook to catch it. However, the only reason to use that is to undo edits you've already made, so it's reasonable to assume you'd only have changes to undo if you'd already locked the file. Other `reset` routes involve a ref checkout so are caught by the `post-checkout` hook.

The behaviour can be disabled by setting env var `GIT_LFS_SET_LOCKABLE_READONLY` to false, in case there are environments where you don't want this (e.g. automated scratch copies)

Hope this all makes sense!

NB: This PR targets a new integration branch, `locking-master-2` since I can't fast-forward `locking-master` to `master` because of the review checks on it. I'd be fine with targeting `locking-master` as well if that could be brought forward to latest `master`, I just can't do that as I have no admin access.",2592,True,en,11
1820,3,4,6,Externals,creste,2017-01-12T16:01:09Z,30,0,1,11,"Fixes git-lfs/git-lfs#865.  These are the changes that @marcrossinyol created.  Tested against v1.5.4 on cygwin.  Can't test against master because master doesn't build on cygwin:

```
$ ./script/bootstrap
Installing goversioninfo to embed resources into Windows executables...
Creating the resource.syso version information file...
git-lfs.go:1: running ""goversioninfo"": exec: ""goversioninfo"": executable file not found in %PATH%
```

",436,True,en,0
1818,9,0,0,Internals,ttaylorr,2017-01-05T18:07:55Z,63,38,9,5,"This pull-request brings in some API changes which fixes making locking API requests at the root of the remote, instead of relative to the current repository.

It is currently based off of `master`, and should wait until #1815, #1816 & #1817 have been merged first. Once those three are merged into `master`, I'll rebase this PR off of `master`, and then merge. After this is merged into `master`, I think the changes should be merged back into `api-master`. Another approach we could take is to target this at `api-master`, to simplify some of the merging back and forth. I think it would be preferable to merge this into `master` first, if we cut a release off of master before `api-master` has been finished.

Here's a before and after:

```diff
--- /dev/fd/11  2016-12-30 12:44:03.000000000 -0700
+++ /dev/fd/12  2016-12-30 12:44:03.000000000 -0700
@@ -1 +1 @@
-https://github.com/locks
+https://github.com/owner/repo.git/info/lfs/locks
```

And a summary of what changed:

1. 9c11250...043ee8b: don't use `func (*net/url.URL) ResolveReference)`, allow for relative path joining.
2. eb53d39...2e397a9: add an `Accept` and `Content-Type` header to all API requests made using the `*api.Client` type.
3. d6df15d: ensure that `/repo.git/info/lfs/locks` is a GET request
4. 51c35df...caf632f: some prep-work to make sure the `{assert,refute}_server_lock` helpers have the information they need to make requests at the correct location.
5. ed34d39: update the test server to respond to locking requests at the correct URL 🎉 

---

Before merging, I'd like to teach the gitserver how to store a per-repo cache of locks, instead of maintaining a global one.

---

/cc @git-lfs/core ",1682,True,en,7
1815,17,2,10,Internals,ttaylorr,2017-01-13T23:22:50Z,172,10,5,14,"This pull-request teaches the `pre-push` hook to warn when you are pushing files that you own the lock on, and to error (preventing the push) when you are pushing files that you don't own the lock of.

Here's a breakdown of what happened:

1. 18faf7a...8eb3659: teach the `pre-push` hook to search for locks in range
2. b3707a6...18ec881: implement and use `findLocks` helper to make searching for locks more concise
3. aa21a3d...518aeb8: integration tests for pushing owned and unowned locks
4. f1b2f98: Preemptively use the `--no-verify` flag to avoid calling the `pre-commit` flag introduced in #1816.

Some things that I'd like to take a look at before merging: 

- Should the `pre-push` hook be configurable where to search for locks? It seems that callers should be able to decide between searching the local lock cache, or searching the remote's locks. A flag seems like the wrong approach, since you'd have to update `.git/hooks/pre-push` each time, but a config option seems reasonable.
- Should the `pre-push` hook warn about your own locks? Should this be configurable?
- Should the `commands` package own a singleton, private, instance of a `*locking.Client`?

---

/cc @git-lfs/core ",1196,True,en,2
1814,5,3,0,Internals,ttaylorr,2017-01-05T18:18:54Z,89,9,7,6,"This pull-request backports an internal change made to the various locking commands adding the `--json` flag.

To allow 3rd party tools written in languages that do not interoperate with Go to integrate with LFS , a `--json` flag is used to share a standard encoding format. This allows other programs to shell out to LFS and expect an exact data format in return over stdout.

As a caveat, the `Error()`'d messages are not encoded in JSON. This behavior should be OK, since programs can expect that JSON parse errors should be treated as LFS errors and can treat the contents of stdout as the error message.

---

While working on this PR, I noticed that none of the three locking commands (`locks`, `lock`, and `unlock`) have manpage documentation. Before removing the `GITLFSLOCKSENABLED` environment flag, manpages should be written, and they should include notes about the `--json` flag.

---

/cc @git-lfs/core",916,True,en,3
1812,13,6,0,Internals,ttaylorr,2017-01-11T22:47:45Z,112,143,7,12,"This pull-request teaches the `push` and `pre-push` commands how to use the new `gitscanner` without accumulating potentially large slices of `*lfs.WrappedPointers`.

Previously, in order to push a set of LFS objects to a remote, the pusher needed to have explicit knowledge of all objects they were going to push. In many cases, this isn't a problem, since usually the number of objects is manageable. During initial or large pushes, however, the number of objects to push can grow prohibitively large, causing a problem.

This pull-request applies the work that @technoweenie has done with the `gitscanner` type and applies it to the `push` and `pre-push` commands. Here's a breakdown of what happened:

1. 4d4f808: since the commands will now call `uploadPointers()` more than once, re-use the `*tq.TransferQueue` instance across invocations to prevent needless re-allocation and to take full advantage of batching.
2. 64a643e: since the `uploadPointers()` calls can place objects across multiple batches and thus do not guarantee that all objects in the call have been uploaded, introduce `Await()` to ensure that the `*tq.TransferQueue` is done before exiting LFS.
3. [`a58e91f^1...f1380bd`][1]: teach calling code how to asynchronously call `uploadPointers`.
4. [`028facf^1...430f5a7`][2]: :nail_care:
5. 7af9281: fix small bug in `lfs.NewDownloadCheckQueue` which created `n` empty elements in the options array (where `n` is equal to the length of options provided)
6. 15673a4: since the download check queue is used many times instead of all at once, do some preparation work to make it reusable. In this commit, provide a mechanism for callers to find out about failed transfers so that calling code can accurately determine when all given items have been checked.
7. b169435: Wire-up the download check queue to be reused in `*commands.uploadContext`.

[1]: https://github.com/git-lfs/git-lfs/compare/a58e91f%5E1...f1380bd
[2]: https://github.com/git-lfs/git-lfs/compare/028facf%5E1...430f5a7

---

One thing I'd like to investigate before merging is the use of the download check queue in b169435. Prior to that commit, the queue was re-instantiated each time the scanner reported items. This would be OK if the scanner reported items in small batches, since we'd be able to take advantage of the batching functionality of the `*tq.TransferQueue`, however it does not. What this means is that we have to perform an expensive object allocation (not to mention all of the internal `chan`s, `map`s, etc.) _each time a pointer is read from the gitscanner_.

To mitigate this, I did work in [`15673a4^1...b169435`][3] to avoid this expensive and repeated allocation. However, as a consequence, the download check queue needs to report synchronously whether or not the server has items that are missing locally in `.git/lfs/objects`. What this means is a batch size of 1, so that we're not waiting indefinitely to hear of the status a set of items with cardinality less than the batch size.

[3]: https://github.com/git-lfs/git-lfs/compare/15673a4%5E1...b169435

This may be fine, since I think it's a safe assumption to assume the number of items that needs to go through this check queue `(i.e., the number of objects missing from `.git/lfs/objects` needed to push) is sufficiently small. If not, it may be worth pursuing alternatives that remove the need for single-length batches.

One option we could pursue is using a second transfer queue to keep track of the items that are not present in `.git/lfs/objects`, or using the `*lfs.Batcher` type to batch it ourselves. I'm not sure if this is advantageous or not, since it does carry with it additional complexity. I'd love to hear additional thoughts on this.

---

/cc @git-lfs/core ",3745,True,en,2
1811,1,0,0,Internals,ttaylorr,2016-12-27T22:34:55Z,1,1,1,0,This backports #1810.,21,False,en,1
1810,1,2,0,Internals,ttaylorr,2016-12-27T22:22:19Z,1,1,1,0,"This pull-request removes the sub-package: `github.com/git-lfs/git-lfs/filepathfilter/filepathfilterbench`, which caused builds on Debian 7 & 8 to fail under `dh_golang`.

When trying to build the v1.5.4 release of LFS, `dh_golang` would not successfully preform the `go install -v` of all Go/LFS packages necessary to build LFS. When inspecting a diff of the build log between the v1.5.3 and v1.5.4 tree, I noticed the following line:

```
go build github.com/git-lfs/git-lfs/filepathfilter/filepathfilterbench: no buildable Go source files in /tmp/docker_run/src/github.com/git-lfs/git-lfs/i386/obj-i486-linux-gnu/src/github.com/git-lfs/git-lfs/filepathfilter/filepathfilterbench
```

`go build` exits in a dirty state after trying to build a path with no source files in it, as is the case with the `filepathfilterbench` sub-package.

As a short-term solution, I am moving the `bench_test.go` file into the parent package, `filepathfilter`. This follows standard Go testing conventions, and will allow us to build LFS using `dh_golang` again. As a precautionary measure, I moved the file into the `filepathfilter_test` pseudo-package so that this change will not affect the public API, nor will it make importing `filepathfilter` any heavier.

```diff
--- a/filepathfilter/filepathfilterbench/bench_test.go
+++ b/filepathfilter/bench_test.go
@@ -1,4 +1,4 @@
-package filepathfilterbench
+package filepathfilter_test
```

Looking at a long-term solution, I'd like to:

1. Figure out why this problem doesn't occur on Centos builds, and
2. Submit a patch upstream to `dh_golang` to skip building import paths with no build-able source files.

---

/cc @git-lfs/core ",1667,True,en,1
1809,1,0,0,Internals,ttaylorr,2016-12-27T20:33:44Z,22,4,6,0,cc @git-lfs/core ,17,False,en,0
1807,1,0,0,Internals,ttaylorr,2016-12-27T20:11:45Z,37,27,2,0,This backports #1806.,21,False,en,0
1806,3,1,0,Internals,ttaylorr,2016-12-27T20:00:17Z,37,27,2,0,"This pull-request prevents the `len(padding)` used in the progress meter from ever being less than zero. This prevents the panic from `strings.Repeat` trying to [allocate a slice][1] with a [`len < 0`][2] as seen in #1803.

Previously, LFS printed a number of number of padding characters to the terminal when displaying progress meter updates, so that the terminal's cursor would be in the correct position to fill the entire line after printing the CR character, `\r`, as such:

```
       |-----------------------padding---------------------|
message                                                    
                                                           ^- cursor position
```

However, if the message's length is greater than the terminal width, `width-len(str)` is a negative number, causing the panic as shown above. This check with `tools.MaxInt(0, width-len(str))` prevents that from happening by forcing the padding to be an empty string.

This is a safe change, since we'll be outside of the terminal's assumed width, leaving the cursor in an OK position to rewrite the entire line. This would leave a remaining number of characters trailing off the line, but this only happens when the `ts` library can't accurately determine the tty's width, and we default back to 80. 

---

/cc @git-lfs/core #1803

[1]: https://github.com/golang/go/blob/go1.7.3/src/strings/strings.go#L420
[2]: https://github.com/golang/go/blob/go1.7.3/src/runtime/slice.go#L47-L50",1471,True,en,0
1805,1,0,0,Internals,ttaylorr,2016-12-27T20:04:59Z,183,89,7,0,"This backports #1796.

Conflicting files:
- commands/command_filter_process.go
- commands/command_smudge.go",107,True,en,3
1801,2,2,0,Internals,ttaylorr,2017-01-05T18:23:04Z,11,0,1,9,"See: https://github.com/git-lfs/git-lfs/pull/1782#issuecomment-267678319.

---",78,True,en,1
1799,4,0,1,Internals,technoweenie,2017-01-03T18:23:41Z,300,213,4,11,"This fixes some issues with the new API auth code:

1. Clarify and describe in comments the difference between a request URL, api endpoint URL, and the git remote URL. Using the credsURL for check and set the lfs endpoint access was causing endless loops.
2. Strip URL auth when building the `lfs.URL.access` git config key.
3. Better tests.",341,True,en,2
1798,1,0,0,Internals,ttaylorr,2016-12-26T23:02:27Z,1,0,1,3,This backports #1797.,21,False,en,0
1797,1,0,0,Internals,ttaylorr,2016-12-23T18:14:08Z,1,0,1,0,"This pull-request adds `fedora/25` to our list of targets for Packagecloud, which will make all future builds available on the latest release of Fedora.

In addition to this, I re-built and released Git LFS v1.5.3 under the `centos_7` Docker image, and pushed that release out to just the Fedora 25 target.

---

/cc @git-lfs/core https://github.com/git-lfs/git-lfs/issues/1795",377,True,en,0
1796,10,4,2,Internals,ttaylorr,2016-12-26T23:02:03Z,155,66,7,4,"This pull-request fixes #1729 by streaming out the entire contents of a malformed pointer, instead of truncating the first 1024 bytes.

Previously, if LFS was unable to parse file that it thought was a pointer, it would ""smudge"" the file by just emitting it as is. The catch, however, was that the only data that it could hold onto was the first 1024 bytes. Since `(*git.PktlineReader) Read()`s block if there is no data on the pipe, buffering a fixed amount of data was the best that we could do. There were two cases:

1. `len(pbuf) < 1024`: We received the entire contents, no join necessary.
2. `len(pbuf) == 1024`: We _might_ have received the entire contents, or there were more than 1024 bytes and we just read the first 1024 of them. 

To handle this better, I introduced `lfs.DecodePointerHasMore` which mimics `lfs.DecodePointer`, but returns an additional `bool`, dictating whether or not more data is available to be read (in other words, where the `(*git.PktlineReader) Read()` error was `== io.EOF` or not). When using this in the `commands` package, we just check if there was `more` data, and join the reader as necessary:

```go
var r io.Reader = bytes.NewBuffer(pbuf)
if more {
        r = io.MultiReader(r, src)
}
```

As an added bonus, I added some warning messages that get printed to `os.Stderr` and include the filenames of all malformed pointers. When using `filter.lfs.process`, the files are collected together and printed once at the end. When using the `filter.lfs.clean` mode, we print out an error once per file, instead of bundling them up. Short of storing the list on disk in `.git/`, this is the best that we can do.

To wrap things up, I audited all uses of `lfs.DecodePointer`, `lfs.DecodeFromFile`, et. al., and determined that there were no other instances in the code where we would only output partially buffered data.

Hooray!

---

Here's a quick break-down of what was done:

1. cfcba6f: Introduce `lfs.DecodePointerHasMore` and use it in `commands.smudge()` to determine when to correctly join and copy the readers.
2. b3bab24: Keep track of the malformed pointers seen in a given pull/checkout/clone and emit them at the end (or once per file, if we're using `filter.lfs.clean` instead of the process filter).

---

/cc @git-lfs/core #1729 ",2286,True,en,3
1794,10,1,0,Internals,technoweenie,2017-01-03T18:28:02Z,697,3,7,13,"This attempts to port over the tracing code from `httputil`. The main change is relying no tracing/debugging flags on `*lfsapi.Client` instead of a global `*config.Configuration`.

TODO

* [x] Tests
* [x] HTTP Request Stats",223,True,en,2
1793,1,0,0,Internals,technoweenie,2016-12-21T17:25:33Z,6,4,1,0,"Implements the suggestion in #1792, using `pushd` and `popd` so the user's `pwd` doesn't change after running the command.",122,False,en,0
1791,3,2,12,Internals,technoweenie,2016-12-21T17:32:14Z,248,89,5,0,,0,False,en,2
1788,2,0,0,Internals,technoweenie,2016-12-20T21:40:48Z,63,7,4,0,Ensures body is rewound if an auth request is retried.,54,False,en,1
1787,8,0,0,Internals,technoweenie,2016-12-20T21:52:44Z,986,92,16,0,"Adds support for custom ssl certs, http proxies, and timeouts.",62,False,en,5
1784,5,0,0,Internals,technoweenie,2016-12-20T19:21:43Z,966,7,10,0,Introduce `DoWithAuth(*http.Request)` with credential helpers and netrc.,72,False,en,3
1782,2,4,0,Internals,technoweenie,2016-12-26T23:02:19Z,515,328,12,10,"This backports the `filepathfilter` package, which should improve `git lfs track` times. /cc #1750",98,False,en,3
1780,50,1,0,Internals,technoweenie,2016-12-16T17:28:11Z,1411,1023,32,0,"* tq: prioritize transferring retries before new items #1758
* Manifest config attempt 2 #1767
* tq: simplify usage of `tq.Transfer` #1772
* Change Adapter Begin() signature to accept an AdapterConfig interface #1774
* teach the smudge filter how to use the transfer queue directly #1775
* tq: un-export `NewTransfer` and `Batch` #1777",335,False,en,12
1779,1,0,0,Internals,ttaylorr,2016-12-16T16:44:06Z,4,3,2,0,"This pull-request makes more clear that object sizes sent to and returned from the server must be positive.

This information was originally added in https://github.com/git-lfs/git-lfs/pull/1371, but only changed the legacy and v1 schemas, which were removed as of https://github.com/git-lfs/git-lfs/pull/1641. Now they're back :-)

---

/cc @git-lfs/core #1778",361,True,en,0
1777,2,1,0,Internals,ttaylorr,2016-12-15T21:24:10Z,11,16,2,0,"This pull-request un-exports two identifiers, `tq.NewTransfer` and `tq.Batch`, since they are not needed in the public API.

Since we got un-exported `tq.NewTransfer`, this removes the last public use of the `api` package in `tq`, meaning callers don't need to depend on `api` directly to use `tq`.

---

/cc @git-lfs/core ",323,True,en,0
1776,3,1,2,Internals,ttaylorr,2016-12-15T21:26:47Z,96,91,7,0,"This pull-request moves the `lfs.NewDownloadable` and `lfs.NewUploadable` functions into the `commands` package and un-exports them.

As an aside, the `NewUploadable` alternative had to be copied into the `test` package, since it was inaccessible as a private member of the `commands` package. I think this follows the Go-ism: ""A little copy is better than a little dependency.""

---

/cc @git-lfs/core ",403,True,en,0
1775,1,0,0,Internals,technoweenie,2016-12-15T17:37:03Z,13,27,1,0,This removes the only public usage of `tq.NewTransfer()`. That `multiErr` stuff should be pulled into some package....,118,False,en,0
1774,2,0,0,Internals,technoweenie,2016-12-15T18:39:22Z,19,17,6,0,"This implements my [suggested change](https://github.com/git-lfs/git-lfs/issues/1764#issuecomment-266901659) of the adapter `Begin()` interface, to accept a configuration object interface, instead of a `maxConcurrency int` argument. This gives us flexibility to add more properties if needed without breaking the public interface. If we decided to add something like `MaxSchmeckles() int`, adapters would keep working without ever having to deal with schmeckles if they don't need to.

The PR is currently based on #1772, which is about to merge. Once merged, the base will change to `tq-master`.",596,True,en,2
1772,5,1,0,Internals,ttaylorr,2016-12-15T17:35:42Z,326,263,14,0,"This pull-request simplifies the `tq.Transfer` type, and removes the usage of the mutable `Transferable` interface. Additionally, it enables us to remove `*api.ObjectResource` from the `tq`'s exported API.

Previously, we used three main types:

1. `Transferable` - an `interface{}` to cover downloadable and uploadable LFS pointers.
2. `*api.ObjectResource` - A type to hold values from the API.
3. `*transfer.Transfer` - A combination of `Transferable()` and `*api.ObjectResource`. Used in adapter implementations to grab values both from the API, and values pertaining to the local repository.

The bummer is that the `Transferable` is cached in a `map[string]Transferable` on the `*TransferQueue` for the _entire transfer_, which can incur some pretty high memory consumption. unsafe.Sizeof suggests that the we're storing much more than [56 bytes][1] per Transfer, not including the size of the inner-structs. My calculations estimate about **~128bytes per object** (for two actions (32 bytes/action), 4 bytes for the pointer), and no error).

To simplify, let's store the API data when we need it, and ignore it when we don't. For a local cache, all we need is the Name, Path, Oid and Size, which compacts to [56 bytes][2] as a maximum (we can remove 16 bytes/transfer by dropping the `Name` field). This is, on average, __68.7% less memory consumption per unique Transfer__.

In addition, the code gets simpler, since we only need to care about the objects retuned back from the API when we're sending them to the adapters.

On top of all of that, we got rid of the mutability in `SetObject()`, narrowed down our internal use of the `*api.ObjectResource` type, and only have _one remaining external use of the `api` package in `tq`._

---

Since this PR is on the larger side, here are the important groups of commits:

1. e18044f: remove `Transferable` interface 
2. 7f26137: simplify `(q *TransferQueue) Add()` signature.
3. 94b2d0d...5fc2344: various 💅 and 🍬 to clean things up

---

/cc @git-lfs/core 

[1]: http://golang-sizeof.tips/?t=Ly8gU2FtcGxlIGNvZGUKc3RydWN0IHsKCU9pZCAgICAgICAgICAgc3RyaW5nCglTaXplICAgICAgICAgIGludDY0CglBdXRoZW50aWNhdGVkIGJvb2wKCUFjdGlvbnMgICAgICAgbWFwW3N0cmluZ10qc3RydWN0ewoJICAgIEhyZWYgc3RyaW5nCgkgICAgSGVhZGVyIG1hcFtzdHJpbmddc3RyaW5nCgkgICAgRXhwaXJlc0F0IHRpbWUuVGltZQoJfQoJTGlua3MgICAgICAgICBtYXBbc3RyaW5nXSpzdHJ1Y3R7CgkgICAgSHJlZiBzdHJpbmcKCSAgICBIZWFkZXIgbWFwW3N0cmluZ11zdHJpbmcKCSAgICBFeHBpcmVzQXQgdGltZS5UaW1lCgl9CglFcnJvciAgICAgICAgICpzdHJ1Y3R7CgkgICAgTWVzc2FnZSBzdHJpbmcKCSAgICBDb2RlIGludAoJfQp9Cg==
[2]: http://golang-sizeof.tips/?t=Ly8gU2FtcGxlIGNvZGUKc3RydWN0IHsKICAgIE5hbWUsIFBhdGgsIE9pZCBzdHJpbmcKICAgIFNpemUgaW50NjQKfQo=",2677,True,en,1
1771,14,2,0,Internals,technoweenie,2016-12-16T17:45:41Z,344,288,9,1,"Finally removed our first `[]*lfs.WrappedPointer` :metal:

* Removes the callback arg on `(*GitScanner) ScanTree(ref)`. Everything was simply passing `nil` to it. 62d0b51ada64411e0045d49c0865ef3c17dcad2e
* Rewrote `lfs.ConvertCwdFilesRelativeToRepo()` and `lfs.ConvertRepoFilesRelativeToCwd()` from functions working with channels, to a couple structs that implement a `PathConverter` interface. 68efd0536a2eb3e0514ee4d2da7ab9c7a084fcb8
* Extracted a `*gitIndexer` type to handle all the `git update-index` stuff. 5ef6b8a1bda07212b97133f2a7794cd6cbfa8283
* Extract a shared `checkout()` func that the `pull` and `checkout` commands can share. 0d5d391f92d5146ba90f8d7cbcd7852279275232
* Removed a reliance on `[]*lfs.WrappedPointer` in the `checkout` command 08dd0309b2aab31663cb6e62b75828ca622a086f
* Moved existing checkout code that still needs `[]*lfs.WrappedPointer` to the pull cmd. It's the only other spot that uses it now, and is next on my list.",954,True,en,0
1770,15,0,3,Internals,technoweenie,2016-12-19T20:00:13Z,700,573,12,5,Experiment in extracting the endpoint and url alias stuff from `config` to a new `endpoint` package. I'm starting to think it belongs in `api` instead though.,158,False,en,4
1769,40,2,0,Externals,sinbad,2016-12-16T17:08:59Z,1090,174,15,2,"This simply aggregates the following PRs:

- #1694 key value store
- #1723 introduce locking package
- #1736 config usage
- #1760 lock cache

This is a stable midpoint so is safe for `master`; `locking-master` will continue afterwards with further review-friendly staging PRs on locking until more is ready for prime-time.",322,True,en,5
1768,1,0,0,Externals,sinbad,2016-12-14T16:05:24Z,2,0,1,0,"Related: #1750 

Just a tiny PR to add tests for set support in filter e.g. `[Dd]ebug`. This is supported by .gitignore even though it's not very explicit in the git docs. I thought it might be an explanation for the issue above but it wasn't, this test just proves that.",271,True,en,1
1767,11,2,0,Internals,technoweenie,2016-12-14T17:06:26Z,177,107,15,0,"This is a slightly different approach to #1766. Instead of introducing a new `tq.WithGitEnv()` option, this assumes that the caller will configure the `*tq.Manifest`, which is now a required argument for `NewTransferQueue()`. I was able to remove all `config` references inside the `tq` package except for the internal uses (which is tied to internal api methods still using it). Nothing in the exported interface uses `config` anymore though.

I like this approach, it gets us closer to @sinbad's idea of a config object per package. Could even rename `*tq.Manifest` to `*tq.Config` if you think that'd make more sense.

Notes:

* <del>Had to export `BasicTransfersOnly` and `TusTransfersAllowed` allowed, because `Unmarshal()` can only set exported properties. I'd rather not export these though.</del> -- not the case, see below
* Discovered that I dropped the dry run setting from `NewDownloadCheckQueue` in https://github.com/git-lfs/git-lfs/pull/1746/files#diff-1b73a9b301d9b5f76392f5818dd2ab15L43, it was re-added.
* Dropped the `ConcurrentTransfers()` call too.",1069,True,en,4
1760,11,1,23,Externals,sinbad,2016-12-14T10:02:36Z,442,61,10,1,"The next incremental rewrite of the locking work; this time we're using our key value store to locally cache locks for the current user for more efficient access. This will be used in the next PR to provide efficient support for marking files read-only on checkout if not locked.

Also adds some minor API improvements such as returning a full `Lock` structure on acquiring a lock rather than just an Id.",404,True,en,4
1758,18,5,14,Internals,ttaylorr,2016-12-13T01:06:53Z,859,592,27,0,"This pull-request implements priority retries, and moves `TransferQueue`-related code into a new package, `tq`, as discussed in #1651.

## Why?

In an effort to better support transferring large numbers of objects through the `*tq.TransferQueue`, we need to buffer less data than we currently do. One way to do this is to process retries up front, instead of keeping data in memory about failed objects around until the end of the transfer. Normally, this isn't a huge problem, but if the transfer queue fails half a million objects, we can't afford to keep that in memory.

## What?

This pull request brings a number of benefits to the `*TransferQueue` type:

1. **Back-pressure**. If the `*TransferQueue` can't accept more items, there's no sense in wasting a large amount of disk and CPU usage scanning the Git data. Previously, instances of `git rev-list`, `git cat-file` and `git cat-file --batch` would run ad nauseam even if the `TransferQueue` couldn't accept new items. Now, `Add()` will block after a maximum buffer depth has been reached. In other words, by default, `Add()` will accept 200 (twice the default batch size of 100) items before apply back-pressure up to the `gitscanner`, causing it to wait. 
2. **Support for many objects**: Right now, we keep a large amount of data in memory per each object retry. Before https://github.com/git-lfs/git-lfs/pull/1535, that data was kept around until the very end of the transfer and then retried all at once. That got better after that PR was merged, but at the cost of many more API calls. This PR encompasses the best of both worlds: by retrying objects closer to when they were initially `Add()`-ed, data about that object can be kept in memory for less time. By treating retries as part of the next batch and prioritizing them, we make less API calls.
3. **Less API calls**. As of https://github.com/git-lfs/git-lfs/pull/1535, we make an API call (about) _once per object retry_. Normally this isn't such a huge problem, but if many objects fail, we'll be making a proportional number of expensive API calls. Not cool. This pull-request, by prioritizing object retries before accepting new items cuts the number of batch API calls by the size of a batch (100, by default). Much better.

## Inner-workings

This pull-request fundamentally changes the way that we process batches and retries in the transfer queue. Here's a breakdown of what goes on:

1. Start with an empty batch.
2. Until the batch is full OR the `<-q.incoming` channel is closed, append from `Add()` via `<-q.incoming` items into the batch.
3. Make a batch API request, and send the results to the transfer adapters.
4. Clear the batch.
5. Collect the failed items into the next batch.
6. If the `<-q.incoming` channel is closed AND the next batch is empty, exit.
7. Otherwise, go to step 2. 

This requires us to change how the `*tq.adapterBase` (previously `*transfer.adapterBase`) type is implemented. The changes can be summarized by the signature change. What used to be:

```go
func (a *adapterBase) Add(t *Transfer)
```

is now:

```go
func (a *adapterBase) Add(ts ...*Transfer) (results <-chan TransferResult)
```

by synchronizing the results with a batch of `*Transfer` items, we can deterministically pre-fill the next batch with failed items from the last one.

This change comes at a cost, which is that in order to know when to `close()` the `results` channel, we must wait for all of the transfer adapters to finish their in-progress tasks. This effect will be un-noticeable if the items in a transfer set are of uniform size, but is more pronounced when items with wildly different sizes are processed in a random order with a poor network connection.

To combat this, items in a batch are sorted in descending object size to minimize the chance that a worker will get tied up on a large object as the last item in a batch. This change, implemented in 6decfe4 should make this a non-issue.

---

Since this PR is a on the bigger side, here's a convenient break-down of the changes:

1. 453d02a: Introduce `batchSize` instance variable (and `OptionFn`) to allow configuring the batch size.
2. bdcacb0: Implement priority retries.
3. 6decfe4: Sort batches by descending object size to minimize chance of idle workers.
4. d0c4ccd...55275ca: Move `lfs/transfer_queue.go` and `transfer` package into new package, `tq`.
5. 70f1479...8c94383: Rename various exported methods/types in `tq` package to avoid [stuttering][1].

[1]: https://blog.golang.org/package-names#TOC_3.

---

/cc @git-lfs/core ",4541,True,en,8
1754,1,0,0,Internals,ttaylorr,2016-12-10T17:24:41Z,1,1,1,0,"This pull-request suppresses the progress output that cURL generates at the end of running the integration suite, which can get rather annoying :-).

I intentionally didn't apply the `-s` flag to other `curl` invocations in the `testhelpers` file, since I think that output is useful when going through failure logs.

---

/cc @git-lfs/core ",341,True,en,1
1752,4,8,10,Externals,sschuberth,2016-12-15T21:04:56Z,57,43,9,6,"On Windows, this makes the detailed file properties dialog show the file
version and copyright information also for the Windows installer
executable. Previously only the git-lfs executables had this information.",211,False,en,0
1747,17,1,14,Internals,technoweenie,2016-12-09T14:54:13Z,169,102,13,2,"This adds `(*progress.ProgressMeter) AddEstimate(size int64)`, which lets us build up the estimated files and total bytes to transfer a file at a time. This is the first step towards relieving us of the requirement that we need to gather all the pointers in a `[]*lfs.WrappedPointer` before any transfers can _start_.

This also changes the transfer queue constructors: `lfs.NewUploadQueue()`, `lfs.NewDownloadQueue()`, and `lfs.NewDownloadCheckQueue()` to accept the minimum args: a `*progress.ProgressMeter` and `dryrun bool`. I didn't like these args, so I tried #1746 as an experiment.",589,True,en,0
1746,3,1,3,Internals,technoweenie,2016-12-07T20:13:29Z,89,70,10,0,"This replaces the argument list in the transfer queue constructors with a variadic option func arg. Both `meter` and `dryRun` are technically optional. Also, the `*TransferQueue` has that `run()` that's required.

This was mostly an experiment. I'm now thinking that `newTransferQueue(dir transfer.Direction)` is all we need if `tq.Run()` is called after the first `tq.Add(...)`. Then you wouldn't need optional args in any fashion:

```go
tq := newTransferQueue(transfer.Download)
// defaults to false
tq.DryRun = true
// defaults to progress.Noop()
tq.Meter = progress.NewMeter(""..."")
```",590,True,en,0
1745,3,1,2,Internals,technoweenie,2016-12-07T02:24:18Z,75,76,7,0,"This removes the inline filepathfilter checking from the `commands`, relying on the gitscanner to do it. ",105,False,en,1
1743,11,0,0,Internals,technoweenie,2016-12-06T23:13:58Z,525,362,18,0,"Merged #1725 into `fast-walk-no-channels`, which was already merged. This PR merges a10f90926e24045c6538055085bfe530a4bc7aa8 into master. See #1725 for prior discussion.",169,False,en,2
1742,3,0,2,Internals,ttaylorr,2016-12-07T20:35:35Z,218,0,2,0,"This pull-request implements the `*tq.WorkerQueue` type, responsible for distributing work among an available set of workers.

## What

Functionally, this type is very similar to the existing [`*transfer.adapterBase`][1] type, but I chose to re-implement in this new package for a few reasons:

1. **Model of execution**. This implementation has slightly different conditions for deciding when workers are available, and when new work can be assigned to the queue. Since this is an ""all or nothing"" scenario, where these execution changes have to be implemented atomically, I figured it'd be easier to start with something similar and port over functionality as necessary.
2. **New package**. This is going in a new package, `tq`, so at the very least I'd be duplicating the `transfer.adapterBase` type as `tq.adapterBase` and making changes there. I figure there won't be a huge difference in time spent whether I port over functionality up front or as needed. My immediate next step is going to be to make the existing interface and functionality from the `transfer` package work in the new `tq` package, so we should know pretty soon whether or not there are major flaws.

## How

This `*tq.WorkerQueue` has design invariants that make it easy to satisfy our goals for new work done in the `*tq.TransferQueue`. One of those goals is prioritizing retries to happen immediately to avoid a large amount of buffering, and in order for that to happen, we need to know about retries as soon as possible. 

This queue reports ""failed"" items that need to be retried through the retry channel that it returns in response to an `Add()` call:

```go
func (q *WorkerQueue) Add(batch []string) (retries <-chan string) { ... }
```

Callers of this method (namely, the `*tq.TransferQueue`) can read items from this channel until it closes and prioritize those items in the next batch of items. In fact, this is exactly what the new transfer queue will do, in a pull-request that I'll push shortly.

One downside of this method is that we have to wait for work to _completely_ finish in a batch before accumulating the next one. Right now, I'm not convinced that this is yet a showstopper, but just something that we need to keep our 👀  on. Implementing this new transfer queue in a new package will allow us to have clear boundaries of functional types that we can change in isolation should this behavior become prohibitive to operation. 

## Misc

Following @sinbad's lead, I've based this PR off of `tq-master`, the de-facto ""master"" branch for the transfer queue refactorings. This means I can avoid the nasty PR chain that was the filter-process project, while still making these fairly short/easy to review.

Once the project is done, we'll fast-forward master to include all the changes from `tq-master`.

---

/cc @git-lfs/core  

[1]: https://github.com/git-lfs/git-lfs/blob/7ffac54d7662d0ca3f919ec68d481d604970cea7/transfer/adapterbase.go",2939,True,en,1
1741,1,0,0,Internals,ttaylorr,2016-12-06T00:21:02Z,6,1,2,0,This backports #1734.,21,False,en,0
1739,1,0,0,Internals,ttaylorr,2016-12-05T23:40:28Z,18,4,6,0,@technoweenie,13,False,pl,0
1738,1,0,0,Internals,technoweenie,2016-12-05T21:21:35Z,5,5,1,0,This backports #1737.,21,False,en,0
1737,1,0,0,Internals,technoweenie,2016-12-05T20:30:38Z,5,5,1,0,"The `url.Parse()` func on go 1.8 fails to handle ssh remotes like `git@foo.com:user/path.git`. Instead of returning a `*url.URL` where the `Path` property is the entire raw url, it now returns an error: ""first path segment in URL cannot contain colon"".

This now attempts to parse the bare ssh url in case `url.Parse` returns a URL, working on both go1.8 and go.1.7.",366,True,en,0
1736,7,1,17,Externals,sinbad,2016-12-08T14:18:42Z,142,124,9,3,"Next incremental PR for bringing locking work back:

- Introduce `locking.Client` as primary facade (with state)
- Explicit use of `Configuration` instance not global config
- Change remaining `api` package functions to use passed in `Configuration` instance directly instead of global `config.Config` (except v1 api since that will be phased out)
- Promotes `CurrentCommitter` to `Configuration` and just keeps JSON packaging in `api`

Seemed like a good place to stop & submit since this is going into `locking-master` only. Cache refactor will use this new encapsulated `Client` instead of statics.",601,True,en,1
1734,3,1,0,Internals,ttaylorr,2016-12-05T21:55:08Z,6,1,2,3,"This pull-request uses Go 1.7.4 on all of our build services. Go 1.7.4 matches what we ship with (after bumping the build dockers) and contains security fixes over 1.7.3.

- **TravisCI**: Bumped version.
- **CircleCI**: Uses latest version from Homebrew, already upgraded.
- **AppVeyor**: Doesn't ship their workers with 1.7.4 yet, working on installing it ourselves.

---

/cc @technoweenie ",392,True,en,0
1733,2,0,0,Internals,ttaylorr,2016-12-05T21:35:19Z,3,2,2,3,This backports #1731.,21,False,en,1
1732,2,0,0,Internals,ttaylorr,2016-12-05T21:54:51Z,88,5,6,3,This backports #1727.,21,False,en,2
1731,1,1,0,Externals,larsxschneider,2016-12-02T15:52:35Z,3,2,2,0,"A filter process key-value pair must be split at the first '=' character
into into at most two substrings. The value *can* contain a '='
character. The key *must never* contain a '=' character.

Should fix https://github.com/git-lfs/git-lfs/issues/1730",252,False,en,1
1727,2,0,0,Internals,technoweenie,2016-12-02T15:52:29Z,88,5,6,1,"Fixes #1717 by splitting `localstorage.ResolveDirs()` so that `install` and `uninstall` can do what they need if `lfs.InRepo()` is true.  This is meant to be a bug fix, and definitely doesn't try to fix any package design issues.  I want to backport this PR to v1.5.3, and explore a redesign of this code for 2.x.",313,False,en,2
1725,10,2,16,Internals,technoweenie,2016-12-06T16:25:56Z,525,362,18,6,"This changes the `gitscanner` API to use callbacks, instead of returning a `PointerChannelWrapper`. See [the fsck command](https://github.com/git-lfs/git-lfs/compare/fast-walk-no-channels...gitscanner-callbacks?expand=1#diff-3b7fa953c43592e4af73f324813e6c2fR35) for an _ideal_ usage of it:

```go
gitscanner := lfs.NewGitScanner(func(p *lfs.WrappedPointer, err error) {
  // handle pointers or scan errors
})

if err := gitscanner.ScanRefWithDeleted(ref.Sha, nil); err != nil {
  // handle cmd error
}

gitscanner.Close()
```

You can now pass a callback to `NewGitScanner()` for all the `.Scan*()` funcs, or pass a callback to individual functions if you want those pointers to be handled differently.

Unfortunately, this introduces some ugly code in the core push/pull/checkout related commands. A lot of code still expects to receive a `[]*lfs.WrappedPointer` after the scan has completed. This cleanup will have to happen in future PRs. The main blockers are the progress meter and transfer queues need to accept a stream of pointers.

My hunch is that the transfer queue is all ready setup for this, but our _use_ of it prefers receiving a `[]*lfs.WrappedPointer`. However, the progress meter definitely expects to receive the total number and size of the pointers up front. Since this process is becoming async, updating the progress meter stuff is my next target.",1371,True,en,2
1723,4,1,0,Externals,sinbad,2016-11-30T10:16:17Z,284,134,6,1,"Re-implementation of #1625. Based on PR feedback (except config changes which are still pending). Channel wrappers are gone & so is much of complexity, simpler for clients (and added local `Lock` struct so remove dependency on `api.Lock`). 

Merge target is `locking-master` to denote that this isn't a finished API yet but to enable reviewing in bite-size chunks.
",365,True,en,0
1721,1,0,0,Externals,myint,2016-11-28T16:19:46Z,1,1,1,1,,0,False,en,0
1713,1,0,0,Internals,benbalter,2016-11-23T17:56:03Z,1,1,1,0,"This is a quick fix to get license detection working while it's fixed upstream.

The underlying copyright regex [assumes there's a copyright date](https://github.com/benbalter/licensee/blob/master/lib/licensee/matchers/copyright_matcher.rb#L8), the year field being present in the original license template.

This PR simply adds the year, so that the license matches the regex. See http://ben.balter.com/2015/06/03/copyright-notices-for-websites-and-open-source-projects/ for background on why that is the ""proper"" copyright notice (although this change should have no legal significance). ",590,True,en,0
1712,1,2,0,Internals,benbalter,2016-11-23T17:06:32Z,1,1,1,0,"This PR removes the ""This project is licensed under the MIT license"" line from the license, and replaces it with just the license title (which itself, is optional).

This will allow GitHub to properly detect the license, because right now it doesn't know what that extra line of custom text means, or if it has any legal implications (and thus doesn't call the license MIT).

/cc @technoweenie ",394,True,en,0
1711,3,1,0,Externals,larsxschneider,2016-11-23T17:10:46Z,2,2,2,0,"Apparently the process-filter does not work with Go below version 1.7
cf. https://github.com/git-lfs/git-lfs/pull/1699#issuecomment-262303880",141,False,en,0
1710,8,7,1,Internals,technoweenie,2016-12-05T22:15:54Z,126,92,4,12,"This is an exploration of a new `FastWalkGitRepo` api that accepts a function callback, instead of returning channels. I've been thinking about the `gitscanner` public interface for a few weeks, and I keep coming back to the fact that we should not be exposing channels to end users (even if _we_ are the end users too). I picked `FastWalkGitRepo()` as a guinea pig, since it's much simpler. 

The `commands/command_track.go` changes look much better to me. The new version is focused on what the command needs, and not reading channels concurrently.

I wrote this as a parallel implementation so I could compare the benchmark side by side, and don't see a big difference:

```
$ script/test tools -v -run Bench -bench . -count 5
BenchmarkFastWalkGitRepoChannels-8   	       1	3059166517 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:79: files: 20008, errors: 0
BenchmarkFastWalkGitRepoChannels-8   	       1	3052510253 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:79: files: 20008, errors: 0
BenchmarkFastWalkGitRepoChannels-8   	       1	2763236760 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:79: files: 20008, errors: 0
BenchmarkFastWalkGitRepoChannels-8   	       1	2656352784 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:79: files: 20008, errors: 0
BenchmarkFastWalkGitRepoChannels-8   	       1	2676479922 ns/op
--- BENCH: BenchmarkFastWalkGitRepoChannels-8
	filetools_test.go:79: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2679861166 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:102: files: 20007, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2744682179 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:102: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2691585917 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:102: files: 20008, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2903895731 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:102: files: 20007, errors: 0
BenchmarkFastWalkGitRepoCallback-8   	       1	2701274878 ns/op
--- BENCH: BenchmarkFastWalkGitRepoCallback-8
	filetools_test.go:102: files: 20008, errors: 0
PASS
ok  	github.com/git-lfs/git-lfs/tools	27.942s
```

If you all agree this is a favorable change, I'll remove all the old code, and start on a change to the `gitscanner` like this:

```go
// pseudo code, I haven't exactly looked all these funcs up
tq := newBatchTransferQueue()

// non blocking!
scanner := gitscanner.New(func(p *lfs.WrappedPointer, err error) {
  // queue up to download this object
  tq.Add(p)
})
scanner.RemoteForPush(""origin"")

// not implemented yet, but would add file path inc/exc filtering to all applicable scans
scanner.Filter = filepathfilter.New(inc, exc)

for _, ref := range pushRefs {
    // blocking call until `rev-list` is done
    // then calls callback given to New()
    scanner.ScanLeftToRemote(ref)
}

// any internal channel clean up, make sure all callbacks have been called
scanner.Close()
```",3144,True,en,2
1709,1,0,3,Internals,ttaylorr,2016-11-22T23:01:41Z,26,4,6,0,cc @technoweenie @larsxschneider @rubyist ,42,False,de,0
1708,2,0,0,Internals,ttaylorr,2016-11-22T21:18:33Z,21,15,3,0,This backports #1699.,21,False,en,2
1707,1,0,0,Internals,ttaylorr,2016-11-22T20:47:44Z,1,3,1,0,This backports #1698.,21,False,en,0
1706,1,0,0,Internals,technoweenie,2016-11-22T20:26:33Z,10,415,9,0,This backports #1703.,21,False,en,1
1705,17,3,0,Internals,technoweenie,2016-11-22T21:40:52Z,427,156,50,0,"Attempting a fix to #1690 for v1.5.x only. I assume that Go 1.8 (which includes this fix in the stdlib) will be out by the time LFS 2.0 is out.

I'm having some problems getting the [failing test](https://github.com/git-lfs/git-lfs/compare/release-1.5...fix-windows-long-paths-test?expand=1) to work (details at https://github.com/git-lfs/git-lfs/issues/1690#issuecomment-262324701). I'd really like to confirm a failing test before these fixes are applied, so that a passing test in this PR proves it actually worked.",518,True,en,11
1703,1,0,0,Internals,technoweenie,2016-11-22T20:10:33Z,10,415,9,0,"This removes the unused `contentaddressable` dependency. Also, updated `glide.yaml` so that it gets a specific `pkg/errors` version. The `errors` package update broke some tests. That should be done in a separate PR.

Glide also decided to bump the commit shas for some internal testify dependencies. They're not in `glide.yaml`, and are unused. They're just along for the ride with testify.",391,True,en,1
1699,6,7,2,Externals,larsxschneider,2016-11-22T20:18:14Z,21,15,3,0,c.f. https://github.com/git-lfs/git-lfs/issues/1697,51,False,en,2
1698,2,1,0,Externals,larsxschneider,2016-11-22T17:58:34Z,1,3,1,0,This fixes the error reporting for https://github.com/git-lfs/git-lfs/issues/1697,81,False,en,0
1696,26,5,1,Internals,technoweenie,2016-11-22T21:49:36Z,494,724,27,1,"This is an exploration of what a `filepathfilter` package could look like. Some benefits:

1. `*logScanner` only has to pass a single value around. It no longer needs to be bound to the internal `tools` package.
2. The `*logScanner` constructor only takes 2 args now. The filter is an optional thing to set. The default filter `nil` is just fine.
3. An immutable `filepathfilter.Filter` gives us a place to optimize repeated calls. More below.
4. A bit pie-in-the-sky, but we could depend on a small interface that's just `Allows(string) bool`, in case there are other filter implementations we may want. Doubt it though :)

`tools.FileMatch()` works well, and has a large test suite, some patterns (wildcards with no path separators, like `*.zip`, or double `**` wildcards) have to create regexes on each call. By simply introducing some new types, and doing this work ahead of time gives us the following savings:

```
BenchmarkToolsIncludeWildcardOnly-8      	     100	  16927573 ns/op
BenchmarkFilterIncludeWildcardOnly-8     	    2000	    982018 ns/op
BenchmarkToolsIncludeDoubleAsterisk-8    	     100	  21409532 ns/op
BenchmarkFilterIncludeDoubleAsterisk-8   	     300	   4350653 ns/op
```",1196,True,en,7
1695,20,1,0,Internals,technoweenie,2016-11-22T22:06:19Z,752,458,15,1,,0,False,en,4
1694,12,5,25,Externals,sinbad,2016-11-28T15:42:53Z,367,0,2,6,"This PR adds an in-memory, optimistically locked key-value store. It's basically a replacement for Boltdb for caching active locks locally as requested in the lock PR.

Submitted separately because it's generic and hopefully easy to review. Rewrite of lock PR is still ongoing but will use this.",295,True,en,1
1689,5,16,12,Externals,sschuberth,2016-12-09T14:42:08Z,49,10,7,20,"I'm currently looking into reducing the number of places where the version is defined, so that less places need to be touched when bumping the version for a new release, like e.g. in 4e5ba415c41c42ceb9b91b89f0a3655740f3c276.

But I have a few questions in this regard. To start with, where are the values for the variables in [this line](https://github.com/git-lfs/git-lfs/blob/master/rpm/SPECS/git-lfs.spec#L9) of the RPM spec defined? Do these come from [a few lines above](https://github.com/git-lfs/git-lfs/blob/master/rpm/SPECS/git-lfs.spec#L1-L2)? I'm asking because these definitions differ in the case from the variable use.",632,True,en,0
1688,17,4,13,Internals,technoweenie,2016-11-21T17:32:03Z,360,203,6,2,"Added unit tests that would have caught the bug that required https://github.com/git-lfs/git-lfs/pull/1680.

Here's the test run on a slightly old version of master, with these 2 commits cherry picked:

```bash
$ gl
commit 35509bfc8836bdd2f5493404caea28c257db90d4
Author: risk danger olson <technoweenie@gmail.com>
Date:   Fri Nov 18 13:48:41 2016 -0700

    add unit tests for 'git cat-file --batch'

commit 65fdf9b6df5fabd19099528f18d95ced3301d333
Author: risk danger olson <technoweenie@gmail.com>
Date:   Fri Nov 18 12:54:56 2016 -0700

    add unit tests for 'cat-file --batch-check'

commit f92bd3b2145b8504753d7b08c27b37befb7556eb
Author: risk danger olson <technoweenie@gmail.com>
Date:   Fri Nov 18 07:44:20 2016 -0700

    remove deprecated features

$ script/test lfs -run TestCatFileBatch
--- FAIL: TestCatFileBatchScanner (0.00s)
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 128
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 128
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
	gitscanner_catfilebatchscanner_test.go:88: 0000000000000000000000000000000000000000 blob 1000
        Error Trace:    gitscanner_catfilebatchscanner_test.go:50
	Error:		Expected nil, but got: git cat-file --batch:: Invalid: ""\x01\x84\xe2\xa6%\x0e\xaaN\x04\xc1.{K<[`\xb8\xc1\x8fkf\x1ds\xcd15*\xa5\xf3\x9fHWqG\xe8\xb7\xe3\x82F\x1e\x82\xa1\xf4\xfcA\x06m\x8b=s\x17K\x9a2\xbd7\xc1\xa7]\xec\x00;!\xc2Y\x9a?\xc8\xd0EE\x1a\xef|z\xe4\x04\xbf$\x87\xa6\x17Ӵ\x97\xd2\r\xbb\xb7^\xe7\xa5\xcc9F,\xeb߅&\n""

FAIL
FAIL	github.com/git-lfs/git-lfs/lfs	0.010s
```

It's reading the invalid data because `io.LimitReader` wasn't ensuring that the `catFileBatchScanner` is reading all of the non-lfs pointer bytes.",3054,True,en,3
1687,4,0,2,Internals,technoweenie,2016-11-18T20:57:21Z,42,7,4,0,Some release fixes that were made for the v1.5.1 release.,57,False,en,0
1686,5,2,0,Internals,ttaylorr,2016-11-18T19:54:54Z,10,28,1,0,"This pull-request removes the remaining relics for supporting the legacy API from the transfer queue.

In particular, we no longer need:

- the `apic` channel (previously used for manually issuing legacy API requests out-of-band with the transfer adapter)
- the `oldApiWorkers` field which used control the number of out-of-band legacy API workers
- some references in the documentation referring to the legacy API

---

/cc @technoweenie @rubyist @sinbad ",456,True,en,0
1685,1,4,0,Internals,technoweenie,2016-11-18T21:40:59Z,1,0,1,0,"After shipped v1.5.1, I looked into why Fedora 24 isn't working. Turns out I just needed to add it to the list.

@JonasT: Does this work for you?",145,True,en,0
1684,2,0,0,Internals,technoweenie,2016-11-18T17:38:59Z,58,11,9,0,"This bumps the version number, and adds some code to track the sha-256 hashes of the built binaries.",100,False,en,0
1683,1,0,0,Internals,technoweenie,2016-11-18T16:29:39Z,11,1,1,0,Applies #1680 for v1.5.1.,25,False,en,0
1680,1,0,0,Internals,technoweenie,2016-11-18T16:16:52Z,11,1,1,0,"The problem here is that `DecodePointer()` will return an error early before reading `size` bytes. The scanner needs _all_ of those bytes to be read, so the next loop starts at an object header.

EDIT: bug was introduced in #1650.",230,True,en,0
1679,2,0,0,Internals,technoweenie,2016-11-18T18:34:17Z,3,319,12,0,"THE LIST

* `git lfs init` (use `git lfs install`)
* `git lfs uninit` (use `git lfs uninit`)
* `git lfs push --stdin` (use `git lfs pre-push`)
* `git lfs smudge --info` (use `git lfs pointer`)
* Git LFS no longer looks for a `.gitconfig` in the root of a repository's working directory. Use `.lfsconfig` instead.

https://www.youtube.com/watch?v=toFm4CkDaUE",357,True,en,3
1676,1,0,0,Internals,ttaylorr,2016-11-18T00:05:53Z,4,4,1,0,cc @technoweenie ,17,False,pl,0
1675,1,0,0,Internals,ttaylorr,2016-11-17T23:15:29Z,31,0,1,0,cc @technoweenie ,17,False,pl,0
1674,1,0,0,Internals,ttaylorr,2016-11-17T22:46:10Z,34,4,6,0,cc @technoweenie @rubyist @larsxschneider @sinbad @sschuberth ,62,False,de,0
1671,3,2,0,Internals,technoweenie,2016-11-17T22:01:58Z,22,19,2,0,"This ensures that all transfers by the `checkQueue` are set as uploaded. I thought this might also be the cause of a deadlock, but now I don't think so. Nothing is waiting for `len(missing)` items to flow through `transferc`.",225,False,en,0
1670,25,5,2,Internals,technoweenie,2016-11-18T20:48:55Z,1269,1097,23,1,"This PR builds on #1650 and introduces a `GitScanner` type. It's pretty empty, but it illustrates where I want to go with #1649. As of this PR, nothing outside of the `lfs` package uses `lfs.ScanRefs()` or `lfs.ScanRefsToChan()`.

TODO

* [x] merge #1650 
* [x] change base to `master`
* [x] :ship:",298,True,en,1
1666,2,0,1,Internals,technoweenie,2016-11-16T17:26:54Z,68,49,1,0,"I want to use `testutils` for testing #1650. However, it seems that `testutils.FileInput` can _only_ write LFS objects. This refactors the code into `(*FileInput) AddToCommit()`, which can eventually support writing plain git objects.",234,False,en,1
1659,24,4,0,Internals,technoweenie,2016-11-15T21:13:41Z,51,38,3,0,,0,False,en,0
1658,3,3,0,Internals,ttaylorr,2016-11-16T18:18:37Z,52,29,4,1,"Previously, we flushed intermediate data out of the underlying *bufio.Writer
used by the implementation of `pkt-line` in `*git.pktline` after _every_ write.
This means that we would flush after partial packets, whole packets, and after
pkt-line flush sequences. This is unnecessary.

Let us instead flush only after an entire packet has been written, after
writing the `0000` flush sequence.

/ref git-lfs/git-lfs#1640

---

/cc @technoweenie @larsxschneider ",459,False,en,3
1657,6,0,0,Internals,technoweenie,2016-11-15T17:59:59Z,341,341,136,0,"I transferred the repo to `git-lfs/git-lfs` to keep the related repositories together. This updates the links and import paths to use the new one. Everything should redirect over, with a few exceptions:

* If you cloned the repo to `$GOPATH/src/github.com/github/git-lfs` locally, you'll have to move it to `$GOPATH/src/github.com/git-lfs/git-lfs` manually.
* The Packagecloud link is staying, since `github` is the username on the account.
* While `https://gitter.im/git-lfs/git-lfs` is the chat room link, it does redirect properly to the existing room.",555,True,en,33
1656,1,0,0,Internals,technoweenie,2016-11-15T17:28:56Z,2,4,1,0,Re-implementing #1643 since @jjgod can't sign the cla: https://github.com/github/git-lfs/pull/1643#issuecomment-260432346,121,False,en,0
1650,12,3,10,Internals,technoweenie,2016-11-16T23:50:15Z,251,121,3,2,"This is the first step towards https://github.com/github/git-lfs/issues/1649. This is a pattern that worked for a small scanner prototype I hacked up this weekend. The scanner currently relies on `git rev-list`, `git cat-file --batch-check`, and `git cat-file --batch`. Feeding data through requires 3 channels:

* An output channel that is sent results from the current command.
* An input channel that receives values (usually git sha1s) from something.
* A single error channel that all commands share.

The commands themselves continue running in goroutines until the input channel is closed. Once closed, the stdout reader will eventually return `io.EOF`, which will eventually close the output channel. The output channel of `git cat-file --batch-check` would be an input channel for `git cat-file --batch`, so its closure would eventually close `git cat-file --batch` too.

This code is written in the lfs package with prefixed filenames and prefixed types where necessary. The goal is to get the new design in there, and then start phasing out coupling on the channel wrappers, `*lfs.WrappedPointer`, etc. Doing this in the `lfs` package is vital, so we can watch it run our test suite and find issues earlier rather than later.",1236,True,en,0
1642,3,0,0,Internals,technoweenie,2016-11-15T21:21:13Z,26,23,3,4,"This adds links to where the gitattributes patterns are defined. It also keeps the doc and internal naming consistent. It adds gitattributes patterns, not paths.",161,False,en,1
1641,5,0,0,Internals,technoweenie,2016-11-15T21:34:26Z,525,210,6,5,"This is a major reorganization of the API docs. Here's what I did:

* Removed relevant auth and config info from the spec.
* Ignored legacy API stuff
* Collapsed the Batch API v1 and v1.3 specs. The properties added in v1.3 are all optional.
* Added an Authentication page.
* Added a Server Discovery page.
* Added a Batch API page.
* Updated the API readme to be a table of contents for the various pages.

View the [rendered markdown](https://github.com/github/git-lfs/blob/api-docs-v2/docs/api/README.md).

TODO:

* [x] Document `basic` transfer adapter
* [x] Add json schema references
* [x] Remove or unlink old docs",621,True,en,0
1638,3,0,0,Internals,technoweenie,2016-11-15T17:02:32Z,4,1,2,5,"I've wanted this pre-push tracing for awhile. Makes it easier to see why pushes aren't uploading the objects you think they should.

Also, this gets rid of an extra `trace git-lfs: HTTP:` when you add `GIT_TRACE=` to any Git LFS commands that make HTTP requests.",262,True,en,0
1636,1,0,0,Externals,larsxschneider,2016-11-10T13:22:27Z,1,1,1,0,"Git 1.8.2 seems to be sufficent for Linux but not for macOS. 

Related change: 632f4881293d6974f169adce3a0f53b4e96393bb",119,True,en,0
1634,6,0,7,Internals,technoweenie,2016-11-15T15:55:52Z,106,24,10,5,"I thought it'd be cool to decouple some things from a `*config.Configuration`, specifically `cfg.Endpoint()`. When converting a raw url to an `Endpoint`, [`config.NewEndpointWithConfig()`](https://github.com/github/git-lfs/blob/a45eaee6fa35993763f87aa7611586faea08dfd5/config/endpoint.go#L54-L56) calls [`ReplaceUrlAlias()`](https://github.com/github/git-lfs/blob/a45eaee6fa35993763f87aa7611586faea08dfd5/config/config.go#L451-L454), which [calls `AllGitConfig()` inside `urlAliases()`](https://github.com/github/git-lfs/blob/a45eaee6fa35993763f87aa7611586faea08dfd5/config/config.go#L430-L438).

This PR adds `All()` to the `config.Environment` interface. But, it also had to add `Del(key string)` and `Set(key, value string)` because of a single spot that modifies that internal `gitConfig` map. I'm not crazy about it, but I think it's better than dealing with that `gitConfig`.

One thought I had was specififying a `MutableEnvironment` interface:

```golang
type Environment interface {
	Get(key string) (val string, ok bool)
	Bool(key string, def bool) (val bool)
	Int(key string, def int) (val int)
	All() map[string]string
}

type MutableEnvironment interface {
	Set(key, value string)
	Del(key string)
}

type Configuration struct {
	Os Environment
	Git Environment
	mutableGit MutableEnvironment
// ...
```

They would need to point to the same data so that changes in `SetEndpointAccess()` affect `Git.Get()` calls elsewhere, but it could be some extra hassle to ensure callers don't start adding `Set()` and `Delete()` calls on `Environment` objects.

* [x] add `MutableEnvironment`?
* [x] Rename Fetcher?
* [x] Docs for all exported funcs",1651,True,en,0
1631,2,1,0,Internals,technoweenie,2016-11-09T00:09:08Z,15,6,3,0,"This deprecates `git lfs smudge --info`, since `git lfs ls-files` provides us better info. 

```
$ git lfs pointer --file CHANGELOG.md | git lfs smudge -i
Git LFS pointer for CHANGELOG.md

WARNING: 'smudge --info' is deprecated and will be removed in v2.0
USE INSTEAD:
  $ git lfs pointer --file=path/to/file
  $ git lfs ls-files

20704 --
```

It also deprecates `git lfs push --stdin`, since `git lfs pre-push` exists.

```
$ echo hi | git lfs push origin master --stdin
WARNING: 'git lfs push --stdin' is deprecated, and will be removed in v2.0.
Run 'git lfs update' or ensure .git/hooks/pre-push uses 'git lfs pre-push'.
```",628,True,en,0
1629,7,0,0,Internals,technoweenie,2016-11-18T14:36:26Z,245,1715,27,9,"This removes legacy api support. The only wrinkle here is that the api upload and download tests had to be rewritten to exercise the batch api and not the legacy API.

* [x] remove legacy api docs",196,True,en,14
1627,6,1,2,Externals,larsxschneider,2016-11-08T18:10:10Z,29,25,10,0,a few patches that I thought could be useful after my first review,66,False,en,5
1626,1,1,0,Externals,larsxschneider,2016-11-08T20:39:18Z,30,5,1,0,"According to @technoweenie GitLFS should work with Git 1.8.2 or later:
https://github.com/github/git-lfs/issues/410#issuecomment-112976174

Git 1.8.2 is sufficient for Linux but macOS seems to require at least
Git 1.8.5 to run all integration tests. On Git 1.8.2 ""test: pull"" and
""test: pull with raw remote url"" fail on macOS.

Details: https://travis-ci.org/github/git-lfs/jobs/174177362",389,False,en,0
1622,14,1,13,Internals,ttaylorr,2016-11-07T23:24:25Z,283,23,3,4,"This pull-request provides an implementation of the `io.Writer` interface capable of writing packets using the Git ""pktline"" format to an underlying datastream.

Here's a 🔎  at some the different parts of this PR:

1. https://github.com/github/git-lfs/commit/5723bb8c016d422fa098fcdaaf1dd15e146c3e42: implement the `PacketWriter` type and add an exhaustive set of unit tests.
2. https://github.com/github/git-lfs/commit/8ab75794997d64c92dc7649abb216ce33e32fbe4: add public constructor `NewPacketWriter` which takes any `io.Writer` and returns a `*PacketWriter` wrapping that underneath. If the given writer is itself already a `*PacketWriter`, it returns that wholesale to avoid re-wrapping.
3. https://github.com/github/git-lfs/commit/a90c16285bc98ae8f7e71fea832494eeabb0caf2: Use the `io.Writer` in the `clean`/`smudge` implementation in `commands/commands_filter.go`.
4. https://github.com/github/git-lfs/commit/5e72db6a3541b21d9bbb1981e09a981a8827f26f: A quick bit of 💅  to use the new `tools.MinInt` func instead of casting `int`s to `float64`s and relying on (potentially) inaccurate results from `math.Min`.

In terms of the implementation of the `io.Writer` itself, here's a quick tour:

- Since the pktline protocol expects us to write as much data as we can in a single packet (as many bytes as we can up to and including `MaxPacketLength`), we have an internal buffer that is written to until we have ingested enough data to fill a single packet. 
- To avoid leaving data in the buffer at the end of writing a chunk of data, calling `w.Write(nil)` is a special-case signaling to write the `0000` flush packet.
- `Write(p []byte)` reports only the amount of _data_ (not including the 4-byte headers) _actually_ written to the stream. This means that `Write()` with less data than `MaxPacketLength` will return `(0, nil)`, unless there was enough data in the buffer to cause a packet to be written.
- `Write` is smart enough to write multiple packets if the given buffer ""p"" holds more information than a single packet can hold. It will buffer extra data that does not fit past the first `n` packets.

---

/cc @technoweenie @larsxschneider @sinbad @rubyist @sschuberth ",2185,True,en,1
1621,25,4,11,Internals,ttaylorr,2016-11-08T00:30:43Z,560,92,12,5,"This pull-request provides an implementation of the `io.Reader` interface that can read data encoded with the protocol used for filter process communication.

This provides a huge savings on memory usage when cleaning files, as the shasum of the contents can be calculated as data is streamed in, and then discarded.

This pull request is implemented in three parts:

- https://github.com/github/git-lfs/commit/4524d1221efc54d82f4a409208e0d83a56a1c78e: Implement the underlying `PacketReader`.
- https://github.com/github/git-lfs/commit/d23c0445f4580d6b82345ae3613bf47ecaff482a: Make the `WriteStatus` method public since reading packets no longer reports success/error statuses, and this responsibility will be delegated to the caller in the following commit...
- https://github.com/github/git-lfs/commit/2db63047c028811deeab1b8462e44251304164ca: use an `io.Reader` as the `Payload` field of a request, instead of buffering the data upfront.

Some notes on the implementation:

- There is no ""offset"" encoded into where the reader starts and stops. This means that a given packet run must be _completely_ consumed before the next one is read. The code as it currently stands within this branch, does obey that rule as the synchronization is done with the loop condition, `scanner.Scan()`.
- The implementation is safe to call with buffers shorter or longer than the packet that is being read. Any data that wont fit into the current given buffer will be sent to an internal buffer, and subsequent calls to `Read(p []byte)` will read first from the internal buffer until the internal buffer is drained.
- An `io.EOF` is returned on the first call to `Read()` _after_ all of the data has been consumed. This is done to avoid a complicated implementation dealing with peeking bytes to see if more data is incoming. Luckily, the Go documentation allows for this (meaning things like `io.Copy`, etc will respect it):

> An instance of this general case is that a Reader returning a non-zero number of bytes at the end of the input stream may return either err == EOF or err == nil. The next Read should return 0, EOF.

(See: https://golang.org/pkg/io#Reader).

---

/cc @larsxschneider @technoweenie @sinbad @rubyist @sschuberth ",2225,True,en,5
1620,34,1,6,Internals,ttaylorr,2016-11-08T02:27:41Z,660,151,12,5,"This pull-request cleans up the `ObjectScanner` API to better fit the scanner-pattern, an example of which can be found in [`bufio.Scanner`](https://golang.org/pkg/bufio/#Scanner).

Commit by commit, here's the breakdown:

1. https://github.com/github/git-lfs/commit/78e583e48e83f5c3889e58079f0242e9e1736aa1: instead of logging errors directly to `os.Stderr` and returning a `bool` from `Init()`, return those messages in `error`s.
2. https://github.com/github/git-lfs/commit/6728507d5e33e832083e97be1ec53b893795864a: cleanup the `""Error: ""` prefixes from the messages, since that formatting will be handled by the `commands` package now.
3. https://github.com/github/git-lfs/commit/18ac2724fd84a76a95ed494a0b3c337974d78ba9, https://github.com/github/git-lfs/commit/b2e568f56d1efb533de01accdd58348e03aa0f65: Do the same thing to `NegotiateCapabilities()`, in the same order.
4. https://github.com/github/git-lfs/commit/c326fcb8c55ae654143d308bfb6a1e145fc1c8f1: Introduce the `*git.Request` type, to clean up the signature of the upcoming `Object()` function to return a type with a `Header` and `Payload` instead of adding more return types, i.e.,:

```go 
type Request struct {
        Header map[string]string
        Payload []byte
}

func (s *ObjectScanner) Object() *Request { ... }
```

instead of:

```go
func (s *ObjectScanner) Object() (map[string]string, []byte)
```

by giving them names, and a meaningful type, I think of that function below is a lot cleaner.

5. https://github.com/github/git-lfs/commit/a778118b384ed352ddf9158e945e688c6e7fbe8a: Implement the scanner itself.

The scanner ends of being a lot cleaner at the call site. Instead of looping forever, and then breaking out at different points in the body, the loop condition encapsulates all of those tiny other exit conditions in one.

The error gets handled once, outside of the loop, which is essentially what was happening in before when it was handled inside of the loop before breaking, now it's just clearer what is actually going on.

This idea was originally a suggestion from @rubyist way back in https://github.com/github/git-lfs/pull/1382#issuecomment-234579799, so credit where credit is due for a great idea!

---

/cc @technoweenie @larsxschneider @sinbad @rubyist @sschuberth ",2267,True,en,5
1619,40,6,15,Internals,ttaylorr,2016-11-08T02:38:31Z,1227,210,14,5,"This pull-request adds unit tests ensuring that the Go implementation of the filter protocol is correct.

This PR contains a fair number of changes, so here's the breakdown:

1. https://github.com/github/git-lfs/commit/8bc726dc87d4763d083c4c958842f48c34db6362: Split the high-level protocol (reading requests, writing responses) from the low-level protocol (reading/writing packets, length headers, chunking large packets, etc). This was done so that the unit tests at each ""strata"" of the protocol could be easily separated, and it hides the underlying implementation of the protocol from the higher-level use cases.
2. https://github.com/github/git-lfs/commit/17f9ead05c0cf3fa81f3d5bbf55a7121b11359bb: add some unit tests for the low-level protocol.
3. https://github.com/github/git-lfs/commit/31d04161d90fc522bcb76e00566eda006979c595: add some unit tests for the high-level protocol.

Though I should have done this sooner, my plan going forward is to rename these types in a future PR to more accurately reflect what they're used for. The `ObjectScanner` type will actually implement the scanner pattern in a future PR in this series, so that name may end up staying the same.

---

/cc @technoweenie @larsxschneider @sinbad @rubyist @sschuberth ",1250,True,en,6
1618,3,5,1,Internals,ttaylorr,2016-11-03T13:28:50Z,102,0,1,0,"This pull request adds an integration test making sure the filter protocol works as expected, when it is enabled.

The test I added creates two files tracked with LFS on two separate branches, and asserts that on each branch, each one of the files:

- exists
- has the correct ""smudged"" contents
- has a valid LFS pointer underneath.

Currently, running the test is gated on the `$GIT_LFS_USE_LEGACY_FILTER` being enabled (`eq ""1""`), and the installed version of Git including support for the filter process. Usually, this is done with:

```bash
ensure_git_version_isnt ""$VERSION_LOWER"" ""2.11.0""
```

but since `2.11.0` isn't released yet, the best we can do is check that the version is a pre-release and contains a ""g"" in the patch number, like: `git version 2.10.1.710.g6539e97`. This is done by using the hack below, which should be removed once version 2.11.0 is released.

```bash
if [ ""1"" -ne ""$(git version | cut -d ' ' -f 3 | grep -c ""g"")"" ]; then
  echo ""skip: $0 git version does not include support for filter protocol""
  exit
fi
```

One open question is how we should treat other existing integration tests once using the filter protocol is the blessed way to clean/smudge. I'm thinking we should ensure that our build matrix covers versions before/after 2.11, and then run the best clean/smudge mechanism we can on each. That way, all the tests will use filter protocol on the versions of Git that support it, and we'll still test the old behavior on machines that don't.

---

/cc @larsxschneider @technoweenie @rubyist @sinbad @sschuberth ",1556,True,en,1
1617,90,12,68,Internals,ttaylorr,2016-11-11T21:08:51Z,1594,66,28,9,"This pull-request is a continuation of #1382, originally authored by @larsxschneider.

It should serve as a place to merge in all of PRs in the filter-stream series (see description below), and then be merged into master as one huge thing. I'm suggesting this since the PR as of https://github.com/github/git-lfs/commit/46a8ee599d0da1fdee59bcdcdbfcbdc966e5db8e is incomplete, and not in a state that I would feel comfortable landing into master.

In terms of the PR series, here's what I'm thinking:

1. https://github.com/github/git-lfs/pull/1617: Initial implementation of the filter protocol from @larsxschneider, that's this PR. 
2. https://github.com/github/git-lfs/pull/1618: Integration tests to make sure that all subsequent PRs keep working
3. https://github.com/github/git-lfs/pull/1619: Unit tests around the protocol reading/writing to verify that its behavior is correct.
4. https://github.com/github/git-lfs/pull/1620: Make the ObjectScanner behave like a Scanner. 
5. https://github.com/github/git-lfs/pull/1621: An `io.Reader` implementation for reading data off of the filter stream, and wiring that `io.Reader` up throughout the code
6. https://github.com/github/git-lfs/pull/1622: An `io.Writer` implementation for writing streams of data to the filter stream, and wiring that up
7. ~~[pending]:~~ A cleanup PR to rename types, document anything that I missed, and generally apply some 💅  EDIT: this was done in place

-----

/cc @larsxschneider @technoweenie @sinbad @rubyist @sschuberth ",1511,True,en,14
1616,24,6,21,Externals,sinbad,2016-11-08T15:52:08Z,549,142,9,6,"Fixes #1611

Provides a number of more optimal replacements for `filepath.Walk`. The easiest of which is `tools.FastWalkGitRepo` which automatically avoids walking `.git` and anything that matches any `.gitignore` it discovers as it walks.

Lower-level versions are available to include/exclude custom patterns.

I've used this in `git lfs track` to significantly speed up the enumeration of `.gitattributes` files, particularly when a repo contains a lot of files, most of which are in the `.gitignore`, as in #1611. 

I've also refactored `FilenamePassesIncludeExcludeFilter` into the `tools` package, and extracted a utility function `FileMatch` which replaces `filepath.Match` by mirroring the behaviour of `gitignore` pattern matching, which wasn't completely supported before. This has a side effect of enhancing the capabilities of the include/exclude filters used elsewhere to support a more complete range of wildcard options including the ""**"" folder match.",967,True,en,2
1609,1,0,0,Externals,sinbad,2016-10-26T15:25:17Z,56,1,1,0,"@technoweenie as requested 😄 
",33,True,af,0
1607,1,1,0,Internals,ttaylorr,2016-10-25T16:32:54Z,0,5645,1,0,"cc @technoweenie 
",18,True,pl,0
1605,1,6,0,Externals,chalstrick,2016-10-25T14:48:53Z,5647,15,2,1,"Sometimes it makes sense to use a proxy even when the remote host is localhost
or 127.0.0.1. git-lfs in contrast to e.g. native git does not allow to use a
proxy when talking to localhost. Remove this special treatment of localhost
and react only on http_proxy or no_proxy env variables.

My use case: I wanted to debug/analyze network traffic from a git client to the
git server and the lfs server running on my developer machine. I set up
mitmproxy [1] as a proxy server running on localhost and I set http_proxy to
point to mitmproxy. I was able to see all the traffic between the client and
the local git server in mitmproxy but the the communication between the client
and the lfs server was hidden because git-lfs ignored the proxy settings
because the hostname was localhost.
",783,False,en,0
1603,7,1,3,Internals,ttaylorr,2016-10-24T20:36:47Z,32,15,4,2,"This pull request enhances of the descriptiveness of the error message returned when an object has expired.

To accomplish this, we needed to teach the `api.Object` how to return which action it was expired for, so we have a basis to compare the duration against the time that the transfer was attempted.

One open ❓ I'm thinking about is whether or not we should change the behavior for the `*api.Object.IsExpired` method to also take a direction so that it can compare against a specific action, and not all of them (as it currently does). This may not actually matter so much, since spec-compliant implementations of the LFS API will only send back the action that we're interested in.

The new error message is down below:

```
Git LFS: (0 of 1 files) 0 B / 29 B
    LFS: lfs/transfer: object ""54899ec3690514f121a8f55729e9f802cde71091c3245966175a0bab6134573d"" has expired at 2016-10-21 14:24:33.728774785 -0600 MDT, -4m55.024738112s ago
    error: failed to push some refs to 'http://127.0.0.1:57180/push_no_retry_expired_action'
```
## 

cc @technoweenie @rubyist @sinbad @sschuberth 
",1092,True,en,2
1602,1,2,3,Internals,ttaylorr,2016-10-24T21:15:20Z,23,4,6,3,"cc @technoweenie @rubyist @sschuberth
",38,True,pl,0
1600,4,3,0,Internals,ttaylorr,2016-10-21T19:47:27Z,80,7,4,1,"This pull-request fixes a regression where sending a non-unique OID to a transfer queue more than once would result in a `panic()` after having decremented the `sync.WaitGroup` past zero.

The fix comes in two parts:
1. https://github.com/github/git-lfs/commit/047fe19830fd497dd9882ed38a3030ec81938491: Only allow calling `lfs.TransferQueue.Add()` once per OID.
2. https://github.com/github/git-lfs/commit/d770dfa09eb289ff4d4167d91ce4a9030f9886ed: De-dup incoming pointers such that the progress meter displays the right number of bytes and files.

Regarding https://github.com/github/git-lfs/commit/d770dfa09eb289ff4d4167d91ce4a9030f9886ed, I am not hugely excited about adding another conditional against a potentially large set of data, but given the expected lifetime of this code, and the relative speed of the implementation (`tools.StringSet`), I am OK with releasing this.

As an additional note, this is a similar piece of functionality as compared what we do when calling `git lfs fetch` in `lfs.readyAndMissingPointers`. This function accepts:
- a list of all pointers
- an include filter
- an exclude filter

and returns (in order):
- the pointers we already have
- the pointers we need
- the total number of bytes we're expecting to transfer.

To make this calculation, it uses a similar mechanism [here](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/commands/command_fetch.go#L317-L322) to de-dup pointers that we have seen already.
## 

/cc @technoweenie @rubyist @sinbad @sschuberth 
",1534,True,en,2
1599,1,3,0,Externals,sschuberth,2016-10-20T19:16:50Z,7,7,2,0,"Not only expose the error message, but also the result message from
calling SSH which contains details about the cause. At the example of
using the wrong SSH key for authentication, with this the console shows

```
download check: exit status 255: Permission denied (publickey).
```

instead of just

```
download check: exit status 255
```

and the log shows

```
trace git-lfs: ssh: download with url failed,
error: exit status 255, message: Permission denied (publickey).
```

instead of just

```
trace git-lfs: ssh: download attempted with url.
Error: exit status 255
```
",577,False,en,0
1594,1,1,0,Externals,sschuberth,2016-10-18T15:16:54Z,2,0,1,0,"As suggested [here](https://github.com/appveyor/ci/issues/1115#issuecomment-254367662). However, I'm wondering why I still see build for bot the branch and PR here, and now I also start seeing both for Travis CI builds.
",220,True,en,0
1593,1,4,3,Externals,dpursehouse,2016-10-18T07:57:28Z,2,0,1,0,"Change-Id: I139809347d7e59d85758e3696a01f2e2e8329c91
Signed-off-by: David Pursehouse dpursehouse@collab.net
",108,False,en,0
1591,1,0,2,Internals,ttaylorr,2016-10-17T21:16:37Z,26,4,6,0,"cc @technoweenie 
",18,True,pl,0
1585,6,1,0,Internals,ttaylorr,2016-10-17T15:18:40Z,154,14,3,1,"This pull-request adds tests asserting retry behavior when both upload and download requests are made to the storage endpoint.

I will follow this PR up with another special-case handler guarding interactions with the batch API endpoint, which, once merged, will fully cover the new retry behavior at the integration level.
## 

/cc @technoweenie @sschuberth 
",360,True,en,3
1584,4,0,3,Internals,ttaylorr,2016-10-15T16:46:21Z,111,4,4,0,"This pull-request fixes an issue described in https://github.com/github/git-lfs/issues/1580, where, when using the transferqueue with `lfs.batch=false`, a failed legacy check would result in a nil-pointer dereference `panic`.

To ensure further safety, I added two new `oidHandler`s to force a finite number of retries into both the upload/download check for legacy transfers. I will follow this up in my next pull-request with a similar solution for the storage endpoint so we can also test this behavior when using the batch API.
## 

/cc @technoweenie @rubyist @sschuberth #1580
",582,True,en,3
1583,1,0,0,Internals,ttaylorr,2016-10-14T21:58:18Z,1,1,1,0,"This pull-request fixes all places within the transferqueue where an incorrect number of arguments are given to the trace log.
## 

/cc @technoweenie 
",151,False,en,0
1582,1,0,0,Internals,ttaylorr,2016-10-14T21:58:12Z,2,2,1,0,"This pull-request fixes some accidental usage of `fmt.Println` where `fmt.Fprintln` should have been used instead. Since `fmt.Println` accepts variadic arguments of the form `(vs ...interface{})`, the old behavior was to print out the address of `os.Stderr` (given as the first argument), and then the message as expected.
## 

/cc @technoweenie 
",347,False,en,0
1579,1,0,0,Externals,sschuberth,2016-10-14T14:15:40Z,2,2,1,0,"Also consistently use the term ""legacy"" instead of ""original"".
",63,True,en,0
1577,1,0,0,Externals,sschuberth,2016-10-13T20:33:32Z,18,0,1,0,"This re-opens https://github.com/github/git-lfs/pull/1576.
",59,True,en,0
1575,2,1,0,Externals,sschuberth,2016-10-12T22:17:16Z,1,0,3,0,"And add compatibility with the ANSI version of Inno Setup with has issues with decoding 16-bits-per-pixel BMP files.
",117,True,en,0
1574,2,2,0,Internals,ttaylorr,2016-10-12T16:07:54Z,4,1,1,0,"This pull requests moves our Travis badge down to a newline, and adds an AppVeyor badge for the build status on `master` right next to it.
## 

/cc @technoweenie @sschuberth 
",175,False,en,0
1571,1,1,0,Internals,ttaylorr,2016-10-10T22:18:11Z,1,1,1,0,"Previously, decrementing the surrounding `sync.WaitGroup` allowed the
`q.errorc` channel to be closed before this send could occur. This racy
behavior introduced a send-on-closed-channel panic, which is fixed in this
commit.
## 

/cc @technoweenie @sinbad @rubyist 
",266,False,en,0
1570,1,0,0,Internals,ttaylorr,2016-10-10T21:28:33Z,7,0,1,0,"cc @technoweenie @sinbad
",25,True,pl,0
1569,1,0,0,Internals,ttaylorr,2016-10-10T22:59:37Z,50,5,7,0,"cc @technoweenie @rubyist @sinbad @larsxschneider @sschuberth
",62,True,de,0
1568,1,0,0,Internals,ttaylorr,2016-10-10T19:56:44Z,1,17,1,0,"Since we only compile LFS on Go 1.7.1, let's update our build matrix to match.
## 

/cc @technoweenie @sschuberth @larsxschneider @sinbad 
",139,False,en,0
1567,1,6,1,Externals,sschuberth,2016-10-10T19:25:42Z,12,3,2,1,"This depends on (and contains the changes from) PR #1566. Once that other PR is merged, this PR contains only a single commit to turn on tests on AppVeyor CI, which should now all pass.
",186,True,en,0
1566,4,5,7,Externals,sschuberth,2016-10-10T17:37:40Z,30,17,4,1,"Some changes around using ""sha256sum"" instead of ""shasum"" on Windows, in particular on MSYS2.
",94,True,en,4
1565,2,4,0,Internals,technoweenie,2016-10-08T00:12:54Z,12,15,1,0,"This removes the windows-specific hacks, and uses `filepath.Clean()` to sanitize the paths. This broke previously because it was `filepath.Match()` expects back slashes on windows.
",181,True,en,0
1564,1,0,0,Internals,ttaylorr,2016-10-10T17:10:09Z,23,4,3,2,"This pull request triggers a warning whenever usage of the legacy API is detected. This is a part of a larger effort to remove usage of the legacy API entirely from Git LFS by the time we release v1.5.0.

I decided to print the message out from the API, since it's the quickest way we can land this without some extra plumbing. Because the `commands` package already has a dependency leading into the `api` package, we can't use `commands.Error` or similar, thus the need for a `fmt.Fprintf` directly.

One other option is to check the config value for `lfs.batch` directly (via `coonfig.Config.BatchEnabled()`) and print it out from the commands package. This would be cleaner, of course, but doesn't accurately cover the case where we fallback to the legacy API mid-transfer.

Either way, this code isn't going to live here long, so I don't think it matters terribly much.
## 

/cc @technoweenie @rubyist 
",908,True,en,2
1563,3,3,1,Internals,ttaylorr,2016-10-08T00:11:15Z,186,9,5,0,"This pull-request fixes a mismatch between LFS's file-matching algorithm and the one used by `.gitattributes`.

Previously, all patterns that began with a leading `/` and matching files in subdirectories were ignored (i.e., `/a/dir/b.dat`). This is incorrect, since Git actually _will_ match these files, unless they contain a wildcard pattern (i.e., `/*.dat`).

This pull-request fixes that by only allow patterns with a leading slash that match files by name, thereby not using wildcard characters.
## 

/cc @technoweenie @larsxschneider #1546.
",547,True,en,1
1557,1,4,0,Externals,sschuberth,2016-10-06T19:35:20Z,2,2,1,1,"It seems some osx10.11 Travis workers already have git installed via
homebrew, resulting in

```
Error: git-2.10.0 already installed

To install this version, first `brew unlink git`
```

So only install git if not installed yet, and upgrade it otherwise.
",256,False,en,0
1550,3,1,0,Internals,ttaylorr,2016-10-03T14:59:30Z,78,24,2,2,"This pull-request teaches the `git lfs status` command how to recognize multiple files that share the same contents. By modifying the behavior of `lfs.ScanIndex`, we now maintain a _slice_ of file metadata associated with a given OID, instead of a one-to-one association [(as before)](https://github.com/github/git-lfs/blob/d8cab9ec1ce008f0230ca6a97581eda0b362d4a1/lfs/scanner.go#L188).

`ScanIndex` now only [accepts unique pointer OIDs](https://github.com/github/git-lfs/commit/752b88e781dcb431e4fe38ea08fccb64cfddf212) (even if there are multiple pointers for a given OID, in the case of many files sharing the same contents), and then [resolves them all at once](https://github.com/github/git-lfs/blob/7c1b2f063979adcde638cf54eb79f0177e4cb947/lfs/scanner.go#L276-L289) to multiple files, per the data stored in the indexFileMap. 

While working on this, @technoweenie and I found what may be a Git core bug having to do with checking a file that is both in the index and working tree (i.e., it appears in both `git diff-index` and `git diff-index --cached`). I stashed a failing test that I wrote to demonstrate this behavior in [this](https://gist.github.com/ttaylorr/bc6df845466cfb720327d31610bc97f7) Gist.

As an aside, this PR is a temporary measure. Maintaining these extra caches is not a long-term solution that I'd like to keep, this is more of a hack to solve this bug quickly.
## 

/cc @technoweenie @sinbad @rubyist
",1431,True,en,1
1545,1,2,6,Internals,ttaylorr,2016-09-29T15:59:18Z,132,17,2,0,"This pull-request introduces the extracted `RetryCounter` type, which serves two purposes:
- Allows configuration via the `lfs.transfer.maxretries` `.gitconfig` option
- Serves as a base on which to implement retry budgets

📝  I left a few notes throughout the code to point out some choices I made, but this should be a pretty minor change regardless.

I want to investigate a higher-level integration test for this behavior, but I'm not sure what it will look like after retry budgets are implemented. As a first pass, I'm thinking that we could encode ""number of retries before success"" on the server side and assert that we retried as many times as we could on the client side.

:wave: thanks in advance for the review.

---

/cc @technoweenie @rubyist @sinbad for 👀 
",778,False,en,1
1540,4,0,3,Externals,sinbad,2016-09-27T23:15:41Z,57,20,5,1,"Fixes #1536 

Also makes added files appear in the staged area before the first commit.
",88,True,en,1
1535,2,0,1,Internals,ttaylorr,2016-09-22T19:22:05Z,84,44,1,0,"This pull-request teaches the `lfs/transfer_queue` how to retry an object more than once per transfer.
### Previously

The transfer queue used to follow these steps when executing a transfer:
1. Receive a bunch of objects from calls to [`Add()`](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L84-L97)
2. Start either the [`batchApiRoutine`](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L330-L408) or [`individualApiRoutine`](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L266-L303) based on [its capabilities](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L442-L457).
3. Attempt to transfer the object(s), and commit to a [`retry`](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L459-L461) if it failed with a [retriable error](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L463-L469).
   1. Collect the transfers to be retried in the [`retryCollector`](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L418-L423)
   2. [Close the transfer channel to kick off all of the objects to be retried.](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L228-L231)
   3. [Re-add all of the objects to be retried](https://github.com/github/git-lfs/blob/878165d746549404cf1ddbac0db58573904abbe0/lfs/transfer_queue.go#L233-L242) and re-process them _once_.
4. Exit.

This works fine, but limits the transfer queue to:
- Responding to one set of retries per transfer.
- Responding to one retry per unique OID in the queue.
### Now

Now, the transfer queue knows how to immediately retry an object. It works like this:
1. Steps 1-4 from above.
2. If an object failed, and [can be retried](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L492-L512), [enqueue a retry](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L488-L490).
3. Collect the retry, and...
   1. Make sure that we [have the budget](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L438-L441) to retry the object.
   2. [`Add()`](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L445) it to the next batch, or API channel (in legacy mode)
   3. If in batch mode, [immediately flush the batch](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L446-L449), forcing the `batchApiRoutine` function to [receive a new batch](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L348).
4. [Wait](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L249) until all objects have been either transferred, or abandoned.

(The ability to flush a batch was introduced in #1528, and enables the ability to immediately retry an object in a batch.) 

In order to make sure that all items are processed before exiting, the way we treat the internal waitgroup `q.wait` changed slightly. Previously, `q.wait` was incremented every time we try to preform a transfer on an item. To prevent a situation where the `WaitGroup` would reach zero while waiting in between failing an object and retrying it, the `WaitGroup` is now [only incremented the _first_ time](https://github.com/github/git-lfs/blob/8d6102854fe14be05602ebe7fe213518685b30ed/lfs/transfer_queue.go#L95-L100) an object begins a transfer.

The transferqueue also now keeps track of the number of retries made per OID in order to prevent infinitely retrying that transfer. Currently, the maximum number of retries per object is set to 1, in order to keep the same behavior as from before this PR which is why there are no new tests.

I've also left some line comments throughout the code to clarify some further things.
## 

/cc @technoweenie @rubyist @sinbad for 👀 and 💭
",4275,False,en,0
1528,11,0,8,Internals,ttaylorr,2016-09-20T19:58:39Z,93,44,2,0,"This pull-request adds the ability to immediately flush the currently accumulating batch.

The motivation behind this pull-request is the ability to support multiple retries per object in the current transfer queue implementation. Currently, we [keep track of the items that failed to transfer](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/transfer_queue.go#L420) and then [retry them once more](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/transfer_queue.go#L233-L242) before we exit in [`Wait()`](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/transfer_queue.go#L218-L221).

In the future, we'd like to support retrying objects multiple times, by re-submitting them into the Batcher, and then getting batches of retries out. In order to do this, we need to know how many retries there are left. In my initial pass, I simply re-added failed items to the batcher, and waited for a batch to come out. However, a batch isn't delivered until we either [fill the batch size](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/batcher.go#L63) (unlikely for retries), or [Exit()](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/batcher.go#L65-L68), [and close all of the channels](https://github.com/github/git-lfs/blob/b7b1f2b7985c8f7a18c563c70898f669ffb8c13c/lfs/batcher.go#L51).

To allow us to force a batch to be delivered immediately, we guarentee that an item has been delivered on the channel (more information in https://github.com/github/git-lfs/commit/98873d87c4b06beecbba57221e70dd975ce7d7d4), and then immediately Flush() the batch, giving us a batch of 1 item to be retried.

In future PRs, I plan to make this retry behavior smarter, by overflowing retry buckets, or batching the retries together. As a first pass, I just want it to work 😄 

As a side 📝 , the test cases that I introduced in https://github.com/github/git-lfs/pull/613 (coincidentally, my first LFS patch) did not fully cover the behavior of the batcher, namely what happens when an uneven amount of items is added. This is what was causing the deadlock in https://github.com/github/git-lfs/pull/1528/commits/98873d87c4b06beecbba57221e70dd975ce7d7d4. With some debugging, the old tests produced:

```
Creating batcher with 5 items and size 3
Added item
Added item
Added item
Added item # <- gone
Added item # <- gone
Grabbing batch #1
Got batch size of 3
<end>
```

The remaining two items are gone! No one ever checks for them. I fixed this behavior in https://github.com/github/git-lfs/pull/1528/commits/a0d0635c82cb8fec724ff24ea7664b28d3dc9d03.
## 

/cc @rubyist since you were the original author
/cc @technoweenie @sinbad for 👀  and 💭 s
",2813,True,en,1
1523,1,1,0,Externals,sschuberth,2016-09-13T19:27:12Z,11,1,1,0,"On Windows 10, this test was failing because the current user's home
directory was in DOS-style 8.3 short path notation in the expected Git
path, whereas the actual path was using the long path notation. Fix that
by comparing files based on Stat() instead of comparing strings.
",278,False,en,1
1522,7,8,1,Externals,sschuberth,2016-10-04T20:06:17Z,15,53,9,21,"First round of fixes to the test framework to make tests basically run on Windows. With this, the remaining failing tests are:

In _test/test-custom-transfers.sh_:

```
test: custom-transfer-upload-download ...                          FAILED
```

In _test/test-fetch-include.sh_:

```
test: fetch: include first matching file ...                       FAILED
test: fetch: include second matching file ...                      FAILED
```

Running tests in AppVeyor will be enabled in a separate PR once these tests are fixed and https://github.com/appveyor/ci/issues/1022 is deployed.
",585,True,en,5
1518,1,1,0,Externals,sschuberth,2016-09-12T21:02:52Z,1,5,1,1,"""git rev-parse --show-toplevel"" is defined to already return an absolute
path, so there is no need to convert it.
",114,False,en,0
1507,1,5,0,Externals,sschuberth,2016-09-06T17:38:10Z,11,6,1,0,"For newly initialized local repositories that are configured to track
existing LFS objects by manually creating pointer files via
git-lfs-pointer, there might be no remote configured yet. Still it should
be possible to fetch the LFS objects. Allow this by postponing the check
for a remote until it is really required.
",319,False,en,0
1506,2,11,10,Externals,sschuberth,2016-09-06T17:41:32Z,20,55,3,0,"This build the binaries and installer for now. Not running tests yet.
",70,True,en,0
1505,5,3,4,Internals,ttaylorr,2016-09-06T21:37:29Z,39,6,3,0,"This pull-request ensures Git LFS will log an error message when it encounters a fatal error using `commands.FullError`.

In versions of Git LFS prior to v1.4.0, an error message would be logged out to the console and the full error (along with command and other useful debugging information) would be logged to a file on disk, viewable by `git lfs logs`.

This pull-request ensures that the first line of an error message is always logged to the console and the stack trace and expanded debugging information are logged out to disk. This diff (contained in 1dabeb5) makes that happen:

``` diff
diff --git a/commands/commands.go b/commands/commands.go
index 6964396..ffcf1cf 100644
--- a/commands/commands.go
+++ b/commands/commands.go
@@ -85,7 +85,7 @@ func FullError(err error) {

 func errorWith(err error, fatalErrFn func(error, string, ...interface{}), errFn func(string, ...interface{})) {
        if Debugging || errors.IsFatalError(err) {
-               fatalErrFn(err, """")
+               fatalErrFn(err, ""%s"", err)
                return
        }

```

The `%s, err` format was intentionally used instead of `%s, err.Error()` since `err` could be `nil`.

To test this behavior, I first added a new [content handler](https://github.com/github/git-lfs/blob/7ccc6b5cec1f8eec1d05f8e582c8e4b825d3bcc2/test/cmd/lfstest-gitserver.go#L42-L54) to the test gitserver to [return some JSON](https://github.com/github/git-lfs/blob/7ccc6b5cec1f8eec1d05f8e582c8e4b825d3bcc2/test/cmd/lfstest-gitserver.go#L493-L501) with 503 status code and a `message` that we assert is contained in the client's output.

I used the `/storage` handler instead of the `lfsBatchHandler`, since it seemed inappropriate to change the outer `message` server error in response to the contents of a single file scoped at the batch-level.

To test that the error made its way to the output of the original `git lfs push`, I added an optional second `$msg` parameter to the `push_fail_test` function in https://github.com/github/git-lfs/commit/50ba7eb794249b6c0fee9b1baae55c449783cb51. When `$msg` is non-empty according to `[ ! -z ""$msg"" ]`, `grep` is run against the output of `git lfs push` with `$msg` as the capture expression. Since this adds some additional complexity to the `push_fail_test` function, I added some documentation to explain, but if there's a more appropriate place to make this assertion I would appreciate your thoughts 😄 

👋  Thanks in advance for the review!
## 

/cc @technoweenie @rubyist @sinbad for review
/cc @dpursehouse #1486 for 👀 
",2548,True,en,2
1504,1,13,0,Externals,sschuberth,2016-09-06T19:16:06Z,2,0,3,0,"The icons were generated from the Git LFS web page's favicon file
available at https://git-lfs.github.com/favicon.png.
",119,False,en,0
1503,1,1,0,Internals,ttaylorr,2016-09-06T19:24:06Z,5,1,1,1,"This pull-request adds some new documentation to `git-lfs-clean`'s man page to reflect that it is not a part of the user-facing plumbing commands. Instead, it points to the `git-lfs-pointer(1)` documentation in order to preview what the generated pointer data would look like for a particular object.
## 

/cc @sinbad @kingces95 @technoweenie #1501 
",350,False,en,0
1499,6,2,0,Internals,technoweenie,2016-09-01T19:04:07Z,15,12,4,0,"Old error:

``` bash
panic: Error trying to init LocalStorage: mkdir lfs: permission denied

goroutine 1 [running]:
panic(0x377740, 0xc420102920)
        /usr/local/Cellar/go/1.7/libexec/src/runtime/panic.go:500 +0x1a1
github.com/github/git-lfs/localstorage.ResolveDirs()
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/src/github.com/github/git-lfs/localstorage/currentstore.go:39 +0x4c3
github.com/github/git-lfs/commands.resolveLocalStorage(0xc420123d40, 0x5f2ae0, 0x0, 0x0)
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/src/github.com/github/git-lfs/commands/commands.go:342 +0x14
github.com/github/git-lfs/vendor/github.com/spf13/cobra.(*Command).execute(0xc420123d40, 0x5f2ae0, 0x0, 0x0, 0xc420123d40, 0x5f2ae0)
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/src/github.com/github/git-lfs/vendor/github.com/spf13/cobra/command.go:474 +0x255
github.com/github/git-lfs/vendor/github.com/spf13/cobra.(*Command).Execute(0xc4200f64e0, 0xc42004fed0, 0x1)
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/src/github.com/github/git-lfs/vendor/github.com/spf13/cobra/command.go:551 +0x380
github.com/github/git-lfs/commands.Run()
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/src/github.com/github/git-lfs/commands/commands.go:70 +0x180
main.main()
        /private/tmp/git-lfs-20160826-6787-1o15v20/git-lfs-1.4.1/git-lfs.go:33 +0x111
```

This looks scary for such a small error. How about:

``` bash
Init error: localstorage: mkdir lfs: not a directory
```

`localstorage.ResolveDirs()` now uses `errors.Wrap()` to add the ""localstorage"" context. The command `PreRun` adds the ""Init error"" context.
",1687,True,en,1
1497,1,2,0,Externals,sinbad,2016-09-01T16:25:56Z,46,16,3,0,"Came across a case recently where someone hadn't used git-lfs for a while and suddenly got errors on `git lfs install` of the form:

```
filter.lfs.clean attribute should be ""git-lfs clean --%f"" but is ""git-lfs clean %f""
```

This surprised me because I thought we had upgrade paths for our config, but turns out that was only for hooks. So rather than making them run `git lfs install --force` for something we already know about, I introduced the same concept as for hooks, a list of upgradeable values we used to use. 

While I was at this I removed the attribute upgrade path for `git-media`, since it was vague and over-general really and I don't think it's necessary any more? I can put it back if there was a specific reason it's still there but looked like a relic to me.
",780,True,en,1
1495,9,6,0,Internals,technoweenie,2016-09-01T17:25:23Z,153,339,29,1,"This is an incomplete PR that I wanted to try after reading [this conversation](https://github.com/github/git-lfs/pull/1478#discussion-diff-75845058).

Unlike the existing `RegisterSubcommand()`, `RegisterCommand()` wraps the initialization of the `*cobra.Command` with the following properties:
- `Use` - The lfs sub command name, needed by every command.
- `Run` - The function for the command.
- `PreRun` - This is the controversial part. _Most_ commands want this set.

I agree that it's better that the few commands that don't need `.git/lfs` initialized can disable the `PreRun` hook. By default though, all `RegisterCommand` callers should work.

The `bool` return value also lets commands choose if they're activated. Currently only used for experimental commands like `locks`.

If this approach is favorable, I'll update all `RegisterSubcommand()` callers, kill it, and change how `subcommandFuncs` works.
",915,True,en,0
1489,2,1,0,Internals,technoweenie,2016-08-26T21:46:28Z,2,0,2,0,"This adds `lfs.pushurl` to the safelist for `.lfsconfig` files. Fixes #1488
",76,True,en,0
1487,2,0,0,Internals,ttaylorr,2016-08-26T19:36:30Z,22,7,7,0,"/cc @technoweenie @rubyist 
",28,True,pl,0
1482,4,1,6,Internals,ttaylorr,2016-08-26T18:37:26Z,85,3,2,2,"This pull-request is a small addendum to @larsxschneider's #1454 to add tests around the `RetriableReader`.

The only behavior change in this PR is that `RetriableReader` will no longer re-wrap already retriable errors, per https://github.com/github/git-lfs/pull/1454#discussion_r76088729.
## 

/cc @technoweenie @larsxschneider for 💭  and 👀 
",349,True,en,1
1478,3,1,5,Internals,ttaylorr,2016-08-23T15:09:15Z,160,75,31,0,"This PR supports cloning into the current directory, `"".""`, a-la:

``` bash
$ git lfs clone git@github.com:foo/bar.git .
```

Previously, this was broken because an invocation to the `git-lfs clone` command would create a `localstorage` directory due to a call to the [`localstorage.ResolveDirs`](https://github.com/github/git-lfs/blob/c21de411141a7536689a63e1f82bcc02f46fdf83/localstorage/currentstore.go#L28-L47) function causing both of [these](https://github.com/github/git-lfs/blob/c21de411141a7536689a63e1f82bcc02f46fdf83/localstorage/currentstore.go#L34-L35) files to be created. The presence of those files violated a `git-clone` invariant that the clone target must be empty. That source of that call is from the `init()` function in the `lfs` package, [here](https://github.com/github/git-lfs/blob/68c0e18d05de0e60c8ce774b5b3163062b47e5a0/lfs/lfs.go#L144).

In https://github.com/github/git-lfs/commit/e447be2172b4b767089516432065003f31ccf9d2, I removed that call, and instead replaced it with a `PreRun` hook on all of our commands, except `clone`. `PreRun` hooks, as dictated by the `cobra` package will run before the actual `Run` function of the command.

In a further PR, we should definitely take a look at which commands _actually_ need to have the `localstorage` stuff initialized.
## 

/cc @technoweenie @rubyist @sinbad for review
/cc @tarka #1431 for a heads-up
",1383,True,en,2
1473,2,6,0,Externals,dpursehouse,2016-08-22T16:37:04Z,9,3,3,2,"Mention that the server implementation may optionally return status
code 507.

This does not add any specific handling of 507 in either the client or
the test server implementation. If a server returns this status code,
it will be handled by the client as a generic ""Server Error"".

See #1327 and #1438.
",304,False,en,1
1471,5,1,0,Internals,ttaylorr,2016-08-19T17:17:56Z,36,4,6,0,,0,False,en,0
1470,1,1,0,Internals,technoweenie,2016-08-19T16:16:17Z,8,10,1,0,"`fetchAndReportToChan()` can optionally receive a channel for sending `*lfs.WrappedPointer` objects. This is [used in `git lfs pull` to send files to checkout](https://github.com/github/git-lfs/blob/177984f2212a9232e1614c5ffc4e0bd55204783f/commands/command_pull.go#L41-L42).  The [checkout process](https://github.com/github/git-lfs/blob/177984f2212a9232e1614c5ffc4e0bd55204783f/commands/command_checkout.go#L74-L80) processes files as it reads them off the channel.

This PR renames `skippedAndUniqPointers()` to `readyAndMissingPointers()`, and changes it so the only pointers that are considered ""ready"" are those that already exist in `.git/lfs/objects`. 
",660,True,en,0
1469,3,1,0,Internals,ttaylorr,2016-08-19T16:36:19Z,19,0,1,0,"cc @technoweenie 
",18,True,pl,0
1467,1,1,0,Externals,dpursehouse,2016-08-19T14:04:44Z,4,6,2,0,"to make it consistent with the others

The others don't begin with ""Returned if "".
",83,True,en,0
1466,12,5,2,Internals,technoweenie,2016-08-19T20:13:52Z,342,386,32,0,"This renames the `github/git-lfs/errutil` package to `github/git-lfs/errors`, and encourages its use in the rest of the codebase instead of `errors` or `github.com/pkg/errors`.

This is still (mostly) API compatible with both, and means we don't have to import multiple error packages in Git LFS itself.
",304,True,en,5
1463,6,2,0,Internals,ttaylorr,2016-08-18T17:05:00Z,78,170,7,0,"This pull-request uses the `github.com/pkg/errors` package as a replacement for the old [`wrappedError`](https://github.com/github/git-lfs/blob/ac5a532665dc35c5c108726e5632e1d288224b64/errutil/errors.go#L300-L330) type that previously existed in the `errutil` package.

`github.com/pkg/errors` gives us the same sort of wrapping that we previously enjoyed, but it puts the onus on a third-party dependency. We still have to keep the `wrappedError` type around for now, since `pkg/errors` doesn't support any sort of `context map[string]interface{}`, but my plan is to remove that type in a future PR by either:

a. Dropping it (+ support for contexts) entirely, or:
b. Only using it where we _need_ contextual data
## 

/cc @technoweenie 
",739,True,en,5
1462,4,1,2,Internals,technoweenie,2016-08-18T15:30:23Z,39,58,7,0,"@ttaylorr: Once I fixed `errorWrapper` to embed an `errorWithCause`, it was just a matter of fixing up some error messages:
- the http errors are being wrapped with no `message`. Since `errorWrapper` needs an `errorWithCause`, I added a default `""LFS""` context message.
- Fixed a few spots during lfs pointer parsing where a `nil` error was being passed. I think the new pointer error messages are better.

Those two issues are because `errors.Wrap()` is fundamentally different from the current error wrapper:
## OLD

``` golang
err := errors.New(""fatal error writing to disk blah blah"")
wrapped := newWrappedError(err, ""error writing to .git/lfs/objects"")
```

It currently replaces the error message with a message more applicable to LFS. Seeing LFS die with some internal io error or whatever is not helpful. Seeing something like this was my original intention:

```
error writing to .git/lfs/objects
fatal error writing to disk blah blah
```

For whatever dumb reason, the old pointer code passed a nil error, resulting in a message like:

```
Not a valid Git LFS pointer file.
<nil> # just a blank space, but this is where an inner error should be
```
## NEW

The new `errors.Wrap()` adds the context as a prefix. So, the pointer errors in my failing test looked like this:

```
Not a valid Git LFS pointer file.: Error
```

At first I thought something was weirdly reversing the string. Instead, I sent real error messages, and shortened the new error prefix in a09c4642b4b730fe179e58eb57da65aff39c9e89.
## TODO

I think this is good to merge into `errors-next`. I think we should also review all the errors and clean up the other spots that are passing `nil` errors.

Also, probably always import `github.com/pkg/errors` instead of just `errors` for consistency.
",1772,False,en,5
1461,4,2,3,Internals,technoweenie,2016-08-18T15:42:15Z,53,15,9,0,"/cc #1212
",10,True,en,0
1460,9,0,0,Internals,technoweenie,2016-08-17T21:48:44Z,183,26,8,0,"Fixing a merge conflict in #1177.  Otherwise, ready to go cap'n :metal:
",72,True,en,0
1459,2,0,1,Internals,ttaylorr,2016-08-17T22:24:24Z,1288,7,15,0,"This PR vendors the `github.com/pkg/errors` package for use in the upcoming `error` package refactoring :metal: 
## 

/cc @technoweenie
",136,False,en,4
1458,7,2,0,Internals,technoweenie,2016-08-18T16:29:32Z,131,33,3,1,"Currently just reproduces the bug described in #1437 with a test.
",66,True,en,1
1455,1,1,0,Externals,ralfthewise,2016-08-16T19:23:12Z,3,3,1,0,"Previously the docs indicated that pattern matching was per gitignore, but actually it is done per golang's `filepath.Match()`.  Ideally it will eventually mirror gitignore, but until then the docs should be corrected.

This will help with user frustration regarding https://github.com/github/git-lfs/issues/912
",312,True,en,0
1454,3,10,7,Externals,larsxschneider,2016-08-24T16:16:02Z,25,3,2,7,"A file download can fail for multiple reasons, e.g. due to various
network errors. Use the `TransferQueue` retry mechansim to try it again.

Possible errors due to spotty network connections:
https://github.com/golang/go/blob/64214792e214bbacb8c00ffea92a7131e30fa59e/src/io/io.go#L26-L47
",288,False,en,0
1453,4,1,0,Internals,technoweenie,2016-08-17T17:13:53Z,27,15,3,0,"This is an extension to #1445 which also cleans up some of the duplicate logic from `commands.ExitWithError()`.  /cc @dpursehouse
",130,True,en,0
1452,3,2,2,Internals,technoweenie,2016-08-16T18:01:44Z,66,12,7,0,"This lets servers set an `Authenticated` property on objects, that the client uses to determine if it needs to call `git-credential` or not. This is a forward compatible API change, and won't affect existing implementations.

When a client hits the batch api, it sends a payload like this:

``` js
{
  ""operation"": ""download"",
  ""objects"": [{""oid"": ""SOMEOID"", ""size"": 123}]
}
```

A typical server response returns a URL to transfer the object with any values for the HTTP request header.

``` js
{""objects"": [{
  ""oid"": ""SOMEOID"",
  ""size"": 123,
  ""actions"": {
    ""download"": {
      ""href"": ""https://download-this-object"",
      ""header"": {
        ""Authorization"": ""Basic ...""
      }
    }
  }
}
```

Git LFS will use `git-credential` to find the user and pass for that download unless the `Authorization` header is set. What if the service uses a non-standard header, or what if the file requires no authentication? This is where the `authenticated` property comes in:

``` js
{""objects"": [{
  ""oid"": ""SOMEOID"",
  ""size"": 123,
  ""authenticated"": false,
  ""actions"": {
    ""download"": {
      ""href"": ""https://download-this-object"",
      ""header"": {
        ""Custom-Token"": ""Basic ...""
      }
    }
  }
}
```
",1216,True,en,2
1451,5,1,4,Internals,technoweenie,2016-08-16T19:08:55Z,146,2,7,0,"This adds support for pushing and pulling LFS objects with a raw remote url. This was originally submitting in #1085, and updated for the current master branch. This also adds tests.
",183,True,en,4
1450,5,3,0,Internals,ttaylorr,2016-08-16T17:33:12Z,176,120,12,0,"This pull-request introduces a wrapped `gitEnvironment` to support the legacy behavior found in `loadGitConfig` in order to make #1436 possible.
## 

In order to support lazily loading the values stored in a user's `.gitconfig`,
we must wait until calling `*config.Configuration.loadGitConfig()` until it is
_absolutely necessary_.

To accomplish this, it was proposed that we introduce a wrapped variant of the
`*Environment` type, only for interacting with the `GitFetcher` that was
capable of supporting such beahvior.

As such, a new implementation of the `Environment` type must be defined. Since
previously there only existed the concrete type `*Environment`, this commit
demotes that down to `*enviornment`, and introduces the interface
`Environment`, which it implements.
## 

To wrap the old behavior found in `*config.Configuration.loadGitConfig`, a
`*gitEnvironment` implementation was introduced to wrap the behavior of another
Environment wholesale while at the same time prepending a call to
`loadGitConfig()`.

It should be noted that in order to preserve legacy behavior with using certain
member variables in `*config.Configuration`, there is a circular dependency
between the two types.
## 

/cc @technoweenie 
",1229,False,en,1
1445,1,7,3,Externals,dpursehouse,2016-08-17T17:13:54Z,7,2,1,4,"Change-Id: Iff591518853b1c5c229b676d08d8f914f1eb6f62
Signed-off-by: David Pursehouse dpursehouse@collab.net
",108,False,en,0
1443,4,1,2,Internals,technoweenie,2016-08-15T16:35:06Z,101,0,3,2,"Rewrite of #1117 after the config refactoring in #1425. There's no `readGitInsteadOfConfig()` anymore to hook into anymore.

We can't easily support `pushinsteadof` without bigger changes. `config.NewEndpointWithConfig()` doesn't know if the request is a push or pull.
",269,True,en,1
1441,2,2,0,Internals,ttaylorr,2016-08-16T16:21:48Z,1,1,1,3,"As pointed out by @ericfrederich in #1439, the `Event` field of the custom transfer ""init request"" is encoded as `""Event"":`, not `""event"":` as it should be.

Running the custom transfer integration tests confirm that this is OK to do 👍 

I'm also thinking that per @technoweenie's suggestion, we backport this to our `release-1.3` branch and get this out as a part of the `v1.3.2` release.
## 

/cc @technoweenie @sinbad @ericfrederich
",439,True,en,0
1438,9,6,1,Internals,technoweenie,2016-08-19T16:38:20Z,22,2,1,7,"Triaging old issues, and adding to the roadmap...
",50,True,en,0
1436,3,3,0,Internals,ttaylorr,2016-08-16T17:16:38Z,29,35,11,5,"🚧  This pull-request removes legacy methods from the `*config.Configuration` object such as:

|  | Was | Becomes |
| --- | :-- | :-- |
| ✅ | `*config.Configuration.GetEnv` | `cfg.Os.Get` |
| ✅ | `*config.Configuration.GetEnvBool` | `cfg.Os.Bool` |
| ⬜ | `*config.Configuration.GitConfig` | `cfg.Git.Get` |
| ⬜ | `*config.Configuration.GitConfigInt` | `cfg.Git.Int` |
| ⬜ | `*config.Configuration.GitConfigBool` | `cfg.Git.Bool` |
## 
",447,True,en,0
1435,2,2,0,Internals,ttaylorr,2016-08-10T19:54:14Z,0,28,1,0,"This pull-request removes the mutable `SetConfig` and `ResetConfig` methods (along with the `origConfig` field, which was a collaborator) from the `*config.Configuration` type. They are no longer used anywhere throughout the LFS codebase 🎉 
## 

/cc @technoweenie @rubyist @sinbad 
",285,False,en,0
1434,6,4,0,Internals,technoweenie,2016-08-11T22:45:22Z,410,369,29,1,"I thought changing `lfs.Environ()` to accept a `*config.Configuration` and `*transfer.Manifest` (instead of using global values) would be easy.  However, I wanted a spot for various ""global"" config objects to be created for all commands, so I picked `commands.Run()`. I may look for a way to pass some kind of context to each command and remove those too.

I built this PR off #1430, so view this diff instead: [transfer-manifest...command-var-scope](https://github.com/github/git-lfs/compare/transfer-manifest...command-var-scope)
",532,True,en,0
1430,5,3,6,Internals,technoweenie,2016-08-10T18:53:08Z,262,295,14,0,"This extracts the configured transfer adapters to an explicit `Manifest` type, instead of storing them on the go package itself. We get a few benefits here:
- Tests operate on immutable `*config.Configuration` and `*transfer.Manifest` objects. No resetting global state.
- The transfer configs are only loaded as needed.

I made sure that a manifest is loaded at most once per `git-lfs` command.
",396,False,en,2
1429,2,2,0,Internals,ttaylorr,2016-08-09T22:15:28Z,19,20,1,0,"❗ The relevant diff is contained in: [`config-next-load-unmarshal..config-next-fetch-unmarshal`](https://github.com/github/git-lfs/compare/config-next-load-unmarshal...config-next-fetch-unmarshal).
## 

This pull request uses the new `Unmarshal(v interface{}) error` function to fill out the result of calling `FetchPruneConfig`.

It adds the relevant `git:""lfs.foo""` tags to the `FetchPruneConfig` type definition, and sets the defaults during the struct initialization. Currently, it `panic`s on any errors being returned from `Unmarshal`, but those errors are all internal, and the presence of one would indicate a state wherein LFS is not able to function properly (thus they are panic-able).
## 

/cc @technoweenie @rubyist @sinbad 
",740,False,en,0
1428,1,2,0,Internals,ttaylorr,2016-08-09T22:13:49Z,2,0,1,0,"This pull request ensures that the `.gitconfig` is loaded before calling `Unmarshal()`.

Previously, the `.gitconfig` would go unloaded causing [this](https://github.com/github/git-lfs/blob/1845c0bf9c3b77c52484ee4e7f9b15f7eab6edce/config/config.go#L196) line to return a `nil` `*Environment`, causing `Unmarshal` to skip its operation on that field per [this](https://github.com/github/git-lfs/blob/1845c0bf9c3b77c52484ee4e7f9b15f7eab6edce/config/config.go#L151-L153) block.

The reason that this wasn't caught before is that it was only being tested by `config.NewFrom()`, which uses the `mapFetcher` implementation, instead of doing actual `.gitconfig` parsing. I don't think it's needed to add a test guarding this behavior, since the `New` constructor should be simplified shortly.
## 

/cc @technoweenie @rubyist @sinbad 
",827,True,en,0
1427,7,2,0,Internals,ttaylorr,2016-08-10T19:18:40Z,124,115,16,0,"This pull request removes mutable `.gitconfig` behavior from the `api`, `lfs`, and `httputil` packages. Most of the work involved here is removing calls to `SetConfig` and `ResetConfig`, and also threading an instance of `*config.Configuration` through the `api` package instead of falling back to the `config.Config` global.

To retain the same behavior outside of the tests, the `api` package did gain a few references to `config.Config`, but this is a temporary measure until we remove that package entirely for v2.0. Alternatively, package `api` could own its own private instance of `*config.Configuration`, but I think that's outside the scope of this PR.

Next (and last!) up is the `transfer` package. This requires a little bit more of a fundamental change than just removing calls. The `transfer` package maintains package-global state that is involved with the `config.Config` singleton, so splitting that up is going to be tricky, but doable.
## 

/cc @technoweenie @rubyist @sinbad 
",996,True,en,4
1426,10,2,0,Internals,ttaylorr,2016-08-09T16:17:34Z,648,465,10,0,"❗ The relevant diff is contained in [`config-next-prune..config-next-unmarshalling`](https://github.com/github/git-lfs/compare/config-next-prune...config-next-unmarshalling).
## 

Calling `Unmarshal` on a struct-pointer will inspect each of that struct's
field's tags, and unmarshal configuration data into said field according to
three parameters:
- The environment specified, either `git` or `os`.
- The name of the key given (in the tag).
- The type of the field (either `string`, `int`, or `bool`).

If there is already a non-zero value stored in the field, then that field will
be skipped, allowing constructors to set up default behavior.
## 

/cc @technoweenie @rubyist @sinbad
",687,False,en,2
1423,1,4,0,Internals,ttaylorr,2016-08-09T16:17:06Z,34,79,3,0,"This pull-request updates the `FetchPruneConfig` type to be loaded from the new Git config parsing hotness.
## 

/cc @technoweenie @rubyist @sinbad 
",149,False,en,0
1420,10,2,0,Internals,technoweenie,2016-08-09T16:17:13Z,440,469,10,3,"This pull-request introduces a `Fetcher` implementation for `.gitconfig`-related interactions that occur in the `config.Configuration` type.

Pulling out the `.gitconfig` stuff is a bit trickier than the OS environment, because most of the state that `config.Configuration` keeps track of is created while parsing is going on, and is deeply coupled to this logic (see: [here](https://github.com/github/git-lfs/blob/49bf4d5178fe7fab99cec7f26eaa434eeb152bd9/config/config.go#L518-L594)).

To make this PR small, and to make it possible to do small refactorings in the future, the `ReadConfig` function, which produces the `.gitconfig` Fetcher, also returns all of the other state that the `config.Configuration` type needs to keep track of (see: [here](https://github.com/github/git-lfs/blob/7bcc69bf583aa1dbe010b0bc09b6f7f56b4cb2c5/config/git_fetcher.go#L31)).

Over time, this function should become simpler as we introduce stronger types that keep track of this state, thereby decreasing the length of that function's signature. Once the signature is simple, (i.e., it only returns a `*GitFetcher`, then it will be safe to add tests.)

The other notable hack that this PR introduces is some legacy support around the `ClearConfig` and `ResetConfig` functions (see: [here](https://github.com/github/git-lfs/blob/7bcc69bf583aa1dbe010b0bc09b6f7f56b4cb2c5/config/config.go#L475-L478), and [here](https://github.com/github/git-lfs/blob/7bcc69bf583aa1dbe010b0bc09b6f7f56b4cb2c5/config/config.go#L485-L487)). This was done to keep mutability out of the `GitFetcher` implementation, while still supporting those legacy methods. The next step is to remove those methods, thereby eradicating all mutability from the `config` package.
## 

/cc @technoweenie @rubyist @sinbad @larsxschneider 
",1782,True,en,2
1419,4,4,2,Internals,ttaylorr,2016-08-05T15:19:30Z,254,130,11,0,"Previously, to fetch data out of the `*config.Configuration` type, a reference
to a `Fetcher` was used, a-la:

``` go
cfg.Env.Get(...)
```

This is quite convenient, however, it forces the LFS client to implement
several methods more than once. Consider the interface:

``` go
type Fetcher interface {
        Get(key string) (val string)

        Bool(key string, def bool) (val bool)
        // et. al.
}
```

In order to return typed information from a configuration instance, _each_
`Fetcher` must implement its own `N` methods for `Int`, `Bool`, etc.

To remedy this, the `Environment` type was introduced. It instead _has_ a
`Fetcher`, and defines its own type conversions, like so:

``` go
type Environment struct {
        f Fetcher
}

func (e *Environment) Bool(key string, def bool) (val bool) { }
func (e *Environment) Int(key string, def int)   (val int) { }

// et. al.
```

Now, the `config.Configuration` type holds a reference to an `Environment`, and
all type conversion methods are defined only once, saving time, and enforcing
consistency across multiple sources.

---

/cc @technoweenie @sinbad @rubyist @larsxschneider 
",1141,False,en,5
1416,5,2,0,Internals,ttaylorr,2016-08-04T16:49:01Z,213,210,8,0,"This pull-request removes all instances of `config.Config.Setenv` and `config.config.SetAllEnv`. References to `SetConfig` still exist, but those are `.gitconfig` related, meaning they'll be addressed in a future pull-request.

There is also now considerably more repetition in the `auth/ssh_test.go` file. It's a good candidate for table-style tests, but I also appreciate its clarity right now.

This completes step 2 of config-next:

> Update tests to not use mutable behavior like Set and SetAll.

---

/cc @technoweenie @rubyist @sinbad @larsxschneider
",558,True,en,5
1415,12,4,7,Internals,ttaylorr,2016-08-04T16:49:14Z,313,208,9,0,"This pull request introduces types `Fetcher`, `*EnvFetcher` and integrates them into the `config.Config` type.

In doing so, we are phasing out behavior like:

``` go
var cfg *config.Config

cfg.GetenvBool(""foo"", true)
```

and replacing it with

``` go
var cfg *config.Config

cfg.Env.Bool(""foo"", true)
```

This is the first in a series of many pull requests which will be focused on making the `*config.Config` type oriented towards data-fetching, and less domain-specific. Eventually, all of the domain-specific knowledge will disappear from the `config` package. In order to get there, however, we must first introduce a set of well factored types that will make this sort of data-fetching easy. I have described those types in https://github.com/github/git-lfs/commit/e32fabe37fc150b21a5d2d7594a5300c1388c5cb.

Timeline-wise, I am thinking:
1. Introduce `Fetcher`, implement `EnvFetcher`, and integrate with `*config.Config`.
2. Update tests to not use mutable behavior like `Set` and `SetAll`.
3. Refactor `Fetcher` type as described in https://github.com/github/git-lfs/commit/e32fabe37fc150b21a5d2d7594a5300c1388c5cb.
4. Implement the `GitFetcher`.
5. Piece by piece, remove legacy calls to `GetenvBool`, replacing them with `.Env.Bool` (and etc).
6. Piece by piece, remove domain knowledge from the `*config.Config` type, in favor of the methodology described in https://github.com/github/git-lfs/pull/1390#issuecomment-236068550.

For a more in-depth description, please read the commit bodies of e32fabe37fc150b21a5d2d7594a5300c1388c5cb, b2272a8c165877dc31bf2eaf8f7b9c06cd139315, and f6e8c528abab7889c893274e97202f3fdf325fe1.

---

/cc @technoweenie @rubyist @sinbad @larsxschneider 
",1696,True,en,5
1412,1,1,0,Internals,ttaylorr,2016-08-03T19:56:57Z,49,30,1,0,"Our current ROADMAP is a list of bullet points, which makes it hard to see what's up-next, being worked on, or has priority. This changes that.

I converted our ROADMAP.md file to contain Markdown tables which have emoji representing their status. The statuses that I added are:
- :ship: - Completed
- :construction: - In Progress
- :soon: - Up next
- :no_entry_sign: - Blocked

I also proposed a new method of keeping track of the ROADMAP wherein we keep completed items on the ROADMAP until we release a version of LFS, to create an opportunity to prune and discuss the ROADMAP after each release.

I'm curious to hear thoughts on these emoji, the tables, or the process. Thanks! 👋 
",688,True,en,0
1411,6,0,2,Internals,technoweenie,2016-08-02T16:58:18Z,461,281,10,0,"This uses a `pflag.Flag`'s `Changed` property to determine if the `--include` or `--exclude` flags are empty or omitted. I'm not convinced using `*string` is any better than setting the default flag value to some magic string like `OPTIONAL`. It does remove any possibility of clashing with a directory in a user's repository, I suppose.

I also ran into some failures in large `test-fetch.sh` tests that run `git lfs fetch` multiple times. Those instances were really difficult to debug, so I split a couple of them up into separate files.

Fixes #1249
",554,True,en,5
1409,4,0,3,Internals,ttaylorr,2016-08-02T15:57:08Z,78,4,4,0,"This commit gives the `lfs.Hook` knowledge of the new `core.hooksPath`
configuration value that was introduce in Git 2.9.0.

When `core.HooksPath` is found in the Git configuration AND is supported (i.e.,
installed Git binary has a version greater than or equal to ""2.9.0""), `git-lfs
install` will place new hooks in that directory. If the `core.hooksPath` is
specified, but the installed verison of Git does NOT support it, then it will
be ignored and installed in `.git/hooks` as per usual.

To test this behavior, two new shell tests were added:
- One that runs on Git >= 2.9.0, and tests that `core.hooksPath` is respected
- One that runs on Git < 2.9.0, and tests that `core.hooksPath` is ignored

Unfortunately, our current testing framework does not support skipping
individual tests, only skipping entire files, so two new shell test files were
added.

Resolves github/git-lfs#1407.

---

/cc @technoweenie 
",916,False,en,2
1405,1,1,4,Externals,dakotahawkins,2016-07-28T20:56:14Z,7,3,1,0,"New section (Branching strategy). This could be filled out a bit but I
don't know enough about your workflow to write it up with any more detail.

Explicitly mention master in the PR section.
",192,False,en,0
1404,1,3,0,Externals,dakotahawkins,2016-08-01T18:42:42Z,58,40,2,3,"Corresponding issue: #1403

appendRootCAsForHostFromGitconfig() modified to check hosts with and without a trailing slash.

Cert unit tests made ""table driven"" and extended to cover this case.
",193,True,en,1
1400,2,2,0,Internals,technoweenie,2016-07-27T22:42:05Z,5,2,1,0,"I've been baffled by the various issues about `git update-index` failing with no reporting. Then it dawned on me that `CombinedOutput()` is the culprit. The [implementation](https://golang.org/src/os/exec/exec.go?s=11924:11970#L433) clearly shows that the stdout and stderr on the command aren't captured until `CombinedOutput()` is called. It's designed for situations where you want to run a simple command and capture it's output in a single line.
",451,True,en,0
1399,1,2,0,Externals,sinbad,2016-07-27T15:50:02Z,1,1,1,0,"Tiny tweak to tracing, makes custom adapters not add newlines everywhere when GIT_TRACE=1
",90,True,en,0
1398,6,2,1,Internals,technoweenie,2016-07-27T19:45:13Z,34,21,4,0,"This updates the debian and rpm build scripts to go with https://github.com/andyneff/git-lfs_dockers/pull/3.

/cc @andyneff 
",125,True,en,1
1397,4,2,0,Externals,sinbad,2016-07-27T13:53:30Z,102,0,3,0,"I found this useful when debugging transfers, above and beyond just showing the booleans or having to dig into the actual JSON that was sent. 

@technoweenie would be great if this could make it into 1.3 but no big deal if not.
",228,True,en,2
1394,1,1,0,Externals,dakotahawkins,2016-07-25T18:27:28Z,1,1,1,0,"I'm not sure what the convention is here. Version 1.3.0 is everywhere in this branch except in version.go.
",107,True,en,0
1390,10,12,0,Internals,technoweenie,2016-08-01T19:01:07Z,378,401,41,10,"I want to live in a world where most of the LFS functions don't use a global `config.Config` value. The `commands` package is the only exception, so I created a `commands.Config` value to use.

This is a small first step towards removing `config.Config` around the app.
",270,True,en,9
1389,12,12,2,Internals,technoweenie,2016-07-26T15:30:03Z,87,34,11,4,"We have old versions of GH Enterprise that still support only the v1 Batch API.  This gives us a way to let customers use Git LFS v1.3 until their servers are updated.

/cc @sinbad
",181,True,en,5
1388,10,2,8,Internals,ttaylorr,2016-07-26T15:54:55Z,66,4,6,4,"This PR bumps the version of Git LFS to 1.3.0, and updates the release notes accordingly.
",90,True,en,0
1386,3,0,2,Internals,ttaylorr,2016-07-21T19:27:12Z,63,20,8,0,"To prepare for the upcoming release of Git LFS v1.3, the `git-lfs lock` and
`git-lfs locks` commands are now hidden behind a enviornment variable
`GITLFSLOCKSENABLED`. Since most (all?) implementations of LFS do not yet
support this new locking API, it makes sense to allow users to experiment with
the command while at the same time, not making it a ""full"" part of the release.

If users wish to run any `git-lfs lock{,s}` command, they may do so according
to the following:

```
$ GITLFSLOCKSEANBLED=1 git lfs lock <flags> [args]
$ GITLFSLOCKSEANBLED=1 git lfs locks <flags> [args]
```

This commit, when applied, adds two new things:
1. The `isCommandEnabled(cmd string) bool` func in the commands package. This
   new func checks the OS's enviornment variables and determines whether or not
   a command is ""enabled"".
2. Updates the `lock` and `locks` tests to use the
   GITLFSLOCKSENABLED=1 flag such that they are able to run.

Since the `isCommandEnabled` func defaults to ""false"", it should only guard
commands which are deemed ""experimental"", as noted in the godoc.

---

/cc @technoweenie @rubyist @sinbad @larsxschneider 
",1134,False,en,4
1384,1,2,0,Externals,andyneff,2016-07-20T21:31:05Z,1,0,1,0,"I think this is all that's needed to make that packages show up for Linux Mint Sarah (18)

@technoweenie
",105,True,en,0
1379,2,3,8,Externals,VladimirKhvostov,2016-07-18T20:04:33Z,66,7,2,0,"GetAuthType method in https://github.com/github/git-lfs/blob/master/httputil/request.go#L174 only takes first WWW-Authenticate header into account. If server sends the following headers:

```
WWW-Authenticate: Bearer
WWW-Authenticate: Negotiate
WWW-Authenticate: NTLM
```

the code returns ""basic"", which is definitely not correct in this case.

This change fixes this issue.  With this change we will also handle Negotiate authentication.

Bug: https://github.com/github/git-lfs/issues/1377
",492,True,en,1
1375,10,4,0,Internals,technoweenie,2016-07-17T22:08:51Z,96,74,8,2,"Found an intermittent test issue running `script/cibuild` on mac. While investigating, I noticed that `GIT_LFS_TEST_MAXPROCS` isn't even used now. The intermittent issue goes away when `GIT_LFS_TEST_MAXPROCS=1` too.
",216,True,en,5
1374,8,4,10,Externals,sinbad,2016-07-17T22:16:21Z,20,7,4,2,"A bunch of fixes on Windows, details in the individual commits. 

Integration tests all appear OK but require some user interaction to cancel GUI auth prompts which the Windows version of OpenSSH seems to be throwing up.
",221,True,en,1
1373,3,1,5,Externals,sinbad,2016-07-15T10:55:46Z,109,0,2,0,"Fixes #1172

git 2.9+ preserves the config settings which disable the LFS filters in submodules so any LFS files will be pointers. This makes it more optimal (previous versions will suppress these settings so the smudge filter will be used in submodules) but we must run ""git lfs pull"" to update the submodule working copies.

/cc @larsxschneider 
",348,True,en,1
1372,1,4,0,Externals,larsxschneider,2016-07-14T19:50:57Z,1,2,1,0,"The Git-core 'master' branch tracks the commits that should go into the next release (see https://github.com/git/git/blob/master/Documentation/gitworkflows.txt). 

Run Git-LFS tests against a build of the Git-core 'master' branch and require a successful pass.
",261,True,en,0
1371,6,3,0,Internals,ttaylorr,2016-07-14T19:50:46Z,70,24,6,1,"This pull-request rejects pushes with actions that have size less than zero bytes, as according to the spec changes.
",117,True,en,2
1369,2,6,3,Internals,ttaylorr,2016-07-13T21:22:42Z,1,1,1,0,"With the new release of Git, version 2.9.1, our ""pull zero len file"" test is
broken. @larsxschneider was the first to point this out in github/git-lfs#1363.

The cause of this problem is that `git-status` changed to print ""working tree
clean"", instead of ""working directory clean"" when running in a clean working
tree. Though this is more correct, it still broke our tests :-).

This commit changes the `grep` assertion to match the new behavior of
`git-status`.

The relevant change from git/git is here: git/git@2a0e6cd.

Closes: github/git-lfs#1363.

---

/cc @larsxschneider @technoweenie @rubyist @sinbad 
",611,False,en,1
1367,46,11,25,Externals,sinbad,2016-07-20T16:03:12Z,1377,115,26,7,"This PR allow external processes to act as relays for uploads and downloads, allowing anyone to implement custom transfer techniques of their choosing without cluttering the core with N supported methods.

LFS talks to the process over stdin/stdout with a simple linewise JSON protocol, with content being exchanged by file path (process and lfs must be on the same machine). The process can then talk to the server however it likes. 

The name of the custom adapter must be agreed between the client config and server, since the adapter to use will be negotiated at the API stage, and may change the information the API returns in the `actions` section. The content of the`upload` and `download` actions from the API are passed to the custom adapter so it can use that information as it sees fit.

This PR also contains a reference implementation of a custom adapter process, `test/cmd/lfstest-customadapter.go` which is used in the integration tests. It just uses the same HTTP protocol under the hood to keep things simple and to re-use the `lfstest-gitserver`, but demonstrates how the process comms work and how progress is reported etc. Other implementations can transfer data however they like.
",1202,True,en,6
1361,1,5,0,Externals,larsxschneider,2016-07-11T19:35:12Z,13,0,1,0,"The Git source version is defined by the variables GIT_SOURCE_REPO and
GIT_SOURCE_BRANCH (which can also be a Git hash). The Git source is
checked out, compiled, and installed on the Travis CI Linux machine.
Afterwards all Git-LFS tests are executed against the this Git version.

This setup helps to test features that depend on changes in the
development branches of Git and Git-LFS.
",386,False,en,0
1360,1,3,0,Externals,jasperla,2016-07-11T18:26:18Z,8,0,1,0,"This effectively allows for building git-lfs on OpenBSD.
",57,True,en,0
1359,7,4,3,Internals,technoweenie,2016-07-14T19:13:39Z,21,9,1,5,"Fixes https://github.com/github/git-lfs/issues/1318 by using `--stdin`. Hat tip to @alex-davidson for the idea. It doesn't work with the `--not` flag, so it now passes SHAs in with a `^` prefix.
",195,True,en,0
1358,16,8,2,Internals,technoweenie,2016-07-21T17:34:53Z,250,1,4,12,"This updates #1173 with the latest master. Since that PR, a lot of subpackages have been split out, and we've switched assertion libraries. 

@jonmagic @LizzHale: I also changed the main `ProxyFromGitConfigOrEnvironment()` function from #1173 for these reasons:
1. `proxyFromGitConfigOrEnvironment()` is coupled to the global `Config` value. I updated the function to accept only a `*config.Configuration` argument, and return a `func(*http.Request) (*url.URL, error)`. That cleaned up the test setup for `TestProxyFromGitConfig` a bit.
2. It returns a valid url OR error from `http.ProxyFromEnvironment` now. I didn't want to drop a potential error if users have a bad HTTPS_PROXY value, but a good git `http.proxy` value.
3. The end of the function returns `nil` now, explicitly.

Unfortunately, I couldn't test the environment, because of [how `http.ProxyFromEnvironment` is implemented](https://golang.org/src/net/http/transport.go?s=7918:7975#L202). It reads from the env the _first_ time that function is called. Calling `os.Setenv` doesn't affect it.

However, I'm thinking about pulling all that code into Git LFS. There are a few internal functions that would be useful for proxy values specified in the git config, such as `NO_PROXY` handling.
",1254,True,en,1
1352,1,4,0,Externals,sinbad,2016-07-05T16:33:09Z,3,43,3,0,"Fixes #1334
Reverts github/git-lfs#1262

Reverting for possible re-submission later. The reasons are:
1. Failures in the test are causing other subsequent PRs to fail. The reason is that skipping the `update-index` is unreliable at creating a clean git state, because the index cache may be out of date if the timestamp of files changes during checkout. Depending on the exact timing, the version of git, and the file system, precision issues can result in a non-clean status without `update-index`.
2. I think the flag `--unstaged` is misleading and the documentation ""Do not add files to the index, keeping them unstaged."" is incorrect. `checkout` never added anything to the index, it only made sure the index cache was not out of date.

If the intention is to save the expense of calling `update-index` then perhaps this feature can come back later in the form of a `--no-update-index` flag or something, with a more accurate description of what it does; including mentioning that although it's faster, it might prevent the state returning to clean correctly in some cases.
",1078,False,en,1
1350,13,6,1,Internals,ttaylorr,2016-07-06T14:30:17Z,156,13,6,1,"This pull request eagerly retries transfers that come back with expired actions, per https://github.com/github/git-lfs/issues/1345.

This is still a ""work-in-progress"", as I'm not 100% certain that I've implemented this in the right place. I followed the upload from `commands/command_push.go`, into the LFS code and the transfer code, into the `handleTransferResult`, which I think is where we want to be.

Just in case, I've left some `// NOTE`s throughout my code, which I would very much appreciate the validation of from any potential reviewers (/cc @sinbad).

Pending that validation, I'll go ahead and implement a change in the test server to validate that this behavior is used correctly and that requests are indeed retried. Since that component of the test server touches a good portion of our tests, I wanted to make sure that my fix is correct before going in and modifying a critical path in the test server.
",922,True,en,3
1349,3,3,0,Internals,ttaylorr,2016-07-05T22:09:18Z,11,3,1,0,"This pull-request introduces an additional safety check around the `requireStdin` function of the `commands` package as seen [here](https://github.com/github/git-lfs/blob/79bedebb2536485317ed5470d4e6d72cdc92d0c4/commands/commands.go#L116).

As reported in https://github.com/github/git-lfs/issues/1347, the function was panicking when trying to call Mode on a nil `os.FileInfo`. Since `os.File.Stat` is guaranteed to return a non-nil value so long as no error is present, a sanity check was added to catch and log these errors. If no error was present, the bitmask is applied and checked as normal.

An aside: I added the error logging in my second commit, whereas it was previously simply discarding the error as before. If we want to continue to discard the blanked error from `os.Stdin.Stat()`, then we can simply not apply the second commit contained in this PR.
",867,True,en,0
1346,8,5,4,Internals,ttaylorr,2016-07-05T22:34:27Z,104,10,4,4,,0,False,en,2
1344,7,16,6,Internals,ttaylorr,2016-07-06T15:22:49Z,89,10,3,4,"This pull request introduces three new flags into the `git lfs track` command: `--no-touch`, `--verbose`, and `--dry-run`. It also updates the man pages and adds test for this new behavior accordingly.
- Specifying `--no-touch` will cause LFS to skip modifying the file's `atime` and `mtime`, leaving the file unmodified from the filesystem's perspective.
- Specifying `--verbose` will cause LFS to print the name of each file that it touches, so that it's more apparent what `git lfs touch` is doing when acting upon a large glob of files (see https://github.com/github/git-lfs/issues/1304).
- Specifying `--dry-run` will cause `git lfs track` to log out all of the actions it would normally preform (as given with `git lfs track --verbose`), without actually modifying files or `.gitattributes` on disk.
",806,False,en,1
1335,1,1,0,Internals,ttaylorr,2016-06-29T18:47:55Z,10,8,1,0,"The `git-lfs-logs.1` man-page incorrectly listed the `clear` and `boomtown` subcommands of `git lfs logs` as `--options` rather than subcommands.

Closes github/git-lfs#1311
",174,True,en,0
1332,1,1,0,Internals,ttaylorr,2016-06-28T23:03:05Z,3,3,1,0,":wave:
",7,True,en,0
1331,1,1,1,Internals,ttaylorr,2016-06-27T16:20:09Z,45,11,5,0,"This pull request applies the commit 79bedebb2536485317ed5470d4e6d72cdc92d0c4 onto `master`, thereby bumping the version to `1.2.1`.
",133,True,en,0
1324,1,1,0,Externals,omonnier,2016-06-23T16:54:07Z,1,1,1,0,"As described in the test/README.md, it is possible to
pass extra args to the script/test, like for example:
  $ script/test lfs -run TestSuccessStatus -v
Those args must be propagated to the 'go test' script.

Signed-off-by: Olivier Monnier olivier.monnier@intel.com
",267,False,en,0
1323,2,6,2,Externals,omonnier,2016-06-28T14:36:15Z,32,2,4,5,"The commit 39676192da53261efd441ccf0c67c85a341ae1a1
introduced a regression in the capability to fetch a
sha1 ref.
The command 'git lfs fetch origin <sha1>' was returning
following error: 'Invalid ref argument: [<sha1>]'.

This is due to the fact that 'git rev-parse --symbolic-full-name <ref>'
returns an empty content if the ref is a sha1.

Signed-off-by: Olivier Monnier olivier.monnier@intel.com
",400,False,en,2
1321,3,0,0,Internals,ttaylorr,2016-06-23T19:46:24Z,168,3,3,0,"This pull-request adds the ability to specify include/exclude flags to the `git lfs clone` command via `-I` and `-X`, and the repository-level `.lfsconfig` file, a-la `git lfs fetch`, etc.

Other things to note: I put the `clone{Include,Exclude}Arg string` flag outside of the `git.CloneFlags` type, since the new flags are LFS-specific, and not related to Git. If we'd rather have those flags roped into the `git.CloneFlags` type (but not passed to the `git clone` invocation), I'm cool with that, too.

Most importantly, thanks for the review! 👋 
",552,True,en,1
1312,1,0,0,Internals,ttaylorr,2016-06-21T15:37:26Z,1,1,1,2,,0,False,en,1
1310,2,1,0,Internals,ttaylorr,2016-06-16T16:26:09Z,11,1,2,0,"Since there is no HEAD ref to resolve when a repository is cloned with the `--bare` flag, the `git lfs fetch` command learned to ignore it. Kudos to @xen2 for bringing this up in #1307.

I piggybacked the pseudo-test for bare clones onto the end of the `fetch-all` test in `test/test-fetch.sh`. I am using all of the fixture data from the test, but if we want to extract that out, I'd be more than happy to do that 😄 

Either way, this pull-request should resolve #1307!

---

/cc @rubyist 
",494,True,en,1
1305,3,5,0,Externals,GabLeRoux,2016-06-28T17:20:48Z,3,3,1,14,"…close this if I'm wrong ;)
",30,True,en,0
1303,6,3,12,Externals,sinbad,2016-07-05T16:46:22Z,414,19,5,21,"Adds a new ""tus"" transfer adapter which uses the [tus.io resumable upload protocol](http://tus.io/protocols/resumable-upload.html) (HEAD/PATCH methods). This allows a server to share upload action links to an endpoint which supports this protocol and therefore allow upload resuming. 

The included tests implement the server protocol too to prove it works, and I'm also submitting a PR to [lfs-test-server](https://github.com/github/lfs-test-server) which uses the official `tusd` server to prove it works using the official implementation and to demonstrate how you might go about using it.
",593,True,en,2
1299,3,1,3,Externals,sinbad,2016-06-10T08:31:13Z,101,0,8,0,"Will be useful as a workaround where there are server bugs & avoid having to retry across adapters without knowing whether the cause is transient or not.

Basically error handling with non-basic adapters gets a lot more complex if we try to allow fallbacks to other adapters when an adapter fails. We can't know if errors are due to a transient problem or whether there's a bug in the server implementation and that we should stop negotiating this adapter. Even if we could determine that we'd have to perform the re-negotiation again. 

Instead with this PR we assume that we continue to use the same definition of retriable errors and fatal errors, and abort if a non-basic adapter fails. If the user then knows it's because the server is buggy then they can enable this option to go back to the basic transfer adapter in all cases until it's fixed.
",852,True,en,4
1298,1,1,0,Externals,javabrett,2016-06-28T19:41:55Z,8,18,3,20,,0,False,en,1
1297,15,0,4,Externals,sinbad,2016-06-10T08:15:59Z,659,307,7,1,"This PR implements resumable downloads for all storage hosts which support HTTP Range/Content-Range exchanges. Since it seamlessly falls back to re-downloading the entire file if the server doesn't support a range request, it doesn't hurt to always ask to resume and to proceed depending on what the server responds with (often these servers will just return 200 instead of 206 and send the entire file, which this caters for).
",428,True,en,2
1296,4,1,0,Externals,sinbad,2016-06-10T07:45:24Z,15,9,4,1,"When a file is skipped because it already exists locally, the progress reporting was wonky and on completion would look something like this from `git lfs fetch`:

```
Git LFS: (1 of 13 files) 17.33 MB / 18.34 MB
```

That looks like it didn't finish! Actually the 1 file it downloaded is 17.33 MB and the other 12 were skipped and made up the remainder.

This PR improves this 2 ways:
- Marks files as skipped during `fetch` so the progress tells the user that files & bytes were skipped
- Reduces the estimated files & bytes when skipping so the totals match up when finished (while still showing the number of files and bytes _actually_ transferred

The result after this PR is something like this instead:

```
Git LFS: (1 of 1 files, 12 skipped) 17.33 MB / 17.33 MB, 1.02 MB skipped
```
",791,True,en,2
1292,1,2,3,Externals,javabrett,2016-06-28T19:41:49Z,4,0,1,21,"Tested by:
- `sudo gem uninstall packagecloud-ruby`
- `sudo gem install packagecloud-ruby -v 1.0.2`
- `sudo gem install packagecloud-ruby`

... running `ruby script/packagecloud.rb` each time.  You get the version warning until you hit `1.0.4`, which is current.  Could make this `1.0.3`, the bare minimum, if preferred.
",321,False,en,0
1291,2,4,0,Externals,javabrett,2016-06-06T04:53:13Z,6,1,2,0,"Makes Debian build work on my machine, needs checks for correctness. #1290.
",76,True,en,0
1282,1,0,0,Internals,ttaylorr,2016-06-02T17:16:41Z,2,0,1,0,"This backports #1271.
",22,True,en,0
1281,6,3,0,Internals,ttaylorr,2016-06-02T22:21:31Z,88,0,1,0,"This pull-request introduces the `script/changelog` script, which enables callers to generate changelog summaries like we currently use within the releases page.

It accepts a range over which each merge commit is examined, categorized, and appended to a list. The categorization step works very similarly to `git add -i`, and allows you to slot each pull-request into a features, bugs, or misc category.

My bash is a little ugly, but this should work for now :smile:

---

As an example, this is a changelog that I generated for the v1.2.1 release:

```
# Features
- Allow additional fields on request & response schema #1276 (@sinbad)
- Add missing config details to `env` command #1217 (@sinbad)
- Allow smudge filter to return 0 on download failure #1213 (@sinbad)
- Add `git lfs update --manual` option & promote it on hook install fail #1182 (@sinbad)
- Applied same -ldflags -X name value -> name=value fix as in a62e510f. #1193 (@javabrett)
- Pass `git lfs clone` flags through to `git clone` correctly, respect some options #1160 (@sinbad)

# Bugs
- Fix installer error on win32. #1198 (@teo-tsirpanis)
- fix concurrent map read and map write #1179 (@technoweenie)
- Fix problems with user prompts in `git lfs clone` #1185 (@sinbad)
- Fix failure to return non-zero exit code when lfs install/update fails to install hooks #1178 (@sinbad)
- Fixed #719 missing /usr/share/man/man5/git-lfs-config.5.gz . #1149 (@javabrett)

# Misc
- Backport #1273 for v1.2.x: ignore all osx ci failures #1280 (@ttaylorr)
- embed the open code of conduct since the link is bad now #1206 (@technoweenie)
- add instructions to install from MacPorts #1186 (@skymoo)
- Add xenial repo #1170 (@graingert)
- add homebrew update to release process #1154 (@larsxschneider)
```
",1760,True,en,0
1280,1,2,0,Internals,ttaylorr,2016-06-02T16:02:22Z,0,1,1,0,"This backports #1273.
",22,True,en,0
1279,11,0,0,Externals,sinbad,2016-06-07T09:16:12Z,364,110,19,4,"Extends #1265 (diff will shrink once that's merged)

Extends the batch API to include transfer adapter negotiation. On each request a list of available transfer adapters is included, and if the server includes a preferred adapter in the response then that is used to construct the adapter for uploading / downloading.

All new API fields are optional. As I've discovered though, the 1.0 schema prohibited any extra fields in the json so servers which validate against that schema, including GitHub,  will need to update their request schema file even if they don't implement any custom transfer features. The schema change has been backported to 1.2.1 so hopefully will be adopted long before this client is an official version. Servers which ignore extra fields in the request work already.

This PR completes Phase 1 of the transfer enhancements discussed in https://github.com/github/git-lfs/blob/experimental/transfer-features-p2/docs/proposals/transfer_adapters.md
",970,True,en,3
1278,4,0,0,Internals,ttaylorr,2016-06-02T17:01:52Z,213,33,9,0,"This backports #1257.

Conflicting files:
- commands/commands.go
- lfs/config.go
- tools/filetools.go
",102,True,en,4
1277,1,3,0,Internals,ttaylorr,2016-06-02T17:16:36Z,8,2,2,0,"This backports #1267.

Conflicting files:
",42,True,en,1
1276,1,2,0,Externals,sinbad,2016-06-02T15:04:13Z,2,4,2,0,"This is to allow us to extend the API with optional fields in future versions without breaking the schema.

We should notify server implementations to update their schema if they're using it to validate requests since we need to add optional fields for the transfer features in v1.3 even if they don't implement those features.
",328,True,en,0
1274,2,0,0,Externals,sinbad,2016-06-02T14:32:13Z,1,0,1,0,"My firewall kept alerting me to this test accepting network connections and when I denied it or didn't click fast enough it would often cause test failures. I'm not sure if this is related to the random test failures we're seeing on OS X sometimes, it's possible. I've turned it off.

/cc @technoweenie @ttaylorr 
",314,True,en,0
1273,1,1,0,Internals,technoweenie,2016-06-02T14:11:46Z,0,1,1,0,"Seems that all 3 of our osx builds have different failures associated with them. 
- https://travis-ci.org/github/git-lfs/jobs/134590303
- https://travis-ci.org/github/git-lfs/jobs/134590297
- https://travis-ci.org/github/git-lfs/jobs/134590299

These 3 seem like test related issues on travis, and not lfs bugs, so they're now ignored.
",336,False,en,0
1271,1,0,0,Internals,ttaylorr,2016-06-02T17:02:17Z,2,0,1,0,,0,False,en,0
1267,2,1,0,Internals,ttaylorr,2016-05-31T23:28:43Z,8,2,2,0,"Some tests are failing on branches of mine because the LFS test credential helper is being overridden by the OS X system-level cred-helper. Instead of `--unset`-ing during the tests that needed it, this PR introduces a no-op credential helper, which fixes those tests.
",269,True,en,1
1265,37,1,7,Externals,sinbad,2016-06-07T08:35:40Z,1043,1391,24,6,"Part 1 of supporting more flexible transfer mechanisms for upload & download. This PR changes no visible behaviour or APIs but prepares the ground for features like resumable transfers and binary chunking/diffing.

The major changes are:
1. the code for actually performing the uploads and downloads is now isolated in the `transfer` package
2. paths for uploading / downloading are abstracted via a `TransferAdapter`, and the existing path of non-resumable HTTP GET/PUT is implemented as `basicTransferAdapter`
3. TransferAdapter implementations are unidirectional, to allow for paths that can only do one or the other (e.g. tus.io is only upload, HTTP range headers are only download)
4. a registration system for adding new named transfer adapters is in place but currently unused, will be in the next stage
5. rationalisation of much of the API code so there is a clearer line between the API which requests URLs to upload/download, and the code which actually performs the upload/download. 
6. `TransferQueue` is still used since it orchestrates the end-to-end process, which includes calling the API. However it no longer has any transfer workers, it delegates that to `TransferAdapter`. 
7. Legacy code which will be removed when we drop the non-batch API route is clearly marked `// TODO LEGACY API`. Use of this code has been minimised so it's no longer generally mixed in even when you have batch support.
8. Fixes #1121 - this was caused by only the API part of the download/upload exchange waiting for a password prompt in serial, the actual transfers all kicked off in parallel so if the storage server had different credentials and had to prompt, all goroutines would prompt. The transfer system now handles this itself.
9. The same transfer code path is used for all cases, whether you're using e.g. `git lfs fetch` or `git lfs smudge`. Previously there were multiple paths.
10. Removed the `DownloadCheckable` and simplified things so it just uses the `dryRun` flag instead when probing the API for possible downloads without actually downloading. No other code used this anyway.
11. `Transferable` still exists but is now just a statement of intent in the `lfs` package for the entire process of queueing through the API and eventually being transferred if `dryRun=false`. It still needs to be there as an abstraction since the data comes from different places, but beyond data wrapping has no real functionality anymore barring a legacy hook which will get removed when we move to batch only. The simpler `Transfer` struct in the `transfer` package is used to schedule the actual transfers (doesn't share `Transferable` both to avoid import cycles and because the intent is different)

As mentioned this is only an internal change right now (albeit a fairly large one) and behaviour is unaffected. The next step is to use the adapter registration system to provide additional transfer routes, negotiated between client & server through optional new fields in the API.
",2986,True,en,5
1262,1,6,0,Externals,orivej,2016-06-28T19:41:45Z,43,3,3,29,"This change introduces `--unstaged` ('-u') flag to the `checkout` subcommand. Originally it is intended to skip the costly `git update-index` call in the continuous integration setup where `git lfs checkout` is the last git operation performed in the clone, and the state of the index does not matter anymore.
",310,True,en,1
1260,1,9,0,Externals,pdf,2016-06-03T09:10:22Z,127,1,2,5,"Per the spec, `GIT_SSH_COMMAND` takes precedence over `GIT_SSH`.

Fixes #1142
",78,True,en,1
1259,2,1,0,Internals,ttaylorr,2016-05-27T22:20:28Z,52,6,4,0,"This pull-request adds the relevant schema, tests, and type to support the ability for a client to indicate to an LFS server that it wishes to forcibly remove a particular lock.
",178,True,en,1
1258,1,1,0,Internals,ttaylorr,2016-05-27T19:25:43Z,2,2,2,0,"This pull-request removes the various errors we received on old Go 1.5.x builds that looked something like:

```
can't load package: package github.com/bgentry/go-netrc/netrc: cannot find package ""github.com/bgentry/go-netrc/netrc"" in any of:
    /home/travis/.gimme/versions/go1.5.linux.amd64/src/github.com/bgentry/go-netrc/netrc (from $GOROOT)
    /home/travis/gopath/src/github.com/bgentry/go-netrc/netrc (from $GOPATH)
can't load package: package github.com/cheggaaa/pb: cannot find package ""github.com/cheggaaa/pb"" in any of:
    /home/travis/.gimme/versions/go1.5.linux.amd64/src/github.com/cheggaaa/pb (from $GOROOT)
    /home/travis/gopath/src/github.com/cheggaaa/pb (from $GOPATH)

<snip>
```

Turns out that even though we applied the `GO15VENDOREXPERIMENT=1` variable to most `go` commands, I neglected to add it to the `go list` we were using to [determine which packages to test](https://github.com/github/git-lfs/blob/7ed06cd1803467322d1c8bb997a7f615c439b34a/script/test#L10).

Anyway, those errors are a thing of the past. Onward!
",1047,True,en,0
1257,8,8,4,Internals,ttaylorr,2016-06-01T21:02:01Z,204,33,9,5,"@dipnlik reported #1251 the other day that the include/exclude filters made a distinction between `./foo/bar/` (with the trailing slash) and `./foo/bar` (without).

This pull-request introduces a patch that essentially runs filepath.Clean() against the paths before processing them. In addition, it removes the `command.determineIncludeExcludeFilters` function, and instead introduces a set of more granular replacement functions in the `config.Configuration` type. Those functions are all documented within the changeset.
",523,True,en,4
1256,28,5,5,Internals,ttaylorr,2016-06-21T15:59:27Z,820,0,11,25,"This pull-request is an incremental step towards the new lock related commands within the Git LFS client.

As an added benefit, these three new commands make extensive use of the new API client, so they serve as an example of its use.
## Commands
##### `git lfs locks [-i id] [-p path] [-l limit] [--remote remote]`

The `git lfs locks` allows the client to list locks active on the server corresponding to the given filters, along with using the optional cursor and limit properties to paginate through a longer list of results.
##### `git lfs lock [--remote remote] <path>`

The `lock` command allows the client to create a lock against a particular file by making the appropriate API call to the server.
##### `git lfs unlock [--force] [--remote remote] <--id | path>`

The `unlock` command allows a client to break a lock created by any user against any particular file [in accordance with the original specification](#https://github.com/github/git-lfs/pull/1223).
## TODO

Still todo, are the following:
- [x] Implement the shell tests for these three new commands
  - [x] Implement the LFS locking API within the test server
- [x] Make the command that take a `<path>` argument resolve to a path relative to the root of a repository, such that they are consistent on the server.
- [x] Add optional --id param to unlock a lock according to its ID, and not the path.
- [x] Add optional --force param to force an unlock.
- [x] Add optional --remote param to all the lock commands to specify a different remote.
",1514,True,en,5
1255,3,1,0,Internals,technoweenie,2016-07-08T19:23:52Z,11,4,2,43,,0,False,en,0
1253,1,0,0,Internals,ttaylorr,2016-05-25T20:16:29Z,44,39,1,0,,0,False,en,1
1252,1,1,0,Internals,ttaylorr,2016-05-25T19:54:01Z,123,75,7,0,,0,False,en,3
1250,2,1,0,Internals,ttaylorr,2016-05-25T16:51:53Z,119,293,22,0,"This pull-request removes @technoweenie's `assert` library so that we only use one assertions library throughout Git LFS.
",122,True,en,15
1248,1,3,1,Internals,technoweenie,2016-05-24T23:12:19Z,4,3,2,0,"Returning simply `{remote}/{branch}` doesn't help if someone creates a local branch `refs/heads/master/{remote}/{branch}`. This `RemoteRefNameForCurrentBranch()` function is only used for `ResolveRef()`. `git rev-parse` can definitely handle full refs.
",253,True,en,1
1243,12,9,0,Internals,ttaylorr,2016-05-24T15:02:58Z,642,4796,744,0,"- script/vendor received an update in order to work with Glide
- import paths have been rewritten to work with GO15VENDOREXPERIMENT
",132,False,en,55
1236,21,11,9,Internals,ttaylorr,2016-05-24T20:15:48Z,1523,135,24,3,"This PR introduces the Git LFS API client, as well as the `LockService`, for interacting with the [new LFS file locking API](https://github.com/github/git-lfs/pull/1223).
# API Client

The API client is broken down into several key components, all of which are described here:
## Request Schemas

A request schema provides a definition or template type from which to build an actual request. Right now, the definition of this type is as follows:

``` go
// RequestSchema provides a schema from which to generate sendable requests.
type RequestSchema struct {
    // Method is the method that should be used when making a particular API
    // call.
    Method string
    // Path is the relative path that this API call should be made against.
    Path string
    // Query is the query parameters used in the request URI.
    Query map[string]string
    // Body is the body of the request.
    Body interface{}
    // Into is an optional field used to represent the data structure into
    // which a response should be serialized.
    Into interface{}
}
```
## Request/Response Lifecycle

The lifecycle type is responsible for a few things:
1. Building an executable request based on the given schema.
2. Executing that request against an API server (and serialize the result, if applicable)
3. Cleaning up after that request has finished.

Right now, things are a little `net/http` specific, and the only Lifecycle implementation is the `*api.HttpLifecycle` type. That type knows how to do all of the things described above in an HTTP-specific context. Internally, it uses the `*http.Client` type to execute the requests.

In the future, I would like to abstract away the HTTP-specific stuff, and open the API up to an SSH, or even WebSocket implementation.
## Services

Services are responsible for implementing API methods by providing code to generate `*api.RequestSchema`s, which can be passed to the `*api.Client` in use to be sent through the lifecycle subsystem, and eventually, a response is returned.
### Lock Service

This PR includes the `LockService` type, which implements all of the APIs type definitions, as well as the three methods specified in the File Locking API proposal (Lock, Unlock, and Search).

An example use of the `LockService` would be as follows.

``` go
client := api.NewClient(...)
locks, schema := client.Locks.Search(&api.LockSearchRequest{
        // ...
})

resp, err := client.Do(schema)
if err != nil {
        panic(err.Error())
}

for _, l := range locks.Locks {
        // ...
}

fmt.Fprint(""API call succeeded with status %d\n"", resp.StatusCode())
```
## `schema` package

We also introduced a way to test that our implementation of the API as defined in the `docs/` directory is correct, by using JSON schema.

This is a nice boundary to pick, since we have tests for the Service methods, and tests for the API client code, so the actual API implementation is tested separately. 

To test a new API type, simply add a `*_schema.json` file to the `api/schema/` directory, and you're good to go:

``` go
func TestLockResponseSchema(t *testing.T) {
        schema.Validate(t, schema.LockResponse, &api.LockResponse{
                // ...
        })
}
```

or, alternatively:

``` go
func TestInvalidLockResponseSchema(t *testing.T) {
        schema.Refute(t, schema.LockResponse, &api.LockResponse{
                // ...
        })
}
```

---

Thanks in advance to anyone who reads through this PR, I appreciate you taking the time to look through this rather lengthy diff. 😄 

Special thanks to @technoweenie and @sinbad for listening to my design proposals, as well as providing invaluable suggestions and advice along the way. 👋 

Enjoy!
",3691,False,en,7
1234,2,1,0,Internals,technoweenie,2016-05-20T21:50:17Z,6512,0,391,0,"@ttaylorr is using this package to test the new api client. That PR is incoming :)
",83,True,en,3
1229,1,3,0,Internals,technoweenie,2016-05-19T01:05:51Z,54,1,2,0,"This uses `NewRepo()` so that these 2 tests run identically from a git clone and from a plain source dump. Should fix #1202 

/cc @sinbad @javabrett 
",150,True,en,1
1228,1,2,0,Internals,technoweenie,2016-05-19T14:24:20Z,15176,0,68,0,"@ttaylorr requested the testify package. Since it doesn't make sense to have multiple test helpers, I think we should also remove `github.com/technoweenie/assert`. The `github.com/technoweenie/assert` package is a fork of a dead project. It also halts test execution after each assertion.

The testify package supports multiple assertion failures in a single test. It also includes a mocking package that @ttaylorr wants to use in his api client tests (https://github.com/ttaylorr/git-lfs/pull/2).

@sinbad: Any thoughts?
",522,True,en,11
1226,25,3,0,Externals,sinbad,2016-05-18T14:33:44Z,2564,1910,90,1,"In preparation for extending git-lfs to allow more transfer (and later, api) options, I've done the first (most significant) stage of a refactor of the `lfs` package into more modular parts.

The key idea is to align parts of the functionality into more cohesive partitions so that each of them can be adapted more easily in future. This has involved the creation of a lot more packages in order to prevent circular dependencies. The general principles of the dependency tree are:
- `lfs` increasingly pulls functionality together rather than providing most of it
- `api` contains logic associated with calling the remote LFS server
- `httputil`, `errutil` collect together different utilities that are used in multiple packages
- `tools` brings together some file system and I/O helpers, too small to be their own package each right now
- `localstorage` existed before but now has more responsibility for the local state, `lfs` delegates more to it
- `config` collects all the environment, git config and lfs config together for use by all other packages
- `auth` covers credentials and the ssh authentication
- `progress` holds the spinners, progress meters etc

It's not done yet but I think I've come a long way to untangling the ball of string that was the `lfs` package. I think we should merge it at this point to head off conflicts since it's already useful. 

The main missing part is the `transfer` package. This will focus on the transferring of content (not the metadata) including parallelisation, so that this can be extended more easily (the original trigger for this work). However, to complete this part of the refactor requires me to move a couple of bits from `api` (`UploadObject` and `DownloadObject`) and also to pull apart the transfer queue, which currently groups together both the logic for batching up calls to the API, and calling the actual upload/download hooks - these need to be separated so batching & API is separate to transferring. This is non-trivial so needs a few more days, I'll do that next but it only affects a handful of files so I think it's worth merging this first.

Aside: I think we might want to create a branch for 1.2.x which excludes this and keep master for this and other big feature work like locking.
",2258,True,en,17
1223,16,6,24,Internals,ttaylorr,2016-05-17T19:52:29Z,410,25,2,0,"This PR adds to @sinbad's original proposal and extends it to document some particular commands that we will have to teach the LFS client.

All of the documentation surrounding these new commands and API methods are in the contents of this PR, so I will keep this description brief 😄

Thanks in advance for reading! 👋
",324,True,en,0
1222,1,6,7,Externals,zeldin,2016-07-07T16:43:37Z,102,0,3,51,"This pull request adds the ability to build git-lfs with gccgo simply by typing ""make"".  No ""go"" command is required.
",118,True,en,0
1217,1,3,0,Externals,sinbad,2016-05-12T16:19:40Z,181,0,3,0,"Adds all Fetch/Prune config details to the `env` command, as well as extensions which weren't reported.
",104,True,en,2
1215,1,1,0,Externals,javabrett,2016-05-11T14:27:22Z,1,1,1,0,,0,False,en,0
1213,4,1,0,Externals,sinbad,2016-05-10T15:26:19Z,162,2,7,0,"Fixes #1195 

Add option `lfs.skipdownloaderrors` / `GIT_LFS_SKIP_DOWNLOAD_ERRORS` to allow the smudge filter to return success on download errors, so that checkout etc can continue even without access to content.

It's an option because using this means exit codes are not propagated and scripts would be unable to detect problems with clone/checkout when LFS downloads failed. Also users if they weren't paying attention. However it's useful as an opt-in if wanting to switch branches etc when disconnected.
",510,True,en,3
1206,1,0,0,Internals,technoweenie,2016-05-06T12:01:33Z,71,4,2,0,"The URL for the code of conduct is down, so I embedded the text as a markdown file. This isn't a change of the code that the project adheres to, so we won't be discussing changes in this PR.
",191,True,en,0
1200,1,5,0,Externals,teo-tsirpanis,2016-07-21T16:48:25Z,5,1,1,78,"In a previous pull request I submitted, there was an error.
The installer would write to a ""mingw64"" directory even on 32-bit versions of Windows.
With this patch, the installer will write to the correct ""mingw32"" directory under Win32.
",237,False,en,0
1198,1,1,0,Externals,teo-tsirpanis,2016-05-04T13:59:24Z,1,1,1,0,"On 32-bit versions of Windows (in my case, Windows XP), the windows installer fails because it cannot expand the ""pf64""constant.

By changing this very constant to ""pf"", it gets resolved properly on all versions of Windows.

See http://www.jrsoftware.org/ishelp/index.php?topic=consts for further explanation of the constants.
",327,True,en,0
1193,1,3,0,Externals,javabrett,2016-05-04T12:42:58Z,1,1,1,1,"Squashes script/run warning:
link: warning: option -X github.com/github/git-lfs/lfs.GitCommit 54c5efa may not work in future releases; use -X github.com/github/git-lfs/lfs.GitCommit=54c5efa
",190,False,en,0
1186,1,4,0,Externals,skymoo,2016-04-28T04:19:10Z,1,1,1,0,,0,False,en,0
1185,1,1,0,Externals,sinbad,2016-04-28T08:13:21Z,13,54,1,0,"Fixes #1159 

Stop using the psuedo-tty & pass through streams directly. Getting pty to work with stdin was too difficult, even when it worked passwords were displayed on the terminal which is no good. We no longer need to filter the stderr for known warnings; Git 2.8 is now released which deals with them and for Git 2.7 and below we can fall back on `cat` instead of a blank filter; it's slightly slower but eliminates the problem more simply. We used to do this for git < 2.2 anyway which didn't support blank filters at all.
",530,True,en,0
1182,1,1,0,Externals,sinbad,2016-05-04T13:50:22Z,64,10,5,8,"Related to #1174 

As discussed in chat, implemented as a command option rather than in docs so that we don't have to maintain the hook script in more than one location.
",170,True,en,2
1179,1,1,0,Internals,technoweenie,2016-05-04T12:46:45Z,9,1,1,8,"Found another one:

```
fatal error: concurrent map read and map write

goroutine 58 [running]:
runtime.throw(0x618f40, 0x21)
    /usr/local/Cellar/go/1.6.1/libexec/src/runtime/panic.go:530 +0x90
fp=0xc820793cc0 sp=0xc820793ca8
runtime.mapaccess2_faststr(0x429280, 0xc8202984e0, 0xc8202b7d00, 0x40,
0xc82064c708, 0xc82042a401)
    /usr/local/Cellar/go/1.6.1/libexec/src/runtime/hashmap_fast.go:307
+0x5b fp=0xc820793d20 sp=0xc820793cc0
github.com/github/git-lfs/lfs.(*TransferQueue).batchApiRoutine(0xc820074
680)
    /Users/rick/go/src/github.com/github/git-lfs/lfs/transfer_queue.go:242
+0xb52 fp=0xc820793f88 sp=0xc820793d20
runtime.goexit()
    /usr/local/Cellar/go/1.6.1/libexec/src/runtime/asm_amd64.s:1998 +0x1
fp=0xc820793f90 sp=0xc820793f88
created by github.com/github/git-lfs/lfs.(*TransferQueue).run
    /Users/rick/go/src/github.com/github/git-lfs/lfs/transfer_queue.go:332
+0x2b7
```
",898,True,en,0
1178,5,1,0,Externals,sinbad,2016-04-25T14:57:57Z,34,10,4,0,"Fixes #1174 

Also tidies up the output a little and automatically replaces blank pre-push hooks now.
",102,True,en,2
1177,8,19,0,Externals,javabrett,2016-08-17T21:48:47Z,184,26,8,114,"These changes modify the packaged install experience, pulling-up config changes currently made in the current user ""global"" config (`~/.gitconfig`), to instead be made at the ""system"" config (`/etc/gitconfig`).  That way, Git LFS is installed once per-system, and does not require additional configuration should a different user start using Git LFS and therefore require the smudge/clean filters.

Note that these changes presume that it is safe to have the Git LFS filters installed and that they do and will continue to run as fast noops in non-Git LFS repos.

The elevation from global-to-system occurs automatically provided:
1. The installation runs as root
2. `--local` is not specified.

Additionally, post-install and pre-remove scripts are added to deb and rpm packages.  Since these run as root, they automatically elevate and install to `/etc/gitconfig`.

I don't know how this plays-out on Windows.
",912,True,en,0
1176,1,4,0,Externals,javabrett,2016-07-21T20:40:15Z,20,2,1,87,,0,False,en,0
1170,1,4,0,Externals,graingert,2016-04-22T14:40:55Z,1,0,1,0,,0,False,en,0
1168,1,1,0,Externals,sinbad,2016-04-22T14:16:21Z,1,0,1,0,"Related: #1167 
",16,True,en,0
1162,1,1,0,Externals,larsxschneider,2016-04-20T14:37:49Z,1,1,1,0,,0,False,en,0
1160,6,7,2,Externals,sinbad,2016-04-25T13:57:49Z,255,4,3,5,"Fixes #1155 
- `git lfs clone` now correctly passes through flags to `git clone`
- `--no-checkout` and `--bare` now cause `git lfs clone` to `git lfs fetch` rather than pull
- `--origin` option is respected and changes how lfs fetches/pulls after clone
",253,False,en,1
1158,2,1,0,Internals,technoweenie,2016-04-22T07:54:05Z,3,0,1,3,"This is focused on build/compilation stuff. Adding these items now so I don't forget later.
",92,True,en,0
1154,1,1,0,Externals,larsxschneider,2016-04-18T13:29:22Z,1,0,1,0,"As homebrew is pretty popular amongst Mac users I think it would be nice to bump the version with every update. However, I also understand that you guys can't update for every package manager out there... therefore this is just a suggestion and I am not sad if you reject it 😄 
",281,True,en,0
1149,1,3,0,Externals,javabrett,2016-04-18T13:31:49Z,4,0,2,3,"I was able to test this for a deb on Ubuntu/LinuxMint, and it worked, `man git-lfs-config` now works after local build and deb install.

Warning: RPM untested.
",160,True,en,0
1146,1,1,0,Externals,pascalberger,2016-07-08T19:28:08Z,1,1,1,85,,0,False,en,0
1145,3,0,0,Internals,technoweenie,2016-04-15T19:52:14Z,7,0,1,1,"Just adding a few things so I can scratch them off my personal todo list. Some of these may be good candidates for ""help-wanted"" issues. I'll keep this PR open for 1 day and merge it, unless there are any oppositions. Feel free to add suggestions in the mean time.
",265,True,en,0
1144,1,1,0,Internals,technoweenie,2016-04-14T13:30:27Z,95,3,2,0,"Whew, glad I QA'd against a real server, and not just a local test one :)

The `net.SplitHostPort` function expects the host string to have a port (like `localhost:8008`). Currently, it blows up if you use a host on a standard http port.
",238,True,en,1
1143,1,1,0,Externals,strich,2016-04-15T00:09:11Z,13,7,1,1,"- Fixed an issue (#1120) where the newly added Git LFS `PATH` location wasn't refreshed in time for use later in the installer script and silently failed to initialize Git LFS.
- If for any reason there is an issue running `git lfs install`, the installer will display a message box asking the user to manually do so.
- Added a `GIT_LFS_PATH` global env var for later use.
",373,False,en,0
1136,7,3,0,Internals,technoweenie,2016-04-12T15:45:23Z,170,63,8,3,"<del>Trying to replicate #906</del>


Replicated it with some more info. Running with `GIT_TRACE=1` showed me this:

```
trace git-lfs: HTTP: POST https://USER:PASS@git-lfs-server.com/repo.git/info/lfs/objects/batch
trace git-lfs: HTTP: 200
trace git-lfs: HTTP: {""objects"":[{""oid"":""0000000000000000000000000000000000000000000000000000000000000000"",""size"":1,""_links"":{""download"":{""href"":""https://git-lfs-server.com/repo/info/lfs/objects/0000000000000000000000000000000000000000000000000000000000000000"",""header"":{""Accept"":""application/vnd.git-lfs""}}}}]}
trace git-lfs: HTTP:
Username for 'https://git-lfs-server.com':
```

The LFS client is authenticating `https://USER:PASS@git-lfs-server.com/repo.git/info/lfs/objects/batch` properly. However, the LFS server is not returning authenticated urls to the requested objects, like `https://git-lfs-server.com/repo/info/lfs/objects/0000000000000000000000000000000000000000000000000000000000000000`. This is undesirable, but should be easy enough to fix.
",999,True,en,3
1135,1,2,0,Internals,jonmagic,2016-04-08T18:01:34Z,1,0,1,0,"While following the instructions in the README made my first commit and then realized I hadn't added the `.gitattributes` file. I think the instructions should be explicit about this step.
",189,True,en,0
1134,1,1,0,Externals,sinbad,2016-04-11T18:00:53Z,2,3,1,3,"Fixes #1132
",12,True,en,0
1130,1,1,0,Externals,javabrett,2016-04-14T16:59:34Z,41,1,2,7,"Adds some details around installing from packagecloud.  #1074 .
",64,True,en,0
1128,7,4,11,Internals,technoweenie,2016-04-08T16:19:12Z,301,225,9,1,"This PR brings back the push optimizations from #1040. Hit up #1040 and #1071 to get the original context. This makes a few changes based on feedback:
- #969 is no longer included. That will come in the next PR.
- https://github.com/github/git-lfs/pull/1071#issuecomment-196280487
  
  > Are you intending to wrap downloading in clientContext too? Although there's somewhat less for it to do than in the upload case. If not, or even if 'not right away' then maybe rename clientContext to uploadContext for now.
  
  It's now called `uploadContext`. It's still unexported, so I expect the type to change and move from the `commands` package some day.
- https://github.com/github/git-lfs/pull/1071/files#diff-d540c48abbcd5b13b0acd4cbef433700R57
  
  > Hmm, feels weird to have to copy the remote name when everything else uses Config directly
  
  Handled in `newUploadContext()`
- https://github.com/github/git-lfs/pull/1071/files#r55989899
  
  > This now feels like non-intuitive output to get when asked to push 2 oids.
  
  Agreed. There are now fewer test changes. The reason the ""skipped"" output changed, is because it was being handled in [the old filter()](https://github.com/github/git-lfs/pull/1071/files#diff-3cff4ed9c5b60b5b81240c88cd74e404R69) _before_ the `*lfs.TransferQueue` object for the upload is created. Now, the only objects the `*uploadContext` skips those that have already been uploaded in the current process (usually from another ref). 
",1463,False,en,3
1127,6,2,0,Internals,technoweenie,2016-04-12T15:45:31Z,17,21,1,6,"I have one more larger proposal for a feature (file expiration), and a bunch of smaller bugs to add.
",101,True,en,0
1122,1,3,0,Externals,rjbell4,2016-04-06T14:23:41Z,16,1,2,1,"I don't know if you want a change this simple, as I don't know the original intent, but as mentioned in issue #1121, I was hoping to describe the access of my LFS URL as ""private"" in the same .lfsconfig as where I define the URL itself.  I think it makes the most sense to have this data be co-resident.  However, git-lfs won't allow me to put this content in the .lfsconfig.  This simple change allows me to define it there.
",426,True,en,1
1118,10,2,3,Externals,sinbad,2016-04-05T13:21:11Z,411,70,8,4,"Fixes #1100 as well as surfacing a number of other fail states previously missed.

Wraps all scanner channels so that consumer only has to worry about primary results as channels, then check error result from `wrapper.Wait()` at the end to pick up any bad exit conditions (rather than having to handle 2 channels themselves).

Fixed a bunch of other issues while I was at it.
",376,True,en,3
1115,1,1,0,Externals,javabrett,2016-03-30T14:17:55Z,1,0,1,0,"Following from #1025.  If you want to run the Debian dpkg build using Go 1.6, you need this change, otherwise the import problems noted in https://github.com/github/git-lfs/pull/1076#issuecomment-199062143 will occur.

It is super-likely that the same need to be added to RPM build `rpm/build_rpms.bsh`, and this could be added on speculation, but I don't have a current build environment on a yum-packaged dist.
",413,True,en,0
1107,1,2,0,Externals,sinbad,2016-03-23T10:06:11Z,17,4,3,0,"If user doesn't specify a specific one, create one in the temp area & clean up when done if KEEPTRASH=0
",104,True,en,2
1105,1,13,0,Externals,sschuberth,2016-04-07T23:53:48Z,6,6,1,16,"This allows to create a pointer file by redirecting Stdout like

```
$ git lfs pointer --file=path/to/file > pointer-to-file
```

Before this change, ""pointer-to-file"" would also contain the line saying

```
""Git LFS pointer for path/to/file""
```

which makes the pointer file invalid.
",286,True,en,0
1104,3,2,1,Externals,sinbad,2016-04-05T08:24:06Z,147,0,3,13,"Resolves #1057 

If a file is already tracked in git when it's added to git-lfs tracking, that file is now 'touched' (`mtime`/`atime` file attributes updated) to ensure that it appears as modified in `git status` along with the `.gitattributes` and therefore prompts the user to re-commit it. Without doing this git doesn't detect that the index is dirty for this file and the user could commit `.gitattributes` but with the file content remaining as non-LFS, which can cause problems when checking out this commit in future. Checking out this commit will forever after show the file as modified in the working copy because `smudge` will not have LFS data to checkout from even though `.gitattributes` says it should have, and `clean` will show a diff.
",753,True,en,1
1102,1,1,0,Externals,javabrett,2016-03-30T14:34:13Z,4,1,1,8,"I ran `mitmproxy` so I could notice that packagecloud package create was failing with an interesting error.    Prior to this change it fails silently in the script.

This change reports the failure and exits.
",209,True,en,0
1096,1,1,0,Externals,epriestley,2016-03-22T14:54:33Z,26,0,2,2,"Fixes issue #1056.

When you try to push `master` but also have a file named  `master`, we run
`git rev-list ... master`. This is ambiguous, because `rev-list` accepts
paths or refs and `git` is unsure whether you mean the ref `master` or the
path `master`.

Instead, run `git rev-list ... master --`, which is unambiguous.

This adds a failing test (trying to push a file named `master` to LFS), then
fixes the test by appending `--` to the command.
",451,True,en,1
1094,1,2,0,Externals,anatolyborodin,2016-03-22T15:36:26Z,1,1,1,2,"Google:
- ""pat yourself""  -> 451,000 results
- ""pat your self"" -> 22,700 results and `Did you mean: ""pat yourself""`
",116,False,en,0
1093,1,4,0,Externals,anatolyborodin,2016-03-22T15:38:46Z,2,1,1,2,"One needs to have release engineer access rights to https://github.com/github/git-lfs.github.com to open the [link](https://github.com/github/git-lfs.github.com/blob/gh-pages/_config.yml#L4), it will show `404` otherwise.

See #1092
",233,True,en,0
1091,2,2,1,Externals,sinbad,2016-03-23T09:41:04Z,62,9,3,4,"I discovered this problem while setting up the integration tests to always run in an isolated temp dir if GIT_LFS_TEST_DIR is not set. On Mac that's `/var/temp`, which is a symlink to `/private/var/temp` and which immediately failed in all kinds of ways. The 2 main issues were: 
1. `git rev-parse` resolves symlinks but os.Getwd(), filepath.Abs() does not, causing internal inconsistencies and some weird relative paths from filepath.Rel() that didn't always work
2. Many integration tests failed because bash wasn't resolving symlinks vs Go doing so sometimes

I've chosen to resolve symlinks always to fix this. In bash this was more tricky because `readlink -f` doesn't exist on Mac so there's a helper function to do it. 
",727,False,en,1
1087,1,2,0,Externals,epriestley,2016-03-18T12:56:37Z,7,6,1,0,"I got this wrong in #1082, see:

https://github.com/github/git-lfs/pull/1082#issuecomment-198308275

I misread the `prePushCheckForMissingObjects()` logic and, in my local test case, I had the server send back `download` _instead of_ `upload` and saw it skip, but that isn't an accurate test because either rule (presence of `download`, absence of `upload`) passes it.

To verify this behavior properly, I had the server send back a made up action (`quack`) instead of `upload`, and observed that the client skipped the transfer:

```
$ GIT_TRACE=1 git lfs push origin master
...
trace git-lfs: HTTP: POST http://local.phacility.com/diffusion/POEMS/poems.git/info/lfs/objects/batch
...
trace git-lfs: HTTP: {... ""actions"":{""quack"":{ ... } }}
...
Git LFS: (0 of 1 files, 1 skipped) 0 B / 87.12 KB, 87.12 KB skipped                                                                                                                                                            
```
",974,True,en,0
1084,1,1,0,Externals,epriestley,2016-03-18T00:20:43Z,1,1,1,0,"The argument order and string order are flipped. Before:

```
$ GIT_TRACE=1 git-lfs push origin master
trace git-lfs: Upload refs origin to remote [master]
```

After:

```
$ GIT_TRACE=1 git-lfs push origin master
trace git-lfs: Upload refs [master] to remote origin
```
",271,True,en,0
1083,2,3,0,Externals,epriestley,2016-03-18T00:20:08Z,65,26,6,0,"Fixes #1072. Currently, the filters run a command like this when a tracked file begins with a dash:

`$ git-lfs clean -filename`

The filename is then misinterpreted as short arguments.

This installs `git-lfs clean -- %f` instead of `git-lfs clean %f`, and a similar smudge filter.

A limitation of this patch is that existing installs don't automatically upgrade to the new filters until they run `git lfs install --force`. It looks like this is consistent with the `git lfs clean` vs `git-lfs clean` precedent, but maybe encountering this behavior is realistic enough to justify trying to build some sort of auto-upgrade feature which promotes known older variants of the filter (it looks like the pre-push hook has such a list already).

In any case, this should fix new installs, and allow existing installs to use `git lfs install --force` to manually apply the fix.
",873,True,en,5
1082,1,5,0,Externals,epriestley,2016-03-17T23:43:04Z,4,1,1,0,"This may not be worth pulling or the best method or place to express the idea, but the behavior wasn't self-evident to me from the documentation while implementing an LFS server, even though it makes sense now that I understand the interaction.
",245,True,en,0
1081,1,1,0,Externals,sinbad,2016-03-18T08:54:27Z,59,2,3,0,"Addresses final point of #308
",30,True,en,1
1080,1,1,0,Externals,sinbad,2016-03-17T16:01:31Z,4,4,4,0,"TTY abstraction and subprocess came out of different PRs, makes sense to move TTY into subprocess now they're both in master.
",126,True,en,0
1078,1,1,0,Externals,epriestley,2016-03-15T22:11:38Z,1,1,1,0,"This JSON key is only indented one space, but should be indented two spaces to align with the rest of the structure.
",117,True,en,0
1076,2,9,0,Externals,javabrett,2016-04-14T23:25:29Z,4,1,1,30,"I haven't got my deb build running yet to be able to test this via push to my packagecloud.  Can build OK but the dpkg build complains about imports.

So I'm not sure this is correct, but someone with a working build would be able to test it, perhaps for the next release.
",273,True,en,0
1071,16,5,8,Internals,technoweenie,2016-04-06T15:54:06Z,624,228,14,25,"I have some issues with this code. But at least now pre-push and push both call shared functions to upload objects.

From https://github.com/github/git-lfs/pull/1040#discussion_r55821731:

> Now that filteredPointers is used in multiple places, maybe promote it to the lfs package for re-use rather than keep it in the pre-push source file?

This PR is a start towards shared functions for pre-push and push commands. While it seems to work, there are a number of things I'd like to change:
- I don't like using `lfs.Configuration` like this. I wanted something more than a `StringSet` to share between multiple ref uploads in the same command.
- Filtering could probably be cleaned up.

EDIT: Fixed this in a later commit ^^^

Instead of promoting to the lfs package, what if we started on a high level client like we discussed in https://github.com/github/git-lfs/issues/779? I am a little concerned that my yak shave trying to get #969 merged is going on too long though :)

I don't think the commands should be assembling upload queue objects or anything. I think they should just be responsible for turning the CLI or STDIN arguments into code like this:

``` go
c := client.New(""origin"")
c.DryRun = false

for _, ref := range args[1:] {
  c.Upload(scanObjectsLeftToRight(ref, """", lfs.ScanRefsMode))
}

errs := c.Errors()
// error handling, os.Exit(2), etc
```
",1366,True,en,1
1070,8,0,0,Externals,sinbad,2016-03-16T12:43:51Z,141,25,8,4,"- Referencing kr/pty breaks Windows, hide in extra layer
- netrc was breaking build on Windows due to needing a blank line after +build directive
- git lfs clone wasn't working because of a doubly-assigned stdout
- integration tests weren't running because of a bash path issue
",278,False,en,2
1067,19,5,10,Externals,sinbad,2016-03-17T14:56:31Z,602,115,20,6,"Adds support for trusting self-signed CA certs from the following locations:
- `http.sslcainfo` in gitconfig (non-specific CA cert file)
- `http.sslcapath` in gitconfig (non-specific dir of CA certs)
- `http.<url>.sslcainfo`, `http.<url>.sslcapath` in gitconfig; as above but specific to server:port. <url> must be of the form `https://host[:port]/` as currently subpaths are not supported (but it's impractical to have different certs per subpath anyway so support would not really beuseful)
- `GIT_SSL_CAINFO` and `GIT_SSL_CAPATH` environment variables; as non-specific gitconfig options
- On Mac OS X, certs marked 'Always Trust' in the System keychain in Keychain Access (just like Chrome and others)

On Windows, the Windows Certificate Store already works for git-lfs access in fact because Golang itself includes it in its Root CA search; however since git (2.7.1) doesn't support the WCS it's not a complete solution, unless you're using SSH clone URLs for git. You're better to stick to the gitconfig / environment options for consistency.

Related: #308 
",1065,False,en,6
1054,1,0,0,Internals,technoweenie,2016-03-03T17:08:20Z,62,0,2,2,"I'm adding this because I started hitting various connection errors, but only when running the tests on debian docker images, and only on my laptop. @andyneff can't replicate this.

This is an ugly hack to ignore those errors. The errors are not LFS related, but they come from the client being unable to talk to the http server that's spun up in the tests, bound to 127.0.0.1. Also, CI tests don't skip these errors, so bugs will still prevent pull request merges.
",466,True,en,2
1051,9,2,3,Externals,sinbad,2016-03-01T16:09:31Z,192,2,4,1,"Fixes problem described in more detail in #1014 

Verifies that server still has all the remote refs we're using to diff which LFS objects to upload, in case one has been deleted without local knowledge and LFS objects have been GC'd in the mean time, which would lead to data loss. Proved that the test I added fails without the code change.
",343,True,en,1
1048,2,2,0,Internals,technoweenie,2016-02-25T20:34:44Z,11,0,2,0,"I've been wanting a Git LFS core team for a while. I wanted something more ""official"", but this at least gets us started.

/cc @andyneff @rubyist @sinbad 
",155,True,en,0
1045,1,1,0,Externals,andyneff,2016-02-25T17:28:50Z,1,0,1,0,"Removes the stray `man` binary causing havoc for man page creation.
",68,True,en,0
1042,1,0,0,Internals,technoweenie,2016-02-24T21:56:44Z,5,1,1,0,"Backported from the first commit in #1038.
",43,True,en,0
1039,1,0,0,Internals,technoweenie,2016-02-24T20:31:21Z,7,5,2,0,"Applying #1037 against the release-1.1 branch.
",47,True,en,0
1030,2,0,0,Internals,technoweenie,2016-02-23T21:11:14Z,36,11,9,0,"This backports #1025.
",22,True,en,2
1028,1,0,0,Internals,technoweenie,2016-02-23T20:11:15Z,49,15,7,0,"This backports #1023.
",22,True,en,1
1026,1,2,0,Internals,technoweenie,2016-03-31T18:49:33Z,0,176,2,37,"https://github.com/github/git-lfs/issues/985#issuecomment-181522174
",68,True,en,0
1025,2,1,0,Internals,technoweenie,2016-02-23T17:20:41Z,26,9,8,0,"This is a quick hack that ensures builds on go 1.6 work. Eventually, I want to start using `GO15VENDOREXPERIMENT=1`.
",117,True,en,1
1023,4,0,2,Internals,technoweenie,2016-02-23T17:51:22Z,49,15,7,0,"This fixes an issue when pushing or fetching where the ""inner error"" is dropped, making it difficult to diagnose problems.

This also tweaks an error message from `ensureFile()` /cc @rjbell4

``` bash
$ git push origin master
Trying to push ""a.wav"" with OID 87428fc522803d31065e7bce3cf03fe475096631e5e07bbd7a0fde60c4cf25c7.
Not found in /Users/rick/p/studious-goggles/.git/lfs/objects/87/42.
error: failed to push some refs to 'https://git-server.com/technoweenie/studious-goggles'
```
",486,True,en,1
1017,1,1,0,Internals,technoweenie,2016-02-22T16:10:48Z,11,3,1,2,"Found a few more places that weren't explicitly calling `Wait()`. /cc #1012 @sinbad
",84,True,en,0
1016,7,3,0,Internals,technoweenie,2016-02-22T18:04:43Z,123,36,4,2,"This updates the `ls-tree` command parser to use `-z`, which tells git to return lines split by a null terminator. This output is designed for scripts, and represents filenames with spaces and unicode better. See https://github.com/github/git-lfs/issues/987#issuecomment-186337634 for a more detailed writeup.

/cc @sinbad: I think we should try and use `-z` where possible. I copied `bufio.ScanLines()` and made `scanNullLines()`, so it should be easy to apply to other commands.

I also made sure `lsTreeBlobs()` calls `Wait()` on the `*exec.Command` object. Don't want another zombie herd (#1012).
",601,True,en,3
1012,3,5,0,Internals,technoweenie,2016-02-18T17:52:30Z,8,0,1,0,"Building on #1008 (/cc @rlaakkol). Just moved the `Wait()` call before closing the channels, as described in https://github.com/github/git-lfs/pull/1008#issuecomment-185353312.
",177,True,en,0
1007,6,10,9,Externals,jlehtnie,2016-04-08T16:36:46Z,198,0,8,52,"Fixes #459 and possibly helps for #515 and #766.
",49,True,en,3
1006,2,0,0,Internals,technoweenie,2016-02-22T18:25:10Z,17,8,1,6,"Fixes #1005
",12,True,en,0
990,3,3,0,Externals,larsxschneider,2016-02-11T17:13:35Z,42,12,1,1,"Run Git-LFS tests against the Travis-CI default Git version and the
latest available Git version on the respective platform.

The default Git version is currently 1.8.5.6 on Ubuntu and 1.9.3 on OSX.
",199,False,en,0
989,1,0,0,Internals,technoweenie,2016-02-10T16:07:32Z,7,5,3,0,"Not sure why I used the base64 url encoding. Fixes #938
",56,True,en,2
988,15,16,9,Externals,sinbad,2016-02-22T18:29:53Z,282,2,6,13,"Adds a new command `git lfs clone` which allows for more efficient cloning of LFS repositories by suppressing filters during clone/checkout then doing `git lfs pull` afterwards. Automatically suppresses error messages generated by this process. 

Addresses #931, thanks to @larsxschneider for the extensive analysis, this is 100% based on his findings.
",353,True,en,2
981,2,0,0,Internals,technoweenie,2016-02-05T22:47:13Z,17,6,1,0,"Dang, forgot to merge this. Fixes cross compilation on my windows vm.

EDIT: `script/bootstrap -os=windows -arch=386` was complaining about writing to `c:\windows\go-build...` because no TMP value is available. That's because `build.go` is setting `cmd.Env` with the `GOOS` and `GOARCH` values.
",295,True,en,0
980,2,1,0,Externals,larsxschneider,2016-02-05T23:26:38Z,7,1,2,0,"With the latest Git installed (2.7 right now) the following test are executed
in addition on Linux:

test/test-credentials-no-prompt.sh (git version < 2.3.0)
test/test-prune-worktree.sh (git version < 2.5.0)
test/test-push-bad-dns.sh (git version < 2.3.0)
test/test-worktree.sh (git version < 2.5.0)
",300,False,en,1
977,3,1,0,Internals,technoweenie,2016-02-04T18:22:13Z,39,3,3,0,"Allow clients to tweak the lfs http timeouts through the git config. It also bumps the normal timeout from 5s to 30s. I think the newer values make more sense for a command line tool.
",184,True,en,0
976,1,2,0,Externals,andyneff,2016-02-04T16:04:57Z,3,0,1,0,,0,False,en,0
975,1,1,0,Internals,technoweenie,2016-02-04T15:47:55Z,22,56,2,0,"Attempt to fix #870. The `git lfs track` command currently checks given patterns against the current working directory, preventing users from tracking files outside the repository. As pointed out in #870, this is actually incorrect. Via [gitignore docs](https://github.com/git/git/blob/f5b6079871904ba5b0a8548f91545f126caf898b/Documentation/gitignore.txt#L112-L114):

> A leading slash matches the beginning of the pathname. For example, `/{asterisk}.c` matches `cat-file.c` but not `mozilla-sha1/sha1.c`.

This removes that check, and the related tests.
",555,True,en,1
974,2,4,0,Internals,technoweenie,2016-02-04T15:44:18Z,41,0,5,0,"Fixes #973
",11,True,en,3
972,1,1,0,Internals,technoweenie,2016-02-04T15:40:36Z,24,25,1,0,"Finally tracked down and fixed the bug in reproduced from https://github.com/github/git-lfs/issues/904#issuecomment-169010912.

I couldn't replicate the issue with `git lfs fetch` and `git lfs checkout` individually, so I assumed the problem [came from `command_pull.go`](https://github.com/github/git-lfs/blob/064043040e1003b51f86b65c14d3f9bedc137f30/commands/command_pull.go#L45-L46).

I added some trace messages and noticed `fetchAndReportToChan()` wasn't [receiving all of the oids](https://github.com/github/git-lfs/blob/064043040e1003b51f86b65c14d3f9bedc137f30/commands/command_fetch.go#L288-L296), even though everything was downloading just fine. Turns out the transfer queues start working in the background as soon as [something is added to the queue](https://github.com/github/git-lfs/blob/064043040e1003b51f86b65c14d3f9bedc137f30/commands/command_fetch.go#L259). Moving the code that registers the transfer queue watcher above where the LFS pointers get added to the queue fixed the bug.

/cc @sinbad @rubyist I'd appreciate another set of :eyes: on this.
",1069,True,en,0
971,2,0,0,Internals,technoweenie,2016-02-04T15:43:25Z,39,4,5,0,"The `git` package provides an api around the `git` command. It doesn't make sense to pass any `GIT_TRACE` env values to it. Here are the errors just from the tests:

```
$ GIT_TRACE=1 script/test git
trace git-lfs: run_command: 'git' config -l
trace git-lfs: run_command: 'git' rev-parse HEAD --symbolic-full-name HEAD
--- FAIL: TestCurrentRefAndCurrentRemoteRef (0.21s)
    assert.go:16: /Users/rick/go/src/github.com/github/git-lfs/git/git_test.go:53
    assert.go:25: ! Sha: ""12:08:04.097045 git.c:348               trace: built-in: git 'show' '-s' '--format=%H"" != ""8263b6dfdc1ec816145ab1635d3719d54bfa8d67""
trace git-lfs: RECENT: Getting refs >= 2016-01-27 12:08:04.156600185 -0700 MST
trace git-lfs: RECENT: master (2016-02-03 12:08:04 -0700 MST)
trace git-lfs: RECENT: included_branch_2 (2016-01-31 12:08:04 -0700 MST)
trace git-lfs: RECENT: included_branch (2016-01-28 12:08:04 -0700 MST)
--- FAIL: TestRecentBranches (0.56s)
    assert.go:16: /Users/rick/go/src/github.com/github/git-lfs/git/git_test.go:149
    assert.go:25: ! []*git.Ref{
            &git.Ref{Name:""master"", Type:0, Sha:""12:08:04.394597 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
            &git.Ref{Name:""included_branch_2"", Type:0, Sha:""12:08:04.359162 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
            &git.Ref{Name:""included_branch"", Type:0, Sha:""12:08:04.323946 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
        } != []*git.Ref{
            &git.Ref{Name:""master"", Type:0, Sha:""c767f84c80519f760b7e267fcaaf8fb3645b6b34""},
            &git.Ref{Name:""included_branch_2"", Type:0, Sha:""e608c9454073e3cda9d58cc68bb23afa5ecd8fa0""},
            &git.Ref{Name:""included_branch"", Type:0, Sha:""7a2005c9affcd46807f3f32f323fe5417f994360""},
        }
    assert.go:28: !  - Refs should be correct
trace git-lfs: run_command: 'git' rev-parse HEAD --symbolic-full-name HEAD
trace git-lfs: run_command: 'git' version
trace git-lfs: run_command: 'git' rev-parse refs/heads/branch2 --symbolic-full-name refs/heads/branch2
trace git-lfs: run_command: 'git' rev-parse refs/heads/branch4 --symbolic-full-name refs/heads/branch4
trace git-lfs: run_command: 'git' rev-parse refs/heads/master --symbolic-full-name refs/heads/master
--- FAIL: TestWorkTrees (0.36s)
    assert.go:16: /Users/rick/go/src/github.com/github/git-lfs/git/git_test.go:259
    assert.go:25: ! []*git.Ref{
            &git.Ref{Name:""branch2"", Type:0, Sha:""12:08:04.831492 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
            &git.Ref{Name:""branch4"", Type:0, Sha:""12:08:04.946992 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
            &git.Ref{Name:""master"", Type:0, Sha:""12:08:04.796134 git.c:348               trace: built-in: git 'show' '-s' '--format=%H""},
        } != []*git.Ref{
            &git.Ref{Name:""branch2"", Type:0, Sha:""49a0848a1391a4d0dec5cf886386849928281484""},
            &git.Ref{Name:""branch4"", Type:0, Sha:""686de8859581179d3d429bb4810da38b51e79bac""},
            &git.Ref{Name:""master"", Type:0, Sha:""b7c05066c76446f4dc84f1842d3dadbcc40ff060""},
        }
    assert.go:28: !  - Refs should be correct
FAIL
FAIL    github.com/github/git-lfs/git   1.196s
```
",3268,True,en,1
966,3,5,1,Externals,nathanhi,2016-02-02T17:15:32Z,16,0,2,1,"This PR fixes the reported behaviour in https://github.com/github/git-lfs/issues/557, where Git reports
a delta, if an attempt was made to track empty files with LFS.
If there already have been empty files tracked with LFS, these
need to be untracked manually, as this fix only prevents that
newly created, empty files can be tracked by LFS.

Problem is, that Git never runs the clean filter on 0-byte files:

https://github.com/git/git/blob/80980a1d5c2678ab9031d7c60faf38b9631eb1ce/diff.c#L2777

This leads to a diff between the file in the repository (pointer file) and 
the actual file content. Apparently the git-fat project seems to be affected 
by this, too (https://github.com/jedbrown/git-fat/issues/18).
The fix/workaround for this in LFS is simple; just don't create pointers 
for 0-byte target files, it's useless to store them in LFS anyway.

I'm not too sure though if my current patch is sufficient - it just checks
if the given file from the parameters has a size == 0, but apparently the
pointer creation + hash calculation is done from the stdin content. So just
let me know if this needs a rework with length calculation of the stdin
io.Reader.
",1163,False,en,1
965,4,0,0,Internals,technoweenie,2016-02-01T17:03:56Z,18,8,4,2,,0,False,en,0
964,3,0,0,Internals,technoweenie,2016-02-02T17:53:55Z,80,12,3,3,"This converts `git://SERVER/REPO` remotes to an LFS URL like `https://SERVER/REPO.git/info/lfs`. This removes the need for users to manually configure the LFS url.
",164,True,en,1
963,3,5,0,Internals,technoweenie,2016-02-02T16:01:28Z,116,89,5,3,"This is another approach to fixing #922.

While #927 fixes the bug, I'm not completey happy with it. Calling `git.RootDir()` in `loadGitConfig()` adds another os exec that's run on _every_ lfs command. This is in addition to when it's run inside `resolveGitDir()` if the `GIT_DIR` is specified. I'd like to fix the behavior without running `git.RootDir()` again.

The problem: `git submodule update --init --remote` runs `git lfs smudge` commands with the following env:

```
GIT_DIR=/path/to/repo/.git/modules/sub
GIT_WORK_TREE=.
```

When run with the above ENV vars, `LocalWorkingDirectory` is `/path/to/repo/.git/modules`, which is wrong. It should be `/path/to/repo/sub`, where `sub` is the path for the submodule. Here's the [code](https://github.com/github/git-lfs/blob/84e9e66c9156564180c9621491865b985f3c838d/lfs/lfs.go#L187-L193):

``` go
func processWorkTreeVar(gitDir, workTree string) (string, string, error) {
    // See `core.worktree` in `man git-config`:
    // “The value [of core.worktree, GIT_WORK_TREE, or --work-tree] can be an absolute path
    // or relative to the path to the .git directory, which is either specified
    // by --git-dir or GIT_DIR, or automatically discovered.”

    if filepath.IsAbs(workTree) {
        return workTree, gitDir, nil
    }

    base := filepath.Dir(filepath.Clean(gitDir))
    absWorkTree := filepath.Join(base, workTree)
    return absWorkTree, gitDir, nil
}
```

If we treat `GIT_WORK_TREE=.` relative to the process' current working directory, it works just fine.  It seems like the comments (which are taken directly from the git docs) are wrong in this case. I can pass both `--git-dir` and `--work-tree` to get the status of my local git-lfs repo, from a totally different directory:

``` cli
~/test $ git --git-dir=/Users/rick/p/git-lfs/.git --work-tree=""/Users/rick/p/git-lfs"" status -sb
## rikdev-fix-submodule-lfsconfig...origin/rikdev-fix-submodule-lfsconfig
 M lfs/config.go
 M lfs/lfs.go
 M test/test-submodule-lfsconfig.sh
```

If I try relative to the `.git` directory, it doesn't work.

```
~/test $ git --git-dir=/Users/rick/p/git-lfs/.git --work-tree="".."" status -sb
## rikdev-fix-submodule-lfsconfig...origin/rikdev-fix-submodule-lfsconfig
 D ../.gitattributes
```

If I try relative to the current working directory, while in the git-lfs directory, it works:

``` cli
~p/git-lfs git:(rikdev-fix-submodule-lfsconfig) $ git --git-dir=/Users/rick/p/git-lfs/.git --work-tree=""."" status -sb
## rikdev-fix-submodule-lfsconfig...origin/rikdev-fix-submodule-lfsconfig
 M lfs/config.go
 M lfs/lfs.go
 M test/test-submodule-lfsconfig.sh
```

@sinbad @rikdev: Thoughts?  
",2646,True,en,3
952,2,10,0,Externals,bozaro,2016-02-04T20:10:07Z,52,0,3,9,"Use btrfs copy-on-write feature for copy lfs files from .git/lfs/objects to working copy (`git lfs checkout`).
Copy-on-write operation is look like hardlink, but change in one file is not visible in another file.

This command works like: `cp --reflink=auto src.txt dst.txt`
For this change I use https://github.com/wertarbyte/coreutils/blob/master/src/copy.c as reference.
",374,False,en,0
949,2,1,4,Externals,sinbad,2016-01-29T16:57:04Z,200,105,7,3,"Fixes #945 

Right now git-lfs ignores the use of 'remote.[name].pushurl' in asymmetrical pull/push situations (within a single remote). This PR changes the way Endpoints are built so that the operation (""download"" or ""upload"") is taken into account and the pushurl is used as a basis instead of the url when pushing. This avoids git-lfs behaving inconsistently with Git itself & the resulting confusion.

Also add support for 'remote.[name].lfspushurl' and global 'lfs.pushurl' so that push versions of urls are supported everywhere you might configure them.

This also affects the Access flags which are stored & looked up alongside the correct url based on whether you're pulling or pushing, in case the 2 urls have different auth mechanisms.
",746,True,en,2
933,1,3,0,Externals,larsxschneider,2016-01-14T18:14:51Z,3,0,1,0,,0,False,en,0
909,1,1,0,Externals,sinbad,2015-12-24T23:02:29Z,2,0,1,2,"If using an SSH URL and git-lfs-authenticate returns an error, without this change the error is just reported to the trace but execution continues.

A common result is a completely made up LFS URL being returned which then 404's, which ends up setting lfs.batch=false. If the server doesn't implement the non-batch interface, this config then breaks LFS even after the SSH issue is resolved & has to be manually removed, which is quite confusing for the user.
",460,True,en,0
907,1,1,0,Externals,wpsmith,2015-12-24T23:00:50Z,1,1,1,3,"Change PackageCloud link to go to more intuitive install page since this is what the list bullet is about.
",107,True,en,0
900,1,4,0,Externals,ro31337,2016-01-05T21:02:22Z,1,0,1,20,"Add installation instructions for Windows users.
",49,True,en,0
891,4,1,0,Externals,andyneff,2016-01-19T21:42:46Z,94,1617,34,43,"Added require for git back into rpm

-Moved Centos 6 build/tests to use IUS for a more official-ish git rpm. Removed our own git.spec file, as discussed in #878
-Change docker images to auto build images, which resulted in a slight name change. The old images will be taken down at a later time
-Got tests working again with new auto builds. They were a low priority, so they were purposefully left behind. But with discussion like #871, I wanted to make sure this was working again. It still doesn't work against package cloud keys yet, but since packagecloud doesn't sign rpms, it would appear there's no point there
-Cleaned up all files duplicated in the git-lfs_dockers repo.
-Updated README
-Since the dockerfiles are no longer in the docker directory, changed the run_dockers script to go by name (i.e. `debian_7` instead of filename `git-lfs_debian_7.dockerfile`, since there was no purpose behind the longer version)
",926,True,en,7
883,2,2,0,Internals,technoweenie,2015-12-21T00:49:06Z,6,2,1,17,"Fixes #880.
",12,True,en,0
882,2,2,0,Internals,technoweenie,2015-12-04T15:22:15Z,105,89,2,1,"My goal here is to describe more of the development workflow, and update the instructions for clarity. 
",104,True,en,0
879,1,2,0,Externals,ssgelm,2015-12-02T19:57:31Z,2,2,1,0,"Since git-lfs requires git >= 1.8.2 this ensures that people don't accidentally install it with older versions of git
",118,True,en,0
877,2,3,0,Externals,pabloguerrero,2015-12-01T23:32:11Z,2,2,1,0,,0,False,en,0
875,10,8,3,Externals,strich,2016-02-02T22:58:52Z,125,69,5,64,"A new INNO Setup based windows installer. Features:
- Issue #819 - The installer will search the PATH environment vars for the location of any actively installed Git instance and use it to find out where to place Git LFS.
- If Git isn't installed or isn't in the env vars then the installer will simply ask the user to tell it where to install Git LFS.
- The installer is dual arch and should run on 32/64bit systems. However no effort has been made to actually install the correct git-lfs.exe file yet.
- It hasn't been setup, but its possible to integrate code signing either in the compile commandline or in the script itself.
- Issue #799 - The installer and uninstaller run git lfs install/uninstall for you.

Should also fix:
- Issue #835.
- Issue #736.
",760,False,en,0
868,17,5,0,Externals,sinbad,2016-02-02T20:42:14Z,670,3,8,68,"Created a tool called `git-lfs-test-server-api` which can be pointed at either an API URL or a clone URL and will run through a series of tests to ensure the responses are as expected. See the `Readme.md` for details of how to use it.

Currently only tests the API responses to upload/download and through inference correct authentication; HTTPS or SSH, works with both via `--clone=<url>`. Relies on the internal methods to test that content types etc are respected. In order to try to keep it simple to update in future, it just calls the `Batch()` method rather than trying to dig any deeper than that.

It can either generate its own test data (in which case it needs to be able to upload some initial state, although it doesn't push any commits, only LFS files), or it can be given lists of data to test with, in which case no server state is modified. In the latter case the content server is not hit at all, only the API.

I wrote this to provide a repeatable smoke test for API implementations, extensions for cases I haven't thought of are welcome, although as mentioned I didn't really want to go any lower than `Batch` to make it easier to keep in sync later.
",1171,True,en,3
863,1,1,0,Externals,sinbad,2015-11-25T15:27:57Z,50,50,7,0,"objectResource is returned by several public functions but isn't exported itself, so fix that. 

Context: I'm using calls to Batch() in my server API test tool which is outside the LFS package & need to see the results. I remember I also needed it when refactoring the API for my old SSH PR so I think it's likely to be useful generally.
",338,True,en,2
862,10,7,8,Internals,technoweenie,2016-02-23T20:10:47Z,211,110,8,90,"This is a quick experiment in extracting some stuff into a proper `localstorage` package. See #778 for details.
",112,True,en,1
861,1,1,0,Internals,technoweenie,2015-12-04T15:22:35Z,10,7,1,9,"We don't care if other git values clash.
",41,True,en,0
860,2,1,0,Internals,technoweenie,2016-01-29T16:37:36Z,9,17,2,65,"Having both `git.CurrentBranch()` and `git.CurrentRef()` seemed redundant.
",75,True,en,0
851,2,7,0,Externals,noamt,2015-11-25T14:48:00Z,2,6,1,4,"Ubuntu repositories no longer offer the Ruby2.0 package, thus breaking the script
",82,True,en,0
843,1,2,0,Internals,technoweenie,2015-11-19T00:08:24Z,46,17,1,0,"Updated the script to upload packages for Ubuntu, AND generate a bunch markdown links for the releases page to manually download them.

NOTE: I already ran this, so the ship has sailed for v1.1 :)

/cc @ssgelm and @andyneff 
",225,True,en,0
842,10,0,0,Internals,technoweenie,2015-11-18T18:24:44Z,103,26,6,0,"This prevents Git LFS from getting into an auth loop if no git credentials are found. It also adds a bit more tracing so we don't have to reach for `GIT_CURL_VERBOSE` as often. And when we do, its output is cleaned up a bit with extra linebreaks.
",247,True,en,2
838,4,0,0,Internals,technoweenie,2015-11-18T00:25:30Z,241,132,20,1,"This renames both `git lfs init` and `git lfs uninit` to `git lfs install` and `git lfs uninstall`.  The old commands will be available until Git LFS v2.0.

Fixes #781
",168,True,en,2
837,7,0,2,Internals,technoweenie,2015-11-18T00:24:52Z,177,25,6,1,"This changes Git LFS to read committed lfs config settings from `.lfsconfig` instead of `.gitconfig`. This makes it more clear what settings should go in that file. It does continue to check for `.gitconfig` but only IF `.lfsconfig` does not exist. This is meant as a way for projects to gradually rename this file on their own. By Git LFS v2.0, we'll remove support completely.

This also makes a few other changes:
- `ListFromFile()` doesn't run `os.Stat` anymore. The new `readGitConfigFromFiles()` function minimizes `os.Stat` calls.
- The config order was tweaked slightly, reducing the number of `git config` calls. No need to call `git config --list` AND `git config --file .git/config --list`. Now it only calls `git config --file .lfsconfig --list` and `git config --list`.

Fixes #780
",795,True,en,2
831,1,6,0,Externals,AndrewJDR,2015-11-16T22:56:27Z,12,9,2,4,"This change makes it so --skip does the smudge if the file
is in cache. It still skips automatic downloads as one would
expect.

This is more convenient, since it prevents one from having
to 'git lfs pull' after every 'git checkout' if the needed
objects are already available in .git/lfs/objects.

Note that the --skip option for smudge is documented as
follows:
""Skip automatic downloading of objects on clone or pull.""
So even after this change we're still in line with the
documentation.
",492,False,en,1
828,1,2,0,Externals,jiangxin,2015-11-16T19:17:22Z,2,2,1,5,"If there are multiple remotes for the current repo, `git lfs env` shows wrong SshUserAndHost for remote endpoints.
",115,True,en,0
821,2,1,3,Internals,technoweenie,2015-11-16T18:48:04Z,193,4,2,9,"This is a proposal to merge into #820. It's complicated enough that I think it could use its own review.

Instead of buffering the entire request body into an in-memory byte buffer, this uses an internal `cloneableBody` type that only buffers up to 1MB. Any overflow is then written to a local temp file. This type can also clone itself without reading the body again. It simply creates a new struct with the same 1MB byte buffer, and re-opens the temp file.

Also, assuming all file handles are properly closed, a `cloneableBody` buffer will only delete the tempfile when the last one is closed. 
",598,True,en,1
820,55,2,0,Internals,technoweenie,2015-11-16T18:50:34Z,8896,10,74,9,"This makes some changes to #714:
- Moved some `!Config.NtlmAccess()` checks to lower level helper functions, so that every caller of these functions doesn't have to also check for ntml access.
- Use a standard tracer message for `toggleAuthType()` so every caller doesn't have to define one.
- Removed some ntlm specific helpers like `isNtlmRequest()`. Trying to remove as much ntlm special casing as possible.
- Remove some spots where http response bodies are closed multiple times.
- Automatically set `ConcurrentTransfers()` to 1 if ntlm authentication is used, so users aren't required to set this value themselves. 
- Removed some redundant internal helper functions in favor of the stdlib (`ioutil.NopCloser()` is pretty cool, for example).

@WillHipschman: Normally I'd just leave feedback for you to fix. But I didn't because the diff on #714 includes some changes in master that were made after the PR was opened. It made it really difficult to review. Seems like a GitHub PR issue, and nothing to do with your actual work. 

There is still an `ioutil.ReadAll()` when cloning an http request, though. If NTLM auth is used for any file requests (as opposed to just LFS API requests), it should definitely buffer to a file instead. Maybe buffer up to 1MB in memory, and put the overflow in a temp file.
",1311,False,en,13
818,1,2,0,Externals,sinbad,2015-11-16T20:49:06Z,24,2,2,10,"To reproduce, run this with an unmatched git lfs:

``` bash
git init track-symlinkdst
ln -s track-symlinkdst track-symlinksrc
cd track-symlinksrc
git lfs track ""*.png""
```

This was accidentally caused by the move to use `git rev-parse --top-level` to find the working dir. While more reliable than previous manual methods, git also silently resolves symlinks in the returned path, meaning that `lfs.LocalWorkingDir` is always the real path and not the symlink. This causes `HasPrefix` tests to fail unless you also check the resolved symlink version.
",552,True,en,1
812,1,5,0,Externals,laurent-barbisan-ullink,2015-11-03T16:17:48Z,2,1,1,0,,0,False,en,0
807,5,1,0,Externals,andyneff,2015-11-17T21:31:22Z,28,25,3,17,"- `run_dockers.bsh` can now auto pull the latest docker images
- More verbose (and un cut) output of 64 bit rpm builds build. No more redirect to `build.log`
- RPMs use GIT_LFS_TEST_DIR in %check
",196,False,en,0
806,1,0,0,Internals,cjs,2015-11-02T18:05:54Z,1,1,1,3,"Minor change to fix broken spec.md link
",40,True,en,0
801,1,0,0,Internals,technoweenie,2015-10-28T16:18:54Z,67,16,4,0,"Should fix #794

/cc @sinbad @rubyist 
",39,True,en,0
795,1,1,0,Internals,technoweenie,2015-10-28T16:14:03Z,13,10,3,0,"This fixes a devious bug that affects strict LFS API servers that verify the size of objects before it lets you download them. 

The update is hopefully temporary, until we refactor the API client as described in https://github.com/github/git-lfs/issues/779.

You can see this at play with `GIT_CURL_VERBOSE`:

``` bash
# manually triggering the smudge command
$ git cat-file -p 1bca198451cc7404e257e5abe60a8478bf28d4cf | GIT_CURL_VERBOSE=1 git lfs smudge
Downloading ... (73.53 KB)
> POST /github/git-lfs-test.git/info/lfs/objects/batch HTTP/1.1
> Accept: application/vnd.git-lfs+json; charset=utf-8
> Authorization: Basic abcdef
> Content-Type: application/vnd.git-lfs+json; charset=utf-8
> User-Agent: git-lfs/1.0.1 (GitHub; darwin amd64; go 1.5.1; git a999185)
>
{""objects"":[{""oid"":""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7"",""size"":0}],""operation"":""download""}
```

Here it is with the fix:

``` bash
$ git cat-file -p 1bca198451cc7404e257e5abe60a8478bf28d4cf | GIT_CURL_VERBOSE=1 ~p/git-lfs/bin/git-lfs smudge
Downloading ... (73.53 KB)
> POST /github/git-lfs-test.git/info/lfs/objects/batch HTTP/1.1
> Accept: application/vnd.git-lfs+json; charset=utf-8
> Authorization: Basic abcdef
> Content-Type: application/vnd.git-lfs+json; charset=utf-8
> User-Agent: git-lfs/1.0.1 (GitHub; darwin amd64; go 1.5.1; git 25bbe79)
>
{""objects"":[{""oid"":""e1732d149d262963996ca77a47a5d3c51c85c6e97187afad370a8bef2828b6b7"",""size"":75291}],""operation"":""download""}
```
",1478,True,en,1
793,6,0,0,Internals,technoweenie,2015-10-27T18:24:56Z,71,38,4,0,"`script/integration.go` doesn't work on Windows. This fixes the easy bugs:
- file patterns didn't use back slashes
- use `which` to find the correct bash path

It still shows no output for each test though.
",207,False,en,1
792,1,0,0,Externals,sinbad,2015-10-27T12:49:27Z,1,1,1,0,"I had a failure after #790 but it was because I had an old .orig file in my test dir from a previous rebase conflict.
",118,True,en,0
790,5,1,0,Internals,technoweenie,2015-10-26T23:25:53Z,163,39,9,0,"Replace 3 highly compact shell lines in `script/integration` with 100 lines of go code. It uses goroutines to manage the concurrency, and a channel to ensure output is dumped to stdout without race conditions.

/cc @andyneff @rubyist @sinbad 
",243,True,en,5
788,1,2,0,Internals,technoweenie,2015-10-26T19:58:22Z,16,1,1,0,"The `lfs.fetchinclude` and `lfs.fetchexclude` keys seem save to read from the working directory's `.gitconfig` file. /cc @sinbad @ptoomey3 

Docs: https://github.com/github/git-lfs/blob/master/docs/man/git-lfs-fetch.1.ronn
",223,True,en,0
784,1,6,0,Externals,andyneff,2015-11-17T22:02:30Z,56,0,1,24,"First working version producing an unsigned git-lfs.exe
",56,True,en,0
783,1,0,0,Externals,andyneff,2015-10-26T23:13:36Z,4,4,1,3,"Moved the the docker image generation to a separately maintained repo
and upload the images to docker hub instead. Should be a far friendlier
experience for the developer.

Almost all of the files in the docker folder should be redundant save
the `run_dockers.bsh` file at this point.
",285,False,en,0
776,1,0,0,Internals,technoweenie,2015-10-23T16:35:47Z,5,5,1,0,,0,False,en,0
775,1,0,0,Internals,technoweenie,2015-10-23T16:12:57Z,1,1,1,0,"Fixes #774
",11,True,en,0
772,5,0,0,Internals,technoweenie,2015-10-27T12:51:58Z,31,7,6,4,,0,False,en,0
771,25,10,0,Externals,sinbad,2015-10-26T14:25:36Z,361,188,10,3,,0,False,en,10
770,1,1,0,Externals,sinbad,2015-10-22T14:12:49Z,50,2,2,0,"Smudge command should return 0 if download was optional and didn't occur
",73,True,en,1
765,1,1,0,Externals,sinbad,2015-10-21T15:44:41Z,7,1,2,0,"Attribute checks whether it thinks the setting is already in the desired state before setting, but for global options was using plain `Find()` which uses `git config` without any flags, which makes it pull in local state too. It should have been using the `--global` flag to get the current value just like it does when setting it. 

Before this fix it could incorrectly assume the global setting is there already and skip setting it, even though when you move out of that folder the setting disappears. This was causing some random failures on Windows tests. Separated from the rest of the Windows test fixing work because it's actually a general bug.
",653,True,en,0
763,17,12,13,Internals,technoweenie,2015-10-23T02:23:58Z,249,442,14,2,"This is an attempt to solve #266. If `git-lfs` is exited while downloading, it leaves some `.git/lfs/objects/../../OID-temp` files, causing future downloads (`smudge`, `fetch`, or `pull`) to error out until those temp files are deleted.

This used to work using my [contentaddressable package](https://github.com/technoweenie/go-contentaddressable) which used the `O_EXCL` file mode to ensure only one process writes to a file at a time. This breaks if the process exits without letting Go's `defer` clean the file up.

This PR changes a few things. First, it drops the contentaddressable package in favor of the [atomic package](https://github.com/natefinch/atomic). While `os.Rename()` works as an atomic operation on posix systems, it doesn't on Windows. The atomic package uses Windows APIs to provide the same atomic guarantee in `atomic.ReplaceFile()`.

It also throws all temp object files into `.git/lfs/tmp/objects`, so it's easy for `git-lfs` to clean the files up on exit. Multiple `git-lfs` processes will have their own sets of temp files. It's possible that multiple `git-lfs fetch` operations will download a file multiple times. But, it should only move the file to it's final spot (`.git/lfs/objects/../../OID`) IF the temp file is written successfully and the SHA-256 signature of the contents matches the expected OID.

This SHOULD work fine on linux/mac, but needs a bit more work for Windows support.

TODO:
- [x] drop `contentaddressable` package
- [x] Add `atomic` package, replace `os.Rename()` usage with `atomic.ReplaceFile()`.
- [x] have git-lfs cleanup old temp files automatically on exit.
",1619,True,en,4
761,2,2,0,Internals,technoweenie,2015-10-21T18:07:07Z,31,2,3,1,,0,False,en,0
760,1,4,4,Internals,technoweenie,2015-10-21T19:07:23Z,118,24,3,1,"This whitelists the valid keys that are read from `.gitconfig`. Git LFS can't make Git read options from `.gitconfig` by default, but it should be explicit about what it allows.
- `lfs.url`
- `remote.{name}.lfsurl`
- `lfs.extension.{name}.priority`

The `.gitconfig` file is designed for common settings for all users cloning.  IMO the other settings should be set by a user's standard git config.
",398,False,en,2
756,2,0,0,Internals,technoweenie,2015-10-20T15:29:50Z,54,13,5,0,"Fixes #717 and supercedes #752.
1. Only skips the tests in docker IF `LFS_DOCKER` is set. This may change before we ship 1.0.1, but at least now I know ALL tests run locally and on Travis.
2. Changed `lfs.InRepo()` so it looks for an empty `LocalGitDir`, instead of `LocalWorkingDir`. Bare repositories have no working directory.
3. Updated the `update` and `init` tests to check that the hooks dir is not created.
",415,False,en,2
750,3,6,0,Externals,glensc,2015-11-18T18:30:22Z,1,1,1,32,"cleanup BR, the tools are not used during build.
they were added in initial commit, 4a716277, so likely bad copy-paste
",119,False,en,0
749,2,7,4,Externals,glensc,2015-11-18T00:27:58Z,1,1,1,32,"update Source0 url to use existing url
",39,True,en,0
742,60,3,5,Externals,sinbad,2015-11-16T19:27:47Z,1893,29,21,32,"I think this is finally ready for review now. Please see `docs/man/git-lfs-prune.1.ronn` for details of what it does and how it determines what to retain and what to delete.

I've created quite a detailed set of tests and think I've covered everything, but please do scrutinise, since this does involve deleting user data!
",323,True,en,9
735,1,1,0,Externals,sinbad,2015-10-19T19:49:10Z,2,1,1,6,"Also report stderr/out since error object is often something useless like ""exit status 128"".
To help with #725. 
",113,False,en,0
734,3,0,0,Externals,sinbad,2015-10-20T15:22:41Z,114,27,5,7,"Raised as part of #731 

Includes some changes to the test git server which actually wasn't strictly complying with the 1.0 API spec. Also includes a couple of tweaks to make errors from transfer queue identifiable to the oid that caused them.

Added a 'delete' method to the git test server just for testing purposes, to create a failing condition.
",350,True,en,3
732,3,5,0,Internals,rubyist,2015-10-19T19:55:14Z,1,0,1,6,"This will cause the git checkout to abort instead of continue on as if things are OK.

/cc https://github.com/github/git-lfs/issues/731
",136,True,en,0
718,1,3,3,Externals,bozaro,2015-10-19T19:45:35Z,14,3,1,11,"It's fix authentication issue on ssh error messages like:

```
X11 forwarding request failed
```
",97,True,en,0
715,10,5,1,Internals,rubyist,2016-03-03T18:03:49Z,1317,25,15,148,"This PR adds support for using netrc for LFS API requests. The priority becomes:
1. Check the LFS URL for authentication. Ex: http://user:pass@example.com
2. Check netrc for authentication.
3. Check the Git remote URL for authentication IF it's the same scheme and host of the LFS URL.
4. Ask 'git credential' to fill in the password from one of the above URLs.

TODO:
- [x] Add netrc support
- [x] Add automated tests
- [x] What happens on Windows? Does netrc work there?

//cc #705 
",485,False,en,3
714,35,8,25,Externals,WillHipschman,2015-11-16T18:50:35Z,8719,13,73,40,"This a first attempt at adding NTLM auth. It addresss the proposal in #617. Please let me know your thoughts.

It uses lfs.{endpoint}.access to toggle NTLM and most ntlm specific logic is in its own class. We store user/pass in the cred helper but could later go get them from AD.

Things that still need to be done:
1. Add Tests-I can add unit tests but I don't think migrating the whole test infrastructure to support windows environments should block this.
2. Add documentation.
",482,True,en,13
713,7,1,6,Externals,sinbad,2015-10-20T15:21:32Z,202,21,6,13,"This fixes #660 and also improves a few other areas:
- Default remote is now either the tracked remote, or ""origin"" or any other _single_ remote defined. If all of these fail there's a better error message now.
- User-supplied remotes are now validated to avoid ambiguous fail cases
- General tidy up to make it clearer what each of these git package functions are intended to do
",380,False,en,2
711,2,4,0,Internals,rubyist,2015-10-21T16:26:25Z,28,0,1,15,"The smudge filters still used the direct legacy api via the `Download()` function. This PR provides a new `Download()` which uses the batch API and falls back to a `DownloadLegacy()` if the server does not support the batch API.

This fixes #708
",246,True,en,0
710,2,2,0,Internals,rubyist,2015-10-19T19:20:11Z,2,1,2,13,"A status of 403 against the API would be masked with a generic message. This displays a more specific message - either one returned in the API json, or a default message about authentication.
",192,True,en,1
704,1,1,0,Externals,revi,2015-10-05T16:18:58Z,1,1,1,0,"Extensibil**_i**_ty, not extensibilty.
",39,True,en,0
702,1,1,0,Externals,sinbad,2015-10-05T16:52:27Z,5,5,1,0,,0,False,en,0
692,1,1,0,Externals,sinbad,2015-10-19T20:12:38Z,64,42,3,17,"This causes tests to fail if GIT_LFS_TEST_DIR is not set, since the bare repo tests actually cascade up to the git-lfs repo itself and start modifying config files in there. Might potentially affect other cases where a bare repo is inside a non-bare repo.

Resolution is to use `git rev-parse` to locate all dirs instead of manually recursing. Could potentially remove manual processing of GIT_DIR and GIT_WORK_TREE in future but have left as belt & braces for now.

Had to remove test for using relative GIT_WORK_TREE with no GIT_DIR, git rev-parse always fails in that case so it appears it's not supported by git even though man git-config claims it is.
",657,True,en,1
691,1,0,0,Externals,sinbad,2015-10-19T19:32:08Z,2,2,1,17,"It was erroneously succeeding when that was set because the test was incorrect, should have been checking the env did NOT include GIT_LFS_SKIP_SMUDGE after unsetting. However any LFS env setting would false-positive and therefore work in Travis.
",246,True,en,1
690,3,7,0,Externals,WillHipschman,2015-10-19T19:09:14Z,5,3,2,17,,0,False,en,1
689,3,1,0,Externals,kaleworsley,2015-10-01T20:44:31Z,3,3,3,0,,0,False,en,0
686,10,0,0,Internals,technoweenie,2015-10-01T01:36:06Z,120,74,13,0,"This bumps the version number, and makes a few changes to get the docker scripts to run.
- Skipped some tests that depend on `GIT_LFS_TEST_DIR`. 
- Hardcoded the root path in `docs/man/mangen.go` so that Git LFS builds on the Debian docker images.
",248,False,en,6
685,1,1,0,Externals,sinbad,2015-09-30T23:13:34Z,6,2,1,0,,0,False,en,1
684,2,1,0,Internals,technoweenie,2015-09-29T19:28:26Z,56,6,5,3,"Git LFS uses a few properties to determine whether something is a valid LFS pointer or not. Right now, the criteria is:
1. Below the blob size threshold (1024 bytes)
2. Contains `git-lfs` in the content.

This causes problems for small test files like ""this is a sample git-lfs file."" So, it assumes anything that doesn't even start with `version` isn't even trying to be a Git LFS file.

/cc @rubyist: Did this by elevating the bad pointer key message to its own error type.
",476,False,en,3
682,2,0,1,Internals,technoweenie,2015-09-28T22:48:19Z,35,9,2,3,"This adds a few more crucial details. This is just a start.
1. PackageCloud and Homebrew are listed as official release channels for Git LFS now.
2. The doc homepage is expanded a bit and includes a spot for video tutorials.
3. The new `help` command is featured.
",264,False,en,0
681,4,1,0,Internals,technoweenie,2015-09-30T16:47:00Z,75,9,3,5,"This builds on #680:
- `lfs.ScanTree()` is used _instead of_ `lfs.ScanRefs()`. Duplicate files are now shown.
- The output includes the LFS OID and whether the file has the lfs pointer or the actual contents.
",209,False,en,1
679,8,4,0,Internals,technoweenie,2015-09-25T16:45:03Z,214,31,11,1,"This is an attempt at a workaround for #616. It's not ideal, but it gives users a way to optimize their downloads at the cost of complicating the git workflow a bit.

``` bash
# downloads all files through smudge
$ git clone foo/bar.git

# downloads all files in a single batch command instead
$ GIT_LFS_SKIP_SMUDGE=1 git clone foo/bar.git
$ git lfs pull
```

That workaround sucks. We can make this better for users with:

``` bash
# update smudge filter for all repos
$ git lfs init --skip-smudge

# update smudge filter for only the local repo
$ git lfs init --skip-smudge --local
```
",588,True,en,4
677,1,1,0,Internals,rubyist,2015-09-22T17:00:44Z,1,1,1,0,"This simple change goes from errors like this:

```
$ git push origin master
(0 of 1 files) 0 B / 33 B
Error for POST http://localhost:8124/rubyist/foo3/objects/batch
error: failed to push some refs to 'http://github.com/rubyist/foo3.git'
```

To this:

```
$ git push origin master
(0 of 1 files) 0 B / 33 B
Post http://localhost:8124/rubyist/foo3/objects/batch: read tcp 127.0.0.1:8124: connection reset by peer
error: failed to push some refs to 'http://github.com/rubyist/foo3.git'
```

This error path can be triggered by a number of network issues, this lets the original error message bubble through which can help in debugging. The data from the message we were providing is already included in the original error string.
",730,True,en,0
676,10,5,0,Internals,technoweenie,2015-09-21T21:02:24Z,416,48,19,0,,0,False,en,17
675,1,0,0,Internals,rubyist,2015-09-21T20:58:37Z,4,2,1,0,"Reported in #673 

A nil check in the wrong place was preventing the retry mechanism from working in the older single mode API which had the side effect of allowing git-lfs to exit cleanly even though it failed to push.
",220,True,en,0
671,4,2,0,Internals,technoweenie,2015-09-23T16:57:42Z,22,16,6,5,"Instead of requiring `git lfs update` to be run inside a git working directory, this relies on `lfs.LocalGitDir` to install the hooks in the correct place.

/cc @ttaylorr since you touched hook code recently. Though I'm pretty sure I'm the one that added the invalid repo error. 
",280,True,en,2
670,6,3,2,Internals,technoweenie,2015-09-23T17:00:07Z,63,89,24,5,"A few minor tweaks. The output of `help subcmd` and `subcmd -h` are now identical. Also, leading and ending linebreaks are consistent.

/cc @sinbad
",148,True,en,0
669,1,0,0,Internals,technoweenie,2015-09-17T21:06:30Z,26,4,3,0,"I like having integration tests for stuff like #668. Partly because it forces me to see how the error is handled externally. This changes the `git.CurrentRef()` error check to simply print an error and exit, as opposed to logging a stack trace.

@Aorjoa: This is just a bit of polish on your fix in #668
",304,True,en,1
668,2,2,1,Externals,Aorjoa,2015-09-17T20:52:33Z,16,0,2,0,"This PR for command `git lfs ls-files` and then error `index out of range` issue according #664 
",97,True,en,1
666,1,15,0,Externals,sinbad,2016-05-16T20:11:31Z,110,0,1,245,"I've given locking some thought before so I've pulled out my notes about how I think it could work for a git-lfs proposal.
",123,True,en,0
665,6,7,5,Externals,sinbad,2015-09-17T21:37:37Z,169,0,4,3,"Call 'go generate ./commands' to generate code from .ronn files which the cobra command can then use. Added to the build scripts but needs to be done manually at least once to test it outside that. 

I've done the minimum re-formatting for now. The man format is pretty damn ugly on the command line and I'd like to do better but didn't want to spend time on that until the principle was approved. For now it just fixes the backtick issue, other things we could do:
- Strip off the 2-line headers
- Strip 'SYNOPSIS' and pull out the command summary as the first line
- Strip '##' section markers generally
- Use an abbreviated form for `command --help` (just contents of SYNOPSIS, DESCRIPTION and OPTIONS) and only print the full text for `help command`. Cobra splits this as Usage/Help, currently it's the same for both.

If you think this is a good idea I can hack on it some more.
",884,True,en,0
659,1,1,0,Internals,technoweenie,2015-09-23T17:18:02Z,50,0,1,11,,0,False,en,0
658,1,3,0,Internals,technoweenie,2015-09-14T15:23:39Z,0,2,1,2,"This removes Go 1.3 and 1.4.2 from the tests. As of v0.6.0, we're now shipping all binaries compiled with Go 1.5.1. The linux packages also bundle Go 1.5.1 to compile.

Obviously, our tests will run in about 1/3rd the time. We can also start supporting newer std lib features and code syntax that we couldn't with Go 1.3.

Any objections? This should only affect git lfs contributors and homebrew users. I think we can configure the git lfs recipe to require Go 1.5+ though.
",475,True,en,0
657,2,1,0,Externals,andyneff,2015-09-11T17:45:39Z,0,1,1,0,,0,False,en,0
656,1,1,0,Externals,sinbad,2015-09-11T15:43:24Z,4,3,1,0,"You could still end up with duplicated seeds between commits which could cause unintended consequences.
",104,True,en,1
654,1,1,0,Externals,andyneff,2015-09-11T17:05:38Z,66,17,9,0,"Added GOLANG_VERSION to override golang version
Disabled dependecy checking when building packages to support external
golang
Changed DOCKER_LFS_BUILD_VERSION to default to master instead.
",189,False,en,0
652,2,0,0,Internals,technoweenie,2015-09-11T03:04:34Z,50,31,3,0,"This fixes a regression with the Git LFS v0.6.0 client and GitHub Enterprise 2.2.8/2.3.2.

/cc @ginja
",102,True,en,1
651,8,2,5,Internals,technoweenie,2015-09-10T17:15:45Z,284,220,8,0,"Did I miss anything in the changelog? How do the subheaders look? I organized the fixes to break the giant list of changes up.

[rendered](https://github.com/github/git-lfs/blob/b78cd7a4a5107b4a73dc4a29a19b9e46da0eaeba/CHANGELOG.md)
",233,True,en,0
650,1,1,0,Internals,technoweenie,2015-09-10T17:11:22Z,3,7,1,0,"While running my QA checks, I noticed that the auth type wasn't being set at all:

```
$ git lfs env
git-lfs/0.6.0 (GitHub; darwin amd64; go 1.5; git 19105ed)
git version 2.3.0

Endpoint=https://github.com/github/git-lfs.git/info/lfs (auth=none)
```
#611 introduced various constructors for different types of requests that the client makes:
- `doApiBatchRequest()` - LFS Batch API requests
- `doLegacyApiRequest()` - Legacy LFS API requests.
- `doAPIRequest()` - Common function for ALL LFS API requests.
- `doStorageRequest()` - Storage requests (these actually upload and download the objects).

`doAPIRequest()` requires credentials for all non-GET requests. But all Batch API requests are POST. This is a pretty small change, but highlights that the project needs better tests around this stuff.
",801,True,en,0
647,2,0,0,Externals,sinbad,2015-09-09T15:23:42Z,11,8,2,0,"Fixes 2 issues with the test package:
- AddCommits: multiple random files of the same size in commit 0 are now guaranteed to be different
- Make sure the global dir vars are updated when using test.Repo
",203,False,en,1
646,12,10,4,Internals,technoweenie,2015-09-10T13:28:28Z,383,65,8,1,"This uses the `lfs.ScanRefsMode` scan mode when pushing if the `--all` flag is given. This lets you confirm that everything referenced in the given ref has been pushed to the given remote.
",189,True,en,4
644,9,3,1,Internals,technoweenie,2015-09-08T21:04:54Z,162,21,21,0,"This prevents 7 commands from blowing up because they're not run from inside of a repository. It also makes a couple slight tweaks to the integration test suite:
1. The verbose logs at the end of a failure (server logs and your local env) are ONLY shown from `script/cibuild`. We care about this output on CI servers, but probably not on our local machines.
2. The trace file is truncated after every individual test. This way a test failure will show just its own git trace log, not the trace log for every test that has run in the file.
",539,False,en,9
642,5,7,14,Internals,technoweenie,2015-09-10T13:30:05Z,68,0,3,3,"This attempts to detect Git in common dirs like:
- `C:\Program Files\Git\mingw64\bin` (Git For Windows)
- `C:\Program Files\Git\bin`
- `C:\Program Files (x86)\Git\bin`

We should try to support every common way to install Git on Windows. Not sure what to do about native tools though. Ideally, they'd just bundle Git LFS. Until then, we can add them to the list.

I also didn't try to run ""git lfs init"" for the user. It seems like Git For Windows and GitHub Desktop include their own ""Git Bash"" commands with the proper env. Users should run the init command there.

/cc @ssgelm: you expressed interest in a Windows installer.
",628,False,en,0
638,1,2,3,Internals,technoweenie,2015-09-04T17:19:54Z,2,1,1,0,"I think it's coming from [here](https://github.com/github/git-lfs/blob/10dbfb5da854b3a4a1aefbb073e4aef7d0f4e898/lfs/attribute.go#L32-L47). Sometimes it returns the smudge error before the clean error. This might be a slight regression from #619. I'll have to see if the older code returned errors for every attribute and not just the first one.
",345,True,en,1
637,1,2,0,Internals,rubyist,2015-09-04T15:34:01Z,5,0,1,0,"This was causing the intermittent batch error test failures under go 1.5. It was possible that the queue's `Wait()` function returned before all of the errors had been collected. This PR ensures error collection has finished.
",226,True,en,0
636,1,1,0,Internals,rubyist,2015-09-04T14:57:34Z,5,0,1,0,"This PR turns on `GIT_TRACE` when running the integration tests and displays the output when a tests fails.
",108,True,en,1
635,4,5,0,Externals,sinbad,2015-09-07T15:05:50Z,84,12,2,3,"Fixes #632 
",12,True,en,1
634,3,1,0,Internals,rubyist,2015-09-08T14:32:17Z,49,2,2,4,"Raised in #609

The legacy api path had no 401 handling, so the call would be treated as a success, allowing `git push` to exit cleanly. This PR handles a 401 in the legacy path the same way the batch path handles it, i.e. re-prompting for credentials.
",253,True,en,0
633,8,5,4,Externals,sinbad,2015-09-07T15:05:34Z,252,16,5,3,"Support for `git lfs fetch --all` for backup/migration purposes. 
",66,True,en,1
631,1,2,0,Externals,sinbad,2015-09-03T18:16:03Z,2,2,1,0,"Travis didn't spot this because it's using a git version < 2.5.0
",65,True,en,1
630,1,1,0,Internals,technoweenie,2015-09-02T20:49:43Z,4,0,1,0,,0,False,en,0
629,5,5,0,Internals,technoweenie,2015-09-07T19:08:02Z,123,26,7,5,"This removes the `AuthType` type in favor of strings. Also adds some unit tests. The only behavior change is that `Config.Access()` returns ""basic"" if `lfs.{url}.access` is still using the legacy ""private"" value.
",213,True,en,2
628,2,4,0,Internals,technoweenie,2015-09-03T13:12:59Z,27,22,2,0,"Adds a more explicit bool parser based on `strconv.ParseBool()`. May want to write to stderr if a config value is invalid (such as `42` or `-1`).
",146,True,en,1
627,2,4,0,Externals,sinbad,2015-09-02T16:05:18Z,6,21,3,0,"The test for lack of batch support turned it off globally on the test server then turned it back on, but since the server is shared between parallel tests, this introduces a race condition which can break other batch tests randomly. Instead, use a specific repo name to flag it.

Found this while investigating #625 although this isn't the complete fix. [Edit]Now it is.
",371,True,en,2
626,2,7,0,Externals,sinbad,2015-09-02T20:20:52Z,26,2,2,0,"This is needed to disambiguate cases where a user has multiple usernames
on the same host. Without this the first item will be silently used
which might be wrong & cause a loop of incorrect password prompts (&
possibly a lockout on the server)
",244,False,en,1
624,11,4,8,Internals,technoweenie,2015-09-02T16:53:52Z,140,174,11,0,"This makes two changes for a Git LFS v0.6.0 release:
1. It now sets `lfs.{endpoint}.access` to ""basic"", not ""private"". This is an attempt to make the config forward compatible with possible alternate authentication methods, such as NTLM #617.
2. It now tries the batch API by default, setting `lfs.batch` to ""false"" if it has to fall back to the legacy API.
",358,False,en,5
620,1,5,0,Externals,rtyley,2015-09-08T15:41:15Z,2,1,1,7,"In practice, Git LFS preserves the executable status of files when they are cleaned-to/smudged-from pointer files - in fact the [git attributes clean/smudge filter mechanism](http://git-scm.com/docs/gitattributes#__code_filter_code) doesn't actually provide any support for changing the executable status of a file, they just work on the file's contents with standard input & output.

This is good behaviour, because users don't want their big *.exe files to stop being executable when they start using Git LFS, and the executable status is not preserved anywhere else (eg. rightly, it is not stored within the pointer file).

As an example, here are two *.exe files that have been stored with Git LFS, which has preserved their exec bit in the file tree object. Note that `bar.exe` has it's exec bit _set_ (`100755`), contrary to the spec:

```
$ git cat-file -p HEAD^{tree}
100644 blob ce8828c1134a1f9feb8177e9e2b988d94a94d951    .gitattributes
100644 blob 9242c60b11d49b42e829070feef1c5b7cf7a6159    foo.exe
100755 blob 25637885004ac19bd1e0404e2bb0d2247de37805    bar.exe
$ git cat-file -p 25637885004ac19bd1e0404e2bb0d2247de37805
version https://git-lfs.github.com/spec/v1
oid sha256:364ea686b8d77dbf49d1c1ce28023e818954574310b68c61433fbb02596744e2
size 51200
```

I think the spec just needs correcting here. The wording was introduced with https://github.com/github/git-lfs/pull/246, tweaked with https://github.com/github/git-lfs/commit/4bdecf, but I couldn't find any justification in those for the statement that the executable bit should always be cleared.
",1567,True,en,0
619,5,8,6,Internals,ttaylorr,2015-09-02T20:45:35Z,260,137,5,2,"This commit introduces two new types into the API: Hook, and Filter.

Both `Hook` and `Filter` are abstractions built on Git hooks and filters
respectively. Each type knows how to install and uninstall itself. These
processes are utilized by the setup method in the `lfs` package, and the
appropriate calls have been updated in the init and uninit commands.

These abstractions were introduced to make adding/removing required filters and
hooks easier for future projects, including the migration away from the smudge
filter.

Eventually it seems appropriate to move both new types into the `git` package,
as opposed to the `lfs` package. At the time of writing this commit, there is
some coupling against state defined in the `lfs` package (i.e., whether or not
we're currently in a git repo, the local working directory, etc). At somepoint
it would be nice to remove that coupling and move these new types into the
`git` package.
",932,True,en,1
618,2,2,0,Internals,technoweenie,2015-08-31T23:25:35Z,230,153,6,3,"Builds on #611 with some more tests for git credentials.
",57,True,en,4
615,3,3,2,Internals,ttaylorr,2015-09-02T14:07:07Z,28,22,1,5,"This commit introduces several refactorings to the `run` method (now called
`acceptInput`) on the Batcher type.
- A call to `acceptInput` directly does not spawn a goroutine. The recommended
  way to initialize is to spawn it as a goroutine, which is how the constructor
  method handles initialization of the Batcher type.
- The responsibility of creating new batches is pushed down into the `newBatch`
  func, which allocates a slice of `Transferable`s and sets its capacity at the
  maximum batch size.
",506,False,en,0
613,3,3,5,Internals,ttaylorr,2015-08-27T21:41:34Z,53,15,1,0,"This commit adds the notion of a test case into the `lfs.Batcher` tests. Each
test case has three parameters: a batch size, the number of items to add to that
batcher, and whether or not it should exit the batcher after adding all items.

This commit also adds a helper func called `assertAll` which processes a set of
test cases, throwing assertion errors into the `*testing.T` along the way.

On the other hand, this commit does not contain any utilities to assert that a
deadlock will occur when feeding items into a Batcher, i.e., when the batch size
is set to 0.
",568,False,en,1
611,17,6,10,Internals,technoweenie,2015-09-01T22:03:12Z,572,434,10,5,"This changes Git LFS so it only checks `git-credential` for LFS API requests. The Git LFS API is intended to be mounted next to the Git server. So it makes sense to use git credentials, since it can take advantage of existing credentials for Git users that use HTTPS remotes.

```
https://github.com/foo/bar.git # git remote
https://github.com/foo/bar.git/info/lfs/... # lfs remote
```

However, the client shouldn't have to check git credentials for the ""storage api"" requests. These are the requests to download or upload raw objects from URLs linked from the LFS API response.  The Storage API may not require any authorization for public objects in public repositories. Basically, the Git LFS client should trust the LFS server to return enough meta data to authenticate the requests.
1. `doApiRequestWithRedirects()` is the low level function that handles API communications. It now fetches the credentials [if needed](https://github.com/github/git-lfs/blob/31ccc2293c11ea7e436b336aac0f42125c44feb7/lfs/client.go#L646-L662), and [saves the credentials on success](https://github.com/github/git-lfs/blob/31ccc2293c11ea7e436b336aac0f42125c44feb7/lfs/client.go#L397).
2. With the Batch API, there's now a distinction between public and private repos. Initially a repo is considered public, unless the batch API returns a 401. Then a git config value is set so future requests treat the repo as private. `doApiBatchRequest()` now [tells `doApiRequestWithRedirects()` if credentials are needed](https://github.com/github/git-lfs/blob/31ccc2293c11ea7e436b336aac0f42125c44feb7/lfs/client.go#L466)

/cc @rubyist @sinbad
",1617,True,en,7
610,67,2,5,Externals,sinbad,2015-09-01T14:43:39Z,953,29,19,4,"`git lfs fetch --recent` downloads files for things other than your current checkout, to pre-empt their use and thus avoid making the user wait when they switch a branch, or want to check out recent changes.

It can do 2 things:
- Fetch a snapshot of files at 'recent branches', committed within a configurable number of days of the current date. This means switching to those branches is far quicker than before.
- Fetch previous versions of files that existed before a branch tip, committed within a configurable number of days of the last commit on that branch. This applies to the current HEAD and all 'recent branches', if any. This means looking at recent changes on interesting branches is quick.

You can also make `--recent` the default via lfs.fetchrecentalways. 

The fetch operations are deliberately ordered so the most useful things are done first:
1. Fetch snapshot of the current HEAD
2. Fetch recent branches, most recent to least recent
3. Fetch recent previous versions, starting with HEAD and then recent branches, most recent to least

This means that this command can be left in the background if you want; once the current ref is finished you can carry on working and let the recent fetching happen in the background. Reporting on the command line has been upped a little bit so the user can see which part of the fetch is going on.

This PR also includes:
- A dedicated 'config' man page listing all of the `git config` options that Git LFS adds
- fetch at a ref now _only_ downloads the state at that ref, and not previous versions (without `--recent`). Previously fetch would use the `--do-walk` option to `git rev-list` which means it would include any previous changes to the same files and also files which were deleted. This is more efficient and the `--recent` option gets time-bounded previous versions.
- Utility methods like CurrentRef now return a Ref struct instead of a single value; this saves round-trips when you need the name of the ref as well as the SHA (also categorises into branch/remote branch/tag)
- When files are skipped in fetch because of the include/exclude filter, this is reported if GIT_TRACE=1
- Tests added for CurrentRef and CurrentRemoteRef
",2201,True,en,5
608,2,3,0,Externals,sinbad,2015-08-26T22:21:16Z,47,24,3,0,"Fixes #606 
",12,True,en,1
607,2,2,9,Externals,sinbad,2015-08-26T16:30:17Z,720,0,6,0,"- Use test.Repo and AddCommits to set up complex multi-branch tests
- Can commit in the past for history tests, branch, merge and tag
- Can generate random data for files or use what you give it
- Returns full detail of the commits created including SHAs and OIDs
- Can pipe JSON from a batch file into lfstest-testutils to get the same
  functionality in acceptance tests
- get_date bash util to create commit dates easily on BSD/Mac and GNU
- see test-push.sh for bash example and scanner_git_test.go for go test
",515,False,en,5
605,1,1,0,Externals,nbrew,2015-08-25T15:02:45Z,4,4,1,0,"Added whitespace for markdown formatting of CentOS bullet points.
",66,True,en,0
603,8,1,0,Externals,andyneff,2015-08-26T22:20:39Z,227,204,10,3,"Added Compatibility for Running docker in Windows via boot2docker
- Fixed CentOS createrepo incompatibility on samba shares (not patched until ~Fedora 22)
- Fixed Debian incompatibility with having too many permissions
- In order to get this working, .gitattributes was added so force all newlines to LF only. extentions.md was the only file that need CRLF converted to LF
- Other small fixes for MINGW compatibility

Fixed RPMs to handle #563 
Added DOCKER_OTHER_OPTIONS so that additional arguments can be sent to the containers
",531,False,en,0
600,18,6,2,Internals,rubyist,2015-09-01T17:59:34Z,739,322,21,10,":warning: Experimental :warning:

This PR contains an experiment in refactoring our error wrapping system. I'm pushing it up for discussion, so don't feel like this is something you have to go along with if you don't like it.

In some [older code](https://github.com/github/git-lfs/blob/4457d7c7c5906025f753579f67f975792235b717/lfs/client.go#L751) I tried out some error inspection techniques outlined by Dave Cheney in [this post](http://dave.cheney.net/2014/12/24/inspecting-errors). I found this to be an interesting approach and agree with his points in the article.

In #595 I'm ending up doing a similar thing. Some errors are retriable conditions, and I need to indicate this down in the client code when they happen. I don't want the `TransferQueue` to be inspecting API response codes or errors to know whether it should retry an operation or not. This type of
behavior wrapping fits well here, and in a few other cases.

So I gave myself a little time this morning to see what this would look like if we went all in on this pattern. The `WrappedError` object we use has gotten in the way before and using this pattern should allow us to keep error wrapping internal to the `lfs` package, having only `error`s coming out of it. No error types are exported, only a handful of functions for checking the error
behavior. I feel this method allows for easier extension without breaking calling code.

Goals of this refactoring:
- Move away from a concrete error wrapper (`WrappedError`), use only `error`
- Avoid exporting any error types
- Avoid comparing any concrete error types
- Define behavior checks for things like retriability, fatal-ness, etc
- Allow behaviors to wrap each other
- Keep the current Stack and Context functionality

Once I got the error wrapping and checking functions working, it was very easy to move all of the existing code over. There aren't too many checks we actually do. There's a little more code involved in setting up a new kind of error to check, but I think that's OK because you should really be questioning whether you really need to inspect an error. Once the boilerplate is in, it's very easy and transparent to use. There's a good chuck of documentation in [errors.go](https://github.com/github/git-lfs/blob/554aef8692d3ffac1b244f00150c624671a7b3e3/lfs/errors.go).

There are a couple things that could use some cleaning up, but I don't want to get any more into it until there's consensus. Particularly, the `Errorf()` isn't fully working yet, and I really don't like the way the
`cleanPointerError` stuff works (I don't like the way it works in master, either).

What do other folks think of this pattern? I'm going to proceed with using the pattern specifically in #595, as the `notImplError` is used, but if there's interest in using this for more, this provides a good start. If you hate it, it's fine, it was fun anyway :satisfied:
",2887,True,en,5
599,3,3,6,Internals,technoweenie,2015-09-02T16:36:38Z,130,88,2,11,"Updates the batch API spec to match https://github.com/github/git-lfs/issues/597.
",82,True,en,0
595,18,7,21,Internals,rubyist,2015-09-10T11:02:20Z,124,22,4,23,"We want to retry some calls in the event of an http error. We would typically not retry if the http call was successful and returned a status code, with the exception of upload transfers that can expire and return a 403. There are three calls that can be retried in these cases:
- [x] Retry once when the transfer fails (timeout, http error, 403 with expiry)
- [x] Retry once when a batch api call fails (timeout, http error)
- [x] Retry once when old api call fails (timeout, http error)

And also:
- [ ] Tests!
",513,False,en,0
594,5,4,0,Internals,rubyist,2015-08-24T14:40:43Z,76,2,6,6,"A few problems with the batch code error handling can lead to a hang:
- [x] Actually return an error instead of nil
- [x] Properly manage the waitgroup when a batch call errors
- [x] Make sure we display errors instead of just a 0 count
- [x] Tests for this scenario

/cc #593 
",278,False,en,2
589,1,0,0,Internals,technoweenie,2015-08-17T15:23:52Z,3,1,1,0,"This backports #519.
",21,True,en,0
587,2,2,0,Internals,technoweenie,2015-08-17T15:19:08Z,4251,2676,72,2,"This gets the latest cobra and pflag changes, mostly to clear up the spelling mistakes brought up in https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=793171.

It does add bash completion to cobra though. Might be worth investigating...

https://github.com/spf13/cobra/compare/864687ae689edc28688c67edef47e3d2ad651a1b...c55cdf33856a08e4822738728b41783292812889

https://github.com/spf13/pflag/compare/463bdc838f2b35e9307e91d480878bda5fff7232...4869ec2ae0628354eaac5bf88fccf9a7265ae475
",485,True,en,15
585,5,2,0,Internals,technoweenie,2015-08-14T16:00:34Z,72,19,5,0,"This adds some tests to confirm that `git lfs update` can automatically update the former pre-push hooks. Also taught `git lfs init --force` how to update the pre-push hook too.
",178,True,en,2
583,5,2,0,Externals,sinbad,2015-08-17T19:59:54Z,306,43,11,4,"The first arg to fetch & pull is now a remote. In addition, the default remote if you don't specify is now the tracking remote as in `git pull` if it exists, and origin if that's not set. This makes it more consistent with the underlying git workflow especially in triangular fork setups.

Note: I had to base this on top of https://github.com/github/git-lfs/pull/573 to avoid conflicts.
",388,True,en,3
581,8,9,2,Externals,sinbad,2015-08-14T14:52:42Z,203,22,4,1,"The local client doesn't have all the LFS objects so it's perfectly valid to push commits which reference objects that don't exist, so long as the server already has them. This could occur when deleting files and pushing new branches (https://github.com/github/git-lfs/issues/564) but is increasingly likely as fetch & prune functionality is introduced.

So now we perform a pre-check and any locally missing files are checked on the server. To gain the benefit of the existing parallelism and batching API this required adding a new type of transferable which only checks for download, and doesn't actually do it - instead the fact that the transfer _would_ go ahead is used as an indicator that this oid can be skipped when it comes to push & therefore not cause the process to fail.

After merging this PR it's safe to merge https://github.com/github/git-lfs/pull/573 (which deliberately doesn't download all LFS objects).
",926,True,en,2
579,1,2,0,Internals,technoweenie,2015-08-11T20:30:46Z,10,2,3,0,"gccgo silently ignores them, causing tests to fail.
",52,True,en,3
578,1,6,3,Externals,billygor,2015-08-17T20:01:21Z,30,10,3,6,"this change improves drastically pre-push behaviour, by not sending
lfs objects which are already on a remote. Works perfectly with
pushing new branches and tags.

currently pre-push command analyse ""local sha1"" vs ""remote sha1"" of the
ref being pushed and if ""remote sha1"" is available locally tries to send
only lfs objects introduced with new commits.

why this is broken:
- remote branch might have moved forward (local repo is not up to date).
  In this case you have no chance to isolate new lfs objects (""remote sha1""
  does not exist locally) and git-lfs sends everything from the local
  branch history.
- remote branch does not exist (or new tag is pushed). Same consequences.

But what is important - local repository always have remote references,
from which user created his local branch and started making some local
changes. So, all we have to do is to identify new lfs objects which do
not exist on remote references. And all this can be easily achieved with
the same all mighty git rev-list command.

This change makes git-lfs usable with gerrit, where changes are uploaded
by using magic gerrit branches which does not really exist. i.e.
git push origin master:refs/for/master

in this case ""refs/for/master"" does not exist and git feeds all 0-s as
""remote sha1"".
",1282,False,en,1
577,1,1,0,Externals,sinbad,2015-08-11T16:51:49Z,1,1,1,0,"Previously error went to chan after `q.wait.Done()` so if a caller was blocked on `q.Wait()` it could end up checking `q.Errors()` before the error had been sent to the channel / extracted by errorCollector. Error needs to be sent before `q.wait.Done()`.
",255,True,en,0
573,5,5,2,Externals,sinbad,2015-08-17T19:59:24Z,251,35,11,7,"Note: don't merge until we've resolved https://github.com/github/git-lfs/issues/564.

Added `lfs.fetchinclude` and `lfs.fetchexclude` config options and `--include` and `--exclude` command line args to fetch. These cause certain paths to either be included or excluded when fetching binaries so that people who work in specific subfolders and don't want to waste time or disk space fetching irrelevant things can do so. This is most common in teams using a single shared repo for all assets but where not everyone needs all of them, e.g. only texture artists might need the original .psd files vs exported runtime equivalents, only modellers/animators might need the original .max files etc. Some teams have a more complex pipeline which avoids this but for those that don't wanting to download by subfolder is quite common. I expect the config option variants to be most used, `--include`/`--exclude` args to fetch are there for special occasions.

This affects the behaviour of `fetch`, `pull` and `smudge` since in all cases the `download` argument to PointerSmudge is set based on whether it matches include/exclude filters.

There is a later knock-on effect on `push` though because it means a user won't have all oids for a given commit. Right now that will cause `push` to fail later if the commits in question get included in the scan for pushing a new branch. This is another case of https://github.com/github/git-lfs/issues/564, which needs to be addressed before this can be merged.
",1494,True,en,3
572,1,1,0,Externals,billygor,2015-08-10T21:54:19Z,3,0,1,0,"non-batch transfer was stuck when objects already exist on lfs-server
",70,True,en,0
570,2,4,0,Internals,rubyist,2015-08-14T13:25:51Z,26,14,1,6,"This PR will avoid any use of `Panic()` while the `git update-index` loop is running. If the process exits while `update-index` is in the middle of processing a file, the index can be left in an inconsistent, locked state.

/cc #558 
",234,True,en,0
569,1,1,0,Externals,sinbad,2015-08-07T15:29:12Z,6,0,1,0,,0,False,en,0
566,1,5,0,Externals,sinbad,2015-08-07T14:56:01Z,45,11,5,0,"This was always the intention but the PointerSmudge functions would automatically do it if the local files were missing. Now they take a boolean argument to say whether to download or not, and the case of skipped smudge is dealt with by writing out the original pointer data and returning a known non-fatal error.
",314,True,en,1
565,1,1,0,Externals,sinbad,2015-08-06T14:40:08Z,32,6,2,0,"Spotted while working on other things that assert_pointer wasn't a good test for fetch, since it only validates that the git commit objects have the right pointer data, not that the content exists locally. 

Added assert_local_object and refute_local_object instead & used in fetch tests.
",289,True,en,2
563,2,3,0,Internals,hoolio,2015-08-05T13:18:02Z,2,0,1,0,"Adding language at the top of the file that makes clear that the project is licensed under the MIT license, with a link to the Wikipedia article explaining what that license is. 

Users should have an easy way to determine what standard OSS license applies to a project, if any, by quickly looking at it.
",305,True,en,0
562,7,0,0,Internals,technoweenie,2015-08-04T19:19:47Z,131,12,4,0,"Some additions to the credential tests in #561, written specifically for #554.
",79,True,en,2
561,12,0,0,Internals,technoweenie,2015-08-04T19:20:39Z,272,16,7,0,"Trying to spike out some tests for the git credential behavior. This is so we can find out if we break the credential flow, and test changes to it like #554.
",158,True,en,5
560,1,1,0,Internals,technoweenie,2015-08-04T21:24:01Z,4,7,1,0,"This was pointed out by @WillHipschman in https://github.com/github/git-lfs/pull/486#discussion_r36108775.
- fewer slice iterations
- slices are initialized with the correct capacity

/cc @ryansimmen since this came from your pr.
",230,False,en,0
559,5,19,5,Externals,sinbad,2015-08-07T14:53:54Z,389,0,2,3,"This is part of my preparatory work to support the `prune` command; I thought I would submit this part early both to establish its use while I continue working on the specific features, and in case it is useful elsewhere. 

The focus of this PR is the `parseLogOutputToPointers` function which can scan a properly formatted `git log` output & extract relevant changes to LFS references. I've included an example of its use, ScanUnpushed() which shows what oids haven't been pushed anywhere & therefore only exist locally. However it will also be useful for other tasks (e.g. `fetch --recent`). The reason for it being able to scan for additions or removals is that depending on which direction in history you're scanning you might want either one (e.g. scanning backwards from a snapshot date between commits you want the '-' diffs to know what was being used beforehand).

The main feature of this method compared to alternatives is that it can extract WrappedPointers from arbitrary history with just a single `git log` command (and can be run in parallel with other tasks if needed)
",1086,True,en,1
555,21,2,8,Externals,andyneff,2015-08-06T14:41:03Z,703,420,36,5,"Vastly cleaned up docker directory and files

Removed need to rebuild entire environment just to get dependencies
Normalized all rpm names so they follow the same pattern between OSes
Added 32 bit cross compile support
Move GPG agent from host to docker, to support any boot2docker host now. 
Fixed file ownership issue
Enabled integration test on rpm build
Cleaned up README
",376,True,en,5
554,3,6,0,Externals,clareliguori,2015-08-04T19:20:40Z,25,2,2,3,"Support credentials from multiple accounts when useHttpPath=true is set in the git config

Provide the URL path to 'git credential fill' for credential helpers that need the path to return the right credentials
Use the objects API URL for credentials so there is a stable path passed to the credential helper for caching
",321,True,en,0
553,5,3,0,Internals,rubyist,2015-08-07T16:00:07Z,52,27,5,6,"This adds support for the batch api outlined in #437
- [x] `_links` => `actions`
- [x] Handle the new `error` property
",119,False,en,3
552,1,1,0,Internals,technoweenie,2015-08-03T15:26:28Z,33,7,2,2,"I didn't notice until too late that the skip message from #546 never showed up. The problem is that `comparison_to_operator()` causes the script to halt if it returns something other than `$VERSION_EQUAL` (0) because of `set -e`.

/cc @sinbad 
",244,True,en,2
551,2,4,2,Externals,sinbad,2015-08-04T20:09:14Z,19,2,1,4,"Only displayed when running a separate checkout command, not on pull (lets the download queue do the progress to avoid mixing the 2)
",133,True,en,0
550,1,0,0,Internals,technoweenie,2015-07-31T15:17:36Z,1,4,1,0,"This backports #549.
",21,True,en,0
549,2,1,0,Internals,rubyist,2015-07-31T15:02:09Z,1,4,1,0,"When building from a non git checkout the build script would panic when it can't find the commit hash. Instead, just ignore it.

Fixes #548
",140,True,en,0
547,1,1,0,Internals,rubyist,2015-07-31T15:12:44Z,12,4,2,0,"If progress is not delayed it can interfere with credential helpers asking for credentials to make the API calls.
",114,True,en,0
546,7,1,5,Externals,sinbad,2015-07-31T15:58:26Z,199,41,7,0,"When using `git worktree`, store lfs objects in the same shared location as the git commit objects, rather than duplicating them. Temp files are still kept per worktree.

This requires resolving an extra level of indirection on the git dir; with worktree, the first level, identified by GIT_DIR when setting up and by a git-dir: redirect in the `.git` file afterwards, points at a git dir which just has an index and other worktree-specific data. A `commondir` file in that git dir points to where the git objects are stored, which is common with the original repo the worktree was created from. We store lfs files alongside the commit objects in this case, sharing with all worktrees.
",686,True,en,4
544,4,1,0,Internals,rubyist,2015-07-30T14:54:09Z,16,29,7,0,"There should be a `SuppressProgress()` call on the upload queue when it's doing a dry run. I added it to the `pre-push` stuff but overlooked it for `push`. It only fails intermittently because the progress meter output is written in a goroutine, so during a dry run it's possible that the `push` command exits before the goroutine ever runs. On slower or more utilized machines, like this CI, it gets a chance to run and shows progress output.
",444,True,en,0
543,3,0,6,Externals,sinbad,2015-07-30T15:08:28Z,29,0,2,0,"Previously using `.` `./` and `.\` would only behave as expected in subdirs
(because calculating the relative dir would resolve it), using them in the
root would match nothing. Behave as expected instead.
",205,False,en,1
542,1,1,0,Externals,sinbad,2015-07-30T12:46:42Z,18,11,3,0,,0,False,en,1
541,1,1,0,Externals,sinbad,2015-07-30T12:30:30Z,50,67,1,0,,0,False,en,1
540,7,4,0,Internals,technoweenie,2015-07-30T14:43:56Z,81,97,42,0,"This attempts to fix the race condition regarding `$HOME` in the integration tests.

Now, an initial `$TESTHOME` is setup at `$REMOTEDIR/home`. It has the starting git config and OSX keychain (if needed). `begin_test()` resets `$HOME` to `$TRASHDIR/home`, which is unique per test script. Tests run sequentially in a single script.

I also ran into an issue where `begin_test()` was silently failing, causing the scripts to bail after the first test. So, I added something in `shutdown()` that ensures every test runs by grepping the file for all `begin_test()` calls.
",569,True,en,28
539,7,1,2,Internals,technoweenie,2015-07-29T21:11:27Z,84,46,12,0,"Fixes:
- teach 'uninit' how to remove git config sections #530
- Client prompts for username/password auth after obtaining a token via SSH #534 

Patches:
- Commit SHA is retained in the client version and user agent #536 
- Reorganize Git LFS error logs #537
",260,False,en,2
538,1,1,0,Externals,sinbad,2015-07-29T16:32:09Z,1,1,1,0,"Just a little fix: without the quotes the -x test passes and you get a weird error along the lines of:
`script/man: line 10: man/git-lfs-checkout.1.ronn: Permission denied`
..if ronn isn't installed, instead of the correct error message: 
`Install the 'ronn' ruby gem to build the man pages.`
",293,False,en,0
537,2,1,0,Internals,technoweenie,2015-07-29T16:41:36Z,17,7,2,0,"I'm tired of asking people for their version info.  This update adds the Git LFS and Git versions to the top. It also throws the git lfs environment at the bottom, so we can see things like their git lfs concurrency setting.

OLD:

```
> git-lfs logs boomtown
LocalWorkingDir=/Users/rick/go/src/github.com/github/git-lfs
LocalGitDir=/Users/rick/go/src/github.com/github/git-lfs/.git
LocalMediaDir=/Users/rick/go/src/github.com/github/git-lfs/.git/lfs/objects
TempDir=/Users/rick/go/src/github.com/github/git-lfs/.git/lfs/tmp
ConcurrentTransfers=3
BatchTransfer=false
GIT_LFS_TEST_DIR=/Users/rick/p/git-lfs-temp
GIT_LFS_TEST_MAXPROCS=4

Welcome to Boomtown

Error!
Inner error message!
goroutine 16 [running]:
github.com/github/git-lfs/lfs.Stack(0x0, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/lfs/errors.go:85 +0x89
github.com/github/git-lfs/lfs.Errorf(0x6831b0, 0xc208034d00, 0x3b9e00, 0x6, 0x0, 0x0, 0x0, 0x5b8f20)
    /Users/rick/go/src/github.com/github/git-lfs/lfs/errors.go:29 +0x62
github.com/github/git-lfs/commands.logsBoomtownCommand(0x5b8f20, 0x5bfc78, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/commands/command_logs.go:88 +0xf6
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).execute(0x5b8f20, 0x5bfc78, 0x0, 0x0, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:355 +0x17c
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).findAndExecute(0x5b9c20, 0xc20800e010, 0x2, 0x2, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:334 +0xd3
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).Execute(0x5b9c20, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:408 +0x7b0
github.com/github/git-lfs/commands.Run()
    /Users/rick/go/src/github.com/github/git-lfs/commands/commands.go:84 +0x2a
main.main()
    /Users/rick/go/src/github.com/github/git-lfs/git-lfs.go:9 +0x1a
```

NEW:

```
git-lfs/0.5.3 (GitHub; darwin amd64; go 1.3)
git version 2.3.0

$ git-lfs logs boomtown
Welcome to Boomtown

Error!
Inner error message!
goroutine 16 [running]:
github.com/github/git-lfs/lfs.Stack(0x0, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/lfs/errors.go:85 +0x89
github.com/github/git-lfs/lfs.Errorf(0x6831b0, 0xc208034d00, 0x3ba0e0, 0x6, 0x0, 0x0, 0x0, 0x5b8f20)
    /Users/rick/go/src/github.com/github/git-lfs/lfs/errors.go:29 +0x62
github.com/github/git-lfs/commands.logsBoomtownCommand(0x5b8f20, 0x5bfc78, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/commands/command_logs.go:88 +0xf6
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).execute(0x5b8f20, 0x5bfc78, 0x0, 0x0, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:355 +0x17c
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).findAndExecute(0x5b9c20, 0xc20800e010, 0x2, 0x2, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:334 +0xd3
github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra.(*Command).Execute(0x5b9c20, 0x0, 0x0)
    /Users/rick/go/src/github.com/github/git-lfs/vendor/_nuts/github.com/spf13/cobra/command.go:408 +0x7b0
github.com/github/git-lfs/commands.Run()
    /Users/rick/go/src/github.com/github/git-lfs/commands/commands.go:85 +0x2a
main.main()
    /Users/rick/go/src/github.com/github/git-lfs/git-lfs.go:9 +0x1a

ENV:
LocalWorkingDir=/Users/rick/go/src/github.com/github/git-lfs
LocalGitDir=/Users/rick/go/src/github.com/github/git-lfs/.git
LocalMediaDir=/Users/rick/go/src/github.com/github/git-lfs/.git/lfs/objects
TempDir=/Users/rick/go/src/github.com/github/git-lfs/.git/lfs/tmp
ConcurrentTransfers=3
BatchTransfer=false
GIT_LFS_TEST_DIR=/Users/rick/p/git-lfs-temp
GIT_LFS_TEST_MAXPROCS=4
```
",3946,True,en,1
536,4,1,0,Internals,technoweenie,2015-07-29T16:40:16Z,30,19,4,0,"I want the version string to include the git commit that built it:

```
$ git lfs version
git-lfs/0.5.3 (GitHub; darwin amd64; go 1.3; git 0cf7c47)
```

This PR gets it working with `script/run version`, but not `script/bootstrap`.

```
$ script/bootstrap
# github.com/github/git-lfs
/opt/boxen/chgo/versions/1.3/pkg/tool/darwin_amd64/6l: unknown flag -X github.com/github/git-lfs/lfs.GitCommit 22bb4ab

2015/07/28 16:04:56 exit status 2
exit status 1
```

I'm really not sure why it [fails here](https://github.com/github/git-lfs/blob/0cf7c479e403deee9f8e0cdafa9b6597d22fab71/script/build.go#L132-L139) when it works in `script/run` or running `go build` manually.

A workaround is to create a file like `lfs/aaaaa_version.go`:

``` go
package lfs

func init() {
  GitCommit = ""22bb4ab""
}
```

Such a file could be created and then trashed during every `script/bootstrap` run.
",878,True,en,0
534,2,4,1,Internals,technoweenie,2015-07-29T14:02:00Z,8,14,1,0,"This allows newClientRequest() to set an Authorization header from either an SSH response or link relation without calling git credentials. Fixes #533 

/cc @jatoben 
",167,True,en,0
532,2,0,0,Internals,technoweenie,2015-07-29T16:42:06Z,16,3,2,0,"As we march towards Git LFS v1.0, I want to make sure the installation and upgrade experience is great. @andyneff and @ssgelm have been extremely helpful with getting official RPM and Apt packages built. The homebrew community has been [keeping the recipe up to date](https://github.com/Homebrew/homebrew/search?q=lfs&type=Issues&utf8=%E2%9C%93) too. 

I think our biggest gap right now is Windows (which is also where most of our help requests come from).

The tasks are listed in more detail at #531
",502,True,en,0
530,1,1,0,Internals,technoweenie,2015-07-29T16:39:34Z,11,6,3,1,"We need to run `git config` with the `--remove-section` arg. Fixes #529
",72,True,en,1
527,31,14,24,Externals,sinbad,2015-07-30T01:19:49Z,916,74,17,2,"1. `fetch` no longer updates the working copy, it only downloads files
2. Added `checkout` command which updates the working copy with content if files are missing or are matching pointers. Modified files are left alone (user should reset if they want)
3. Added `pull` command which performs `fetch` and `checkout` for the current ref
4. ~~`fetch` now supports multiple refs as arguments~~
5. `checkout` will correctly populate multiple local files with the same content (old `fetch` would only populate the first one returned from `git rev-list`)
6. `fetch` only adds missing or incorrect objects to the download queue, not all of them. This improves the progress reporting; previously fetch would appear to be trying to download all objects referenced at a ref then only have to download the missing ones as the download queue figured out they were already local. Also means fetch reports nothing at all if you're completely up to date already, instead of reporting ""(0 of 1000 files)"".
7. A side effect is that 'pull' does all fetching first, then all checkout (not interleaved as before). This is because there may be more objects to checkout than to fetch (missing in working copy but already in store). Coupling these has unwanted edge cases & it's better to simplify & do what it says on the tin i.e. the same as running fetch then checkout.

Note that the ScanTree does something similar to ScanRefs but reports pointers for every file that uses the content and not just one where multiple files share the same content. I'm not sure if this is the intended behaviour elsewhere but for now I've left it as a separate method. It also doesn't have the race conditions on nameMap that I believe ScanRefs has (commented elsewhere).
",1735,False,en,5
526,2,1,0,Externals,andyneff,2015-07-27T16:07:38Z,16,3,2,0,"Workarounds and patches to get Debian to cross compile 32-bit on a 64-bit Debian (using the -ai386 flag)

@ssgelm Does this look okay?
",135,True,en,0
522,1,1,0,Externals,ssgelm,2015-07-24T21:37:19Z,2,2,1,0,"When submitting to debian they found these pedantic typos on codespell.  Sorry for the extra PR noise. :smile: 
",112,True,en,0
521,1,2,0,Externals,ssgelm,2015-07-24T21:34:37Z,6,0,1,0,,0,False,en,0
520,3,3,3,Externals,sinbad,2015-07-24T16:28:35Z,25,0,1,0,"This was caused by the fact that you can't disable the osxkeychain helper
if it's set at the system gitconfig (which is the default in recent git),
and the git credential 'store' operation will call ALL helpers, not just
the special one created for the integration tests. Because the test user
environment doesn't have a keychain this caused lots of annoying popup
error messages saying ""A keychain could not be found to store X"".
",431,False,en,1
519,1,4,0,Externals,seiyanuta,2015-07-24T15:59:44Z,3,1,1,0,"`install(1)`'s `-D` option used in install.sh is a coreutils specific feature. OS X's
implementation does not support it and some other implementation such
as FreeBSD behaves differently.

This PR fixes this problem so that we can use this install script in those OSes.
",270,False,en,0
518,2,7,0,Externals,sinbad,2015-07-27T20:31:59Z,12,2,1,3,"e.g. `script/integration fetch status` will run only status & fetch tests
",74,True,en,0
511,27,2,2,Externals,andyneff,2015-07-28T19:59:44Z,1015,55,32,5,"A set up docker scripts useful for building, packaging, signing, and testing on multiple Linuxes from a single Linux

@ssgelm I could use your help on adding some Debian repos deb. That's the only part missing here. 
",217,True,en,2
510,1,1,0,Externals,andyneff,2015-07-23T16:43:28Z,2,2,1,0,"Handle special characters (\n) in sh script no matter what distro

(Unfortunately...) Fedora/RHEL/CentOS/etc... use the same executable for sh and bash. echo ""\n"" just happens to be one of the few cases when it will produces different (wrong?) results. In order to make this always work for everyone, when trying to print escape characters, using printf works

With this patch, ALL tests pass in Debian and CentOS!
",415,True,en,1
509,1,1,0,Internals,technoweenie,2015-07-23T16:42:42Z,6,1,1,0,"Document `--object-id`.
",24,True,en,0
508,1,0,0,Internals,technoweenie,2015-07-23T20:37:57Z,16,2,3,0,"Ships v0.5.3 from master. For a fun time, check out [this release thread](https://github.com/github/git-lfs/issues/425#issuecomment-123492545) where I find what looks like a regression, spend a few hours backporting a bunch of commits, and realizing it's not a regression.
",273,True,en,0
507,2,0,0,Internals,technoweenie,2015-07-22T21:03:23Z,967,48,7,0,"This backports #480.

Conflicting files:
- .gitignore
",54,True,en,0
506,1,0,0,Internals,technoweenie,2015-07-22T20:51:45Z,11,11,4,0,"This backports #475.
",21,True,en,1
505,2,0,0,Internals,technoweenie,2015-07-22T20:49:11Z,13,10,2,0,"This backports #472 and #488.
",30,True,en,0
504,1,0,0,Internals,technoweenie,2015-07-22T20:45:39Z,33,2,3,0,"This backports #469.
",21,True,en,0
503,1,0,0,Internals,technoweenie,2015-07-22T20:44:08Z,128,87,9,0,"This backports #463.
",21,True,en,9
502,1,0,0,Internals,technoweenie,2015-07-22T20:42:05Z,92,19,10,0,"This backports #461.
",21,True,en,2
501,1,0,0,Internals,technoweenie,2015-07-22T20:39:21Z,115,33,4,0,"This backports #449.
",21,True,en,1
499,1,0,0,Internals,technoweenie,2015-07-22T20:25:41Z,167,3,4,0,"This backports #386.
",21,True,en,3
498,1,0,0,Internals,technoweenie,2015-07-22T20:23:54Z,130,30,6,0,"This backports #447.
",21,True,en,2
497,1,0,0,Internals,technoweenie,2015-07-22T20:20:42Z,18,2,2,0,"This backports #452.
",21,True,en,2
496,3,0,0,Internals,technoweenie,2015-07-22T20:15:23Z,313,20,10,0,"This backports #446, #451, and #465.
",37,True,en,4
495,1,0,0,Internals,technoweenie,2015-07-22T19:34:51Z,89,1,3,0,"This backports #442.
",21,True,en,2
494,2,0,0,Internals,technoweenie,2015-07-22T19:31:46Z,272,17,5,0,"This backports #404 and #464.
",30,True,en,2
493,1,0,0,Internals,technoweenie,2015-07-22T19:26:54Z,9,5,2,0,"This backports #421.
",21,True,en,2
492,2,0,0,Internals,technoweenie,2015-07-22T19:24:11Z,128,78,4,0,"This backports #428.
",21,True,en,0
491,3,1,0,Internals,technoweenie,2015-07-23T17:50:28Z,13,6,1,0,"1. @sinbad is anxious to tackle local storage management: #490. I combined items since they're all covered by his task list.
2. This [Extensions proposal](https://github.com/github/git-lfs/blob/master/docs/proposals/extensions.md) is very important to @ryansimmen (#460). Hooks on hooks on hooks.
3. I demoted client side metrics reporting. While @rubyist added better HTTP stats to the client (#366), I don't know if we need clients reporting this data to servers.
",466,False,en,0
489,3,2,0,Internals,technoweenie,2015-07-22T19:19:50Z,60,0,1,0,"Porting over a backport script from ruby to sh that we use internally at GitHub.

![backport__475_for_v0_5_x__use_-text_instead_of_-crlf_by_technoweenie_ _pull_request__13_ _github_git-lfs-internal](https://cloud.githubusercontent.com/assets/21/8815133/42ade492-2fd2-11e5-800c-e5c2293da98c.jpg)

While experimenting with this, I'm pushing to an internal repo that we use for testing.
",384,True,en,0
488,1,0,0,Internals,technoweenie,2015-07-22T19:18:01Z,9,9,2,0,"The `doHttpRequest()` function sometimes returns an HTTP response with no body. This is so we don't need `res` nil checks in places [like this](https://github.com/github/git-lfs/blob/bbf2d1654f924cfaca9aa7dbfa124c36471cfc9e/lfs/client.go#L374).

Should fix #317 and #487
",271,True,en,0
486,5,4,21,Externals,ryansimmen,2015-08-04T14:45:39Z,873,87,16,13,"Code for proposal https://github.com/github/git-lfs/blob/master/docs/proposals/extensions.md
",93,True,en,4
485,4,5,0,Internals,rubyist,2015-07-21T19:45:26Z,23,0,2,0,"A quick script to warn about importing third party packages directly instead of via nut (i.e. vendored).

Example output if you mistakenly import directly (with an exit code of 1):

```
$ ./script/lint
Non vendored dependencies found:
    github.com/cheggaaa/pb
    github.com/rubyist/tracerx
```

Normal output (with an exit code of 0):

```
$  ./script/lint
Looks good!
```
",376,True,en,0
484,1,1,0,Externals,michael-k,2015-07-21T15:33:41Z,0,0,1,0,,0,False,en,0
483,3,1,0,Internals,technoweenie,2015-07-21T19:43:31Z,63,55,2,1,"Documents the new proposals directory. It's basically a spot to talk about potential features at a high level.

Also fixes some really minor stuff in the extensions proposal.
",175,True,en,0
480,8,1,0,Externals,andyneff,2015-07-16T15:50:19Z,965,48,7,3,"-CentOS 6 only has git 1.7 available. So I had to take the existing git rpm, and update it to 2.4.5. Ever feature and capability should have been ported (Emacs, perl, etc...) So that it could probably replace the existing git with no ill effect...
-CentOS 5 was pulling an 1.7 version instead of an available 1.8.2 version. The scripts has been updated to pull the compatible version
-Building no longer fails when sudo in not installed requiring the developer to set the SUDO environment variable
-Building the SRPM no longer fails due to bad permissions
Docs updated
-Many (but far less now) integration tests still fail. I'm using this for active software development in CentOS 6.6, and it does work. 
",705,False,en,0
476,25,5,1,Internals,rubyist,2015-07-29T15:08:27Z,538,291,13,19,"This PR splits up batch requests into several batches of `n` (currently hardcoded to 100).
- [x] Progress counters are a little off
- [x] Handle errors to the batch call, resubmit batch or track failures
- [x] Test with many thousands of files
",244,False,en,3
475,1,4,0,Internals,technoweenie,2015-07-10T14:09:03Z,11,11,4,0,"Fixing https://github.com/github/git-lfs/issues/473
",52,True,en,1
472,1,1,0,Internals,rubyist,2015-07-09T13:50:21Z,4,1,1,0,"This method was not checking the error from doHttpRequest() yet still manipulating the reponse object and body. In some scenarios this can cause a panic when trying to read from the nil reponse body.

Fixes #462
",212,True,en,0
471,2,7,0,Internals,bkeepers,2015-07-09T16:41:04Z,3,0,1,0,"We are intending to adopt the soon-to-be-announced [Open Code of Conduct](http://todogroup.org/opencodeofconduct) for all @github projects. This adds it to the contributing guidelines. Let me know if you have any questions or concerns.
",236,True,en,0
469,1,1,0,Externals,ssgelm,2015-07-09T16:56:16Z,33,2,3,1,"There were a few issues when running lintian (the debian deb linter) on the package.  This fixes them.
- Add the machine-readable license header that debian requires
- Update to the current standards version (this does not break compiling on older debian releases from what I can tell)
- Add a lintian-overrides file for a few exceptions because golfing doesn't support a few things debian likes.
",397,False,en,0
468,3,0,3,Internals,rubyist,2015-07-09T13:48:02Z,16,14,2,1,"When a batch request received a 401, the request was re-run without resetting the Body, causing the request to error and fall back to individual processing. This just reruns the `Batch()` function.
",198,True,en,0
467,1,1,0,Internals,MikeMcQuaid,2015-07-07T14:53:03Z,1,1,1,0,"@technoweenie Sorry, pushed an old version in #458 with a syntax error. Works now.
",83,True,en,0
465,13,2,3,Internals,technoweenie,2015-07-20T17:06:05Z,263,13,7,13,"- [x] Basic `git lfs init` tests in #446
- [x] confirm `(MISSING)` is not in the `git lfs init` output.
- [x] Add `git lfs init --force` to force writing the git lfs config.
- [x] Document `git lfs init --force`
- [x] Add `git lfs uninit`
- [x] Document `git lfs uninit`
",271,False,en,2
464,1,1,0,Internals,technoweenie,2015-07-07T14:29:48Z,62,61,2,0,"Some small changes to #404:
1. Implemented @michael-k's suggestion in https://github.com/github/git-lfs/pull/404#discussion-diff-32717780. It's more clear where and how both `isPlink` and `isTortoise` are set.
2. Removed any ssh stuff from `NewEndpoint()`. It now returns the correct `Endpoint` based on the url scheme. I really hope we don't try to support any other strings without a uri scheme ;)

/cc @sinbad
",413,False,en,0
463,4,0,0,Internals,technoweenie,2015-07-06T21:06:37Z,128,87,9,0,"This replaces the `assert_server_object` and `refute_server_object` helper no-ops with real functions.

This triggered some test failures because the server was tracking just a single set of objects by OID. So `refute_server_object` in one test would fail if another test already pushed it. 

I updated the test server to track unique objects per repo. The mock Git LFS API parses the repo name from a URL like `/{repo}.git/info/lfs/....` and passes it to the mock storage API as a `?r` query param.
",500,True,en,9
461,10,3,0,Internals,technoweenie,2015-07-06T21:10:28Z,92,19,10,1,"This fixes the scanner to find all objects in a commit range, even if an object was added and deleted in that same range. We want all `git lfs push` commands to push every object so that every individual commit is has all the objects it needs.
",244,True,en,2
458,4,8,0,Internals,MikeMcQuaid,2015-07-07T14:30:10Z,13,1,2,4,"This variable is a bit of a mystery to non-Go developers and it's unclear how you set it up properly. As a result, if it's not set let's set everything up how Go likes it.

Also:
- This will also help keep the Homebrew formula simpler.
- Ignore the `src` directory that we're creating now.
- script/bootstrap: exit on any errors (to be more consistent with other scripts and safer).
- script/bootstrap: remove unneeded `pwd` (the rest of this script assumes it's already in the root of the repository anyway)

Closes #388.
",523,True,en,0
452,2,0,0,Internals,rubyist,2015-06-29T19:37:09Z,18,2,2,0,,0,False,en,2
451,2,0,0,Internals,rubyist,2015-06-29T19:39:52Z,4,1,1,0,"Avoids display bugs if '%' are used when formatting isn't intended. e.g.

```
$ git lfs init
The clean filter should be ""git-lfs clean %!f(MISSING)"" but is ""git lfs clean %!f(MISSING)""
```
",189,True,en,0
450,1,0,0,Internals,rubyist,2015-06-29T15:54:18Z,4,4,1,0,"The progress tracking code in the transfer queue currently uses 64 bit integers for tracking the number of finished transfers. It sets the values using the `sync/atomic` package. There is an [alignment bug](http://golang.org/pkg/sync/atomic/#pkg-note-BUG) in the package when using int64 on 32 bit architectures.

These don't really need to be 64 bit counters, so to avoid just moving them to the top of the struct and risking them being misplaced later we'll just use 32 bit ints.
",482,True,en,0
449,13,6,18,Externals,larsxschneider,2015-07-06T16:54:23Z,115,33,4,7,"Adds a new option ""--objectid"" to the push command to upload objects generated by [BFG](https://github.com/rtyley/bfg-repo-cleaner/pull/87). Click [here](https://gist.github.com/larsxschneider/a31fb77c7e9a9c9b81da) for an example how to use it with BFG.

_Note:_
I am learning golang. Please point out to me anything that could be improved. Even if pedantic :smile: 
",367,True,en,1
447,8,1,1,Internals,technoweenie,2015-07-06T17:00:01Z,130,30,6,8,"`git push` errors if you have Git LFS pointers without an object in `.git/lfs/objects`. This prevents the client from making a successful Git push without a successful Git LFS push. But, the error message is very confusing.

> Cannot clean a Git LFS pointer.  Skipping.

The confusing error message was written to prevent `git add` from turning a Git LFS pointer to _another_ pointer in the clean filter. So here's an attempt at a better error:

> new.dat is an LFS pointer to 7aa7a5359173d05b63cfd682e3c38487f3cb4f7f1d60659fe59fab1505977d4c, which does not exist in .git/lfs/objects.
> 
> Run 'git lfs fsck' to verify Git LFS objects.

This hopefully makes a little more sense. It also points the user to the fsck command, which will show the user all of their missing objects. Thoughts?

The first commits are some light refactoring as I was going over some code. Some properties were no longer used, or could be simplified. For instance, no need to send an `*os.File` in the `*cleanedAsset` object if every caller is going to immediately close it. Just close it and send the filename instead.

Also, the error message change in `commands/command_pre_push.go` is a hack. `lfs.NewUploadable` should return a `*WrappedError` with the `Panic` bool set to false. This way both `push` and `pre-push` get the correct error message for free.
",1337,True,en,2
446,1,1,0,Internals,technoweenie,2015-06-29T16:03:32Z,46,6,3,1,"This simply tests the current behavior in preparation for future `git lfs init/uninit` work.
",93,True,en,3
444,3,3,5,Externals,sanoursa,2015-07-20T16:40:44Z,185,4,2,23,"This is a design proposal for making Git LFS extensible.  The idea is that you can register an LFS extension, and the extension gets inserted into the LFS clean and smudge calls, and is also tracked in the pointer file to ensure that anything that is cleaned can be correctly smudged.

Our biggest use case is that we have many files that are both very large and very compressible, and we want to be able to compress those files before they are written into the LFS cache (and then pushed to the LFS server), and uncompress them when writing to the working directory.  Our proposal is to add extensibility to the core behavior of LFS, and then we will build our own compression extension for the teams that need it. 

We are also considering releasing our compression extension so that others can use it if they want to.  Ideally, this could even lead to a library of LFS extensions, contributed by various authors, so that users of LFS can mix and match the behaviors they want when using LFS.
",995,True,en,0
442,2,3,1,Externals,sinbad,2015-06-29T16:07:04Z,89,1,3,2,"Currently if a server responds with a 307 on POST and the Location header is relative, the re-post fails. 

Relative Location headers are valid and are more convenient for some servers which aren't aware of the original request (e.g. load balancers) without checking for other headers which can vary per routing system. git-lfs should just support relative Location responses.
",377,True,en,2
441,1,1,0,Externals,devcurmudgeon,2015-06-27T23:30:50Z,1,1,1,1,,0,False,en,0
437,7,22,0,Internals,technoweenie,2015-07-28T15:38:44Z,191,4,3,33,"[JSON Schema](http://json-schema.org) is a pretty good format for defining the schema of a data structure. This is the exact schema that we'll be using to validating requests and responses through GitHub's implementation of the server.
- [x] Change `_links` to `actions`. It accurately describes what they're for. Also, `_links` was only ever used for [HAL](http://stateless.co/hal_specification.html) compatibility. Git LFS has diverged enough that there's no point to maintaining that illusion.
- [x] Specify required attributes
- [x] Validate `href` and optional `header` objects under each action.
- [x] Validate action types? (`download`, `upload,`verify`).
- [x] Define `error` object.
- [x] Add simple json parsing test for the schema files #528

Current example request and response:

``` js
// REQUEST
{
  ""operation"": ""upload or download"",
  ""objects"": [
    {
      ""oid"": ""abc123"",
      ""size"": 123
    }
  ]
}

// RESPONSE
{
  ""objects"": [
    {
      ""oid"": ""abc123"",
      ""size"": 123,

      ""actions"": {
        // objects will have either a download action,
        // or an upload + verify
        ""download"": {
          ""href"": ""url"",

          // optional
          ""header"": {
            ""Some-Header"": ""some value""
          },

          // optional UTC timestamp in iso 8601
          ""expires_at"": ""2015-07-20T21:10:55Z""
        }
      },

      // error property is optional
      ""error"": {
        ""code"": ""fatal"",
        ""message"": ""some fatal error occurred""
      }
    }
  ]
}
```

/cc @sinbad: Curious on your thoughts. Ideally the SSH implementation shares the same JSON schema as much as possible.

EDIT: I don't intend to use the json schema files directly in the Git LFS client right now. It's just for API documentation.
",1766,False,en,0
429,2,1,0,Internals,rubyist,2015-06-23T20:42:55Z,91,4,2,3,"This PR fixes two :bug: :beetle: in the `fetch` command.
1. When fetching the not current branch, the queue would not process, nothing would download.
2. When fetching the current branch, the main routine would not wait for the goroutine that copies files into the wd and updates the git index, possibly leaving the wd in an inconsistent state.

Integration tests for fetch are included.
",388,False,en,1
428,4,2,8,Externals,andyneff,2015-06-24T18:53:09Z,127,77,4,4,"Added a bunch of minor fixes for building in CentOS
",52,True,en,0
424,2,2,0,Internals,technoweenie,2015-06-19T20:49:18Z,31,2,2,0,"You can't modify a 0 len array. I didn't want to append on each iteration, so I went with a slice instead.
",107,True,en,1
423,6,0,2,Internals,rubyist,2015-06-19T19:40:18Z,97,14,3,0,"This is a fix for a bug in the handling of the `GIT_LFS_PROGRESS` file which is used by desktop apps, or other things integrating with the git-lfs binary.

At a later point, we should move toward a more unified progress tracking which supports this file as well as the pb progress bars via a single API. This file, the pb output, and possibly the `watchers` channel could be unified into a single event stream, cleaning up some of this code.
",442,True,en,0
422,1,1,0,Internals,rubyist,2015-06-19T18:47:19Z,7,0,1,0,"Older versions of the API may not include the oid and size in the json payload for the check POST. If they're blank, set them to what we currently have.
",153,True,en,0
421,3,1,0,Internals,technoweenie,2015-06-29T16:12:15Z,9,5,2,9,"This is useful if you want to run the existing tests against a specific git-lfs binary.
",88,True,en,2
420,2,0,0,Internals,technoweenie,2015-06-19T21:27:38Z,23,20,2,0,,0,False,en,0
415,14,2,2,Internals,rubyist,2015-06-29T16:13:11Z,112,14,5,10,"This PR adds full 401 support for the Batch API.
- [x] If access is not marked private, request Batch with no creds
- [x] If access is marked private, request Batch with creds
- [x] If a 401 is received, mark private, get creds, and reattempt the request

Related test server PR: https://github.com/github/lfs-test-server/pull/33
",330,False,en,1
413,6,1,0,Internals,technoweenie,2015-06-19T16:08:55Z,362,166,3,1,"This breaks up `docs/api.md` into separate files, as we start to transition the API. `docs/api/README.md` will have a high level overview of the API, and links to all the API versions.  Right now, we just have the ""v1 original"" and ""v1 batch"" APIs to describe.

I'm not incrementing the API version for the original and batch APIs since they don't affect each other. There aren't very many implementations of the original anyway. Breaking changes to existing endpoints will require new API versions and mime types. Additive changes are allowed without bumping the version.
- [x] Add API readme
- [x] Document v1 original api
- [x] Document v1 batch api
",653,True,en,0
412,3,0,0,Internals,technoweenie,2015-06-19T15:45:05Z,38,53,3,1,"This streamlines the readme a bit. The contributing link is moved up. The high level feature descriptions are delegated to the feature page. The roadmap is also streamlined, so we can use issues to discuss details of the roadmap. The main addition is a section on the first principles behind the tool at the top of the contributing doc.
",337,True,en,0
408,2,0,0,Internals,technoweenie,2015-06-19T15:38:05Z,119,77,4,1,"This is another approach at fixing #362, built on #403.

This also reorganizes the `Endpoint` code from #403 into a separate file. It can easily be pulled out into a separate PR if needed.
",189,True,en,1
406,2,2,0,Internals,technoweenie,2015-06-18T13:27:52Z,49,26,2,0,"This breaks all the tests. I see a couple options:
1. Add a switch like `--simple` for tests that excludes the versions.
2. Introduce a NEW command specifically that shows the git lfs version, git version, and git lfs env.
3. Update the tests.

Here are a couple similar commands in other cli tools:

```
# Homebrew
$ brew doctor
Please note that these warnings are just used to help the Homebrew maintainers
with debugging if you file an issue. If everything you use Homebrew for is
working fine: please don't worry and just ignore them. Thanks!

Warning: Your XQuartz (2.7.4) is outdated
Please install XQuartz 2.7.7:
  https://xquartz.macosforge.org

# rubygem
$ gem env
RubyGems Environment:
  - RUBYGEMS VERSION: 2.2.3
  - RUBY VERSION: 2.1.6 (2015-04-13 patchlevel 336) [x86_64-darwin14.0]
  - RUBYGEMS PLATFORMS:
    - ruby
...
  - GEM PATHS:
     - /opt/rubies/2.1.6-github1/lib/ruby/gems/2.1.0
...
  - GEM CONFIGURATION:
     - :update_sources => true
...
  - REMOTE SOURCES:
     - https://rubygems.org/
  - SHELL PATH:
     - /opt/boxen/rbenv/versions/2.1.6-github/bin
...
```
",1088,False,en,1
405,1,1,0,Internals,technoweenie,2015-06-17T16:27:57Z,0,173,78,0,"Fixes github/git-lfs#357
",25,True,en,0
404,2,13,11,Externals,sinbad,2015-07-06T21:26:48Z,271,17,5,19,"- Full SSH urls e.g. ssh://user@host/repo
- Custom ports in both bare and full urls
- GIT_SSH environment for alternate ssh clients
- Explicit support for plink.exe and TortoisePlink.exe

Depends on https://github.com/github/git-lfs/pull/403 (included in PR)
",259,False,en,2
403,1,9,1,Externals,sinbad,2015-06-17T20:34:51Z,27,18,1,0,"There are 2 ways to construct LFS urls - from explicit URLs and from the
clone URL (which gets info/lfs appended). Previously there were multiple
paths where the Endpoint could be constructed in a short-circuit manner
which prevents future expansion in common functions. This standardises
the Endpoint construction so it always happens via NewEndpoint, and
NewEndpointFromCloneURL performs the extra step of appending info/lfs.

This has a current effect of supporting SSH urls in all config settings,
and not just the remote clone URL as before. But mostly this is to enable
future expansion (improved SSH support)
",616,False,en,0
402,1,2,0,Externals,sinbad,2015-06-17T16:22:58Z,1,1,1,0,,0,False,en,0
401,1,0,0,Externals,michael-k,2015-06-17T16:24:55Z,20,4,3,0,"Regards #387, #399
",19,True,en,0
400,1,0,0,Internals,rubyist,2015-06-16T22:38:53Z,3,3,1,0,"Some minor cleanup from #366
- [x] Build object outside of lock
- [x] Pull URL from response instead of storing it
",115,False,en,0
399,6,1,1,Internals,technoweenie,2015-06-16T22:27:13Z,50,44,4,0,"Merges latest master into #387.
",32,True,en,0
398,6,1,2,Externals,michael-k,2015-06-16T14:51:26Z,76,14,2,0,"Fixes #397, Regards #281 
",26,True,en,1
396,1,3,0,Externals,michael-k,2015-06-15T22:13:24Z,11,2,1,0,"To reproduce the deadlock, put `runtime.Gosched()` right after `workersReady <- 1`.  The `q.authCond.Signal()` is the being sent without any worker waiting at `q.authCond.Wait()`.  Therefore all workers block at `q.authCond.Wait()` and the main goroutine blocks at `wg.Wait()` (deadlock).

Use case 1 `q.transferables` is empty:

> `<-workersReady` is not (endlessly) blocking, because the additional `go func` closes the channel.  The `q.authCond.Signal()` does not do anything.

Use case 2 `q.transferables` is not empty:

> `<-workersReady` in combination with `q.authCond.L.Lock()` blocks until at least one worker is waiting (`q.authCond.Wait()`). Therefore the `q.authCond.Signal()` signals one of the goroutines to
>   run.
> 
> The size of the channel `workersReady` makes sure that every worker that passed `q.authCond.L.Lock()` before the main goroutine does not block at `workersReady <- 1`.
",903,True,en,0
393,1,2,0,Externals,sinbad,2015-06-17T21:28:32Z,3,0,1,2,"I needed this to debug Travis issues, might be useful for someone else. Usually trying to use Travis with a fork of a golang project fails because the clone path is $fork_user/git-lfs instead of github/git-lfs which breaks package references. Note that this code should work on any golang repo owned by github, in case that's useful.
",334,True,en,0
392,2,5,0,Externals,michael-k,2015-06-15T16:52:09Z,18,24,2,0,,0,False,en,0
391,1,4,0,Externals,bozaro,2015-06-15T20:10:25Z,4,0,1,0,,0,False,en,0
387,5,0,0,Externals,michael-k,2015-06-16T22:27:15Z,48,42,4,2,"Picks up an idea by @technoweenie: https://github.com/github/git-lfs/pull/380#discussion_r32227378

Cleaned up the config on the way.
",134,True,en,0
386,1,4,0,Externals,ryansimmen,2015-07-01T20:09:57Z,167,3,4,19,"Fixes github/git-lfs#385
",25,True,en,3
384,1,1,0,Externals,michael-k,2015-06-15T20:04:44Z,2,2,1,3,"See https://github.com/github/git-lfs/pull/378#issuecomment-111231779:

> There are a couple problems that are causing the tests to deadlock.
> 
> The first one is easy, some of the download tests are doing a defer reader.Close() in a loop when it should just be closing them immediately, causing the deadlock:
",311,True,en,1
383,1,2,0,Externals,ssgelm,2015-06-17T21:30:09Z,7,3,2,5,"Thanks to the new more standard project layout we no longer need to symlink things.  I also bumped the version in preparation for #281.
",136,True,en,0
382,1,1,0,Externals,bozaro,2015-06-17T17:01:08Z,1,8,1,6,"Because Ms Windows has very expensive CreateProcess this operation takes too long time on large file count.
",108,True,en,0
381,1,8,1,Externals,bozaro,2015-06-17T16:59:18Z,30,1,3,6,"Original problem (https://code.google.com/p/tortoisegit/issues/detail?id=2518):
1. Install Git LFS (https://git-lfs.github.com/)
   - Download and unpack archive;
   - Put git-lfs.exe on any avaialble in PATH directory;
   - Run ""git lfs init""
2. Clone repository from: https://github.com/bozaro/test
3. Change image ""tux.png""
4. Show ""Git Commit"" window

On showing ""Git Commit"" window you will see black window blink for each changed LFS file (twice in this case).

You also will see black window blink on refreshing change list by F5 key.
",542,False,en,0
377,1,1,0,Externals,bozaro,2015-06-10T15:26:29Z,1,1,1,0,"This change improve git-lfs performance on Windows, becuase Ms Windows function CreateProcess is too expensive (~0.2 sec per call).
This small change reduce my test repository clone time from 4970 sec to 4352 sec (1.14X faster).
See #376 for more details.
",256,False,en,0
374,1,0,0,Externals,michael-k,2015-06-08T15:49:49Z,37,31,1,0,"Indentation is not as robust as ```.  See https://github.com/github/git-lfs/blob/afbc5818a37793ee1ea17202fde66f50975dbcb8/docs/spec.md

See https://github.com/michael-k/git-lfs/blob/spec/docs/spec.md for rendering (without diff).
",230,True,en,0
373,12,9,0,Externals,michael-k,2015-06-18T13:19:52Z,247,0,4,10,"This PR is built on #280 by @zeroshirts and #290 by @technoweenie.

I transferred the test to the new test environment. Should be enough to close #262.

@zeroshirts:
I squashed a05e331 (_Add LFS fsck command_) and 1c8c54d (_code review changes_) together and moved  `file.Close()` right after `_, err = io.Copy(oidHash, f)`.¹  I hope this is ok with you!?

¹ See comment in 2f6c3be.  If `io.Copy` fails, we still want to close the file.
",439,True,en,1
372,1,1,0,Externals,michael-k,2015-06-08T15:48:26Z,33,22,3,0,"When running test scripts and the build fails, the tests are running anyway.  This obscures the build error in case an old executable is still present.
- Return a non-zero exit status if one or more builds fail.
- Exit test with a non-zero exit status if build fails, i.e. fail test.
",284,False,en,2
370,3,4,0,Externals,michael-k,2015-06-17T16:56:42Z,132,1,2,11,"The support for config option `core.worktree` and command line options `--work-tree` and `--git-dir` is still missing.
",119,True,en,1
366,11,3,4,Internals,rubyist,2015-06-16T14:43:08Z,216,77,5,12,"I was doing some measuring today and added some code that might be generally useful with respect to some analytics functionality previously discussed.

What's in this PR is a modification of the HTTP tracing code that keeps track of the sizes and timings of every http request that goes through the default client. Once you have a response you can link it to a key in a way similar to statsd (though far less capable, at this point), e.g.:

``` go
LogTransfer(""lfs.api.upload"", res)
```

It tracks the size of both the header and body portions of the transfers, as well as the timing. The header vs body sizes can be useful for determining the point at which the HTTP overhead overtakes the file size (e.g. thousands of small files in LFS).

I'd love to be able to break down the timings into the various pieces of the http request, but that's a whole other can of worms best left for another day.

As it stands, when tracing with `GIT_CURL_VERBOSE=1`, you'll get output like this:

```
(100 of 100 files) 50.00 MB 1m22s
HTTP Transfer Stats

Concurrent Transfers: 3, Batch: false

lfs.api.upload:
  Transfers: 100
  Time: 120870.59ms
  Wire Data (Bytes): 81700
    Request Size (Bytes): 37300
      Headers: 28500
      Bodies: 8800
    Response Size (Bytes): 44400
      Headers: 12700
      Bodies: 31700
  Mean Wire Size: 817
    Requests: 373.00
    Responses: 444.00
  Mean Transfer Time: 1208.71ms

lfs.data.upload:
  Transfers: 100
  Time: 121015.36ms
  Wire Data (Bytes): 52461500
    Request Size (Bytes): 52459800
      Headers: 31000
      Bodies: 52428800
    Response Size (Bytes): 1700
      Headers: 1700
      Bodies: 0
  Mean Wire Size: 524615
    Requests: 524598.00
    Responses: 17.00
  Mean Transfer Time: 1210.15ms


Total Transfers: 200
Total Time: 241885.94ms
```

or

```
(100 of 100 files) 50.00 MB 1m15s
HTTP Transfer Stats

Concurrent Transfers: 10, Batch: false

lfs.api.upload:
  Transfers: 100
  Time: 350577.71ms
  Wire Data (Bytes): 81700
    Request Size (Bytes): 37300
      Headers: 28500
      Bodies: 8800
    Response Size (Bytes): 44400
      Headers: 12700
      Bodies: 31700
  Mean Wire Size: 817
    Requests: 373.00
    Responses: 444.00
  Mean Transfer Time: 3505.78ms

lfs.data.upload:
  Transfers: 100
  Time: 350871.42ms
  Wire Data (Bytes): 52461500
    Request Size (Bytes): 52459800
      Headers: 31000
      Bodies: 52428800
    Response Size (Bytes): 1700
      Headers: 1700
      Bodies: 0
  Mean Wire Size: 524615
    Requests: 524598.00
    Responses: 17.00
  Mean Transfer Time: 3508.71ms


Total Transfers: 200
Total Time: 701449.13ms
```

or

```
(100 of 100 files) 50.00 MB 37s
HTTP Transfer Stats

Concurrent Transfers: 10, Batch: true

lfs.api.batch:
  Transfers: 1
  Time: 766.13ms
  Wire Data (Bytes): 41046
    Request Size (Bytes): 9204
      Headers: 291
      Bodies: 8913
    Response Size (Bytes): 31842
      Headers: 128
      Bodies: 31714
  Mean Wire Size: 41046
    Requests: 9204.00
    Responses: 31842.00
  Mean Transfer Time: 766.13ms

lfs.data.upload:
  Transfers: 100
  Time: 186513.05ms
  Wire Data (Bytes): 52461500
    Request Size (Bytes): 52459800
      Headers: 31000
      Bodies: 52428800
    Response Size (Bytes): 1700
      Headers: 1700
      Bodies: 0
  Mean Wire Size: 524615
    Requests: 524598.00
    Responses: 17.00
  Mean Transfer Time: 1865.13ms


Total Transfers: 101
Total Time: 187279.18ms
```

Some things to consider before this is a real thing:
- [x] Use a separate tracing var for it, http tracing output is messy with concurrent transfers
- [x] Probably want some mutexes around the hashes, it's kind of OK as is but a little iffy
- [x] Make double sure we're not storing extra data when not tracing

Future work could further aggregate these, send them off somewhere, make more statsd-like outputs (percentiles, sums, histograms, etc).
",3851,True,en,0
365,3,3,1,Externals,thpang67,2015-06-17T21:35:36Z,14,5,1,14,"I have updated the code to use constants in place of the 0755 along with a note about possibly using the umask of the system git-lfs is installed.
",147,True,en,0
364,1,1,0,Externals,michael-k,2015-06-02T21:15:21Z,5,5,1,0,"Closes #363
",12,True,en,0
361,4,1,0,Externals,michael-k,2015-06-03T15:52:35Z,58,14,3,1,"Also fixed a typo and added missing env tests.

All config/env related and therefore bundled in one PR.
",104,True,en,1
358,5,1,7,Internals,rubyist,2015-06-15T20:15:16Z,150,22,7,14,"The batch endpoint is still ""experimental"" and a server may not yet support it. It is off by default in the client, but if gets turned on it should fall back to individual processing if the batch processing throws an error.
",224,True,en,2
356,13,1,0,Externals,michael-k,2015-06-01T14:54:12Z,166,39,3,0,"- Improved detection of duplicate paths
- Writes relative paths to `.gitattribute` files; fixes #230
- Don't track file outside the repository
",143,False,en,2
354,6,1,0,Externals,michael-k,2015-06-01T14:53:11Z,71,21,4,2,"Exposes and fixes #353 
",24,True,en,2
352,2,1,0,Externals,michael-k,2015-05-29T23:44:12Z,22,13,3,0,,0,False,en,1
351,3,0,3,Externals,michael-k,2015-05-29T23:49:10Z,27,16,2,0,"Also improved submodules test
",30,True,en,1
349,1,1,0,Internals,rubyist,2015-05-29T16:15:41Z,39,39,3,0,"Fetch is a more appropriate name for the command.
",50,True,en,0
348,1,0,0,Internals,rubyist,2015-05-29T15:24:34Z,15,13,1,0,"Add braces around the objects in example json response.
",56,True,en,0
346,2,1,0,Internals,technoweenie,2015-05-29T16:41:24Z,20,3,3,0,"Git LFS is not intended for zero length files, but it should handle them properly at least.
",92,True,en,1
342,3,0,0,Internals,technoweenie,2015-05-27T20:04:45Z,4,16,3,0,"Some minor things I missed from #336:
- [x] speed up `script/test`.  The old command tests are gone in favor of the shell tests, so we don't have to compile again.
- [x] Do we need to run the global `git config` commands anymore? I don't think so...
- [x] minor tweaks to `test-happy-path.sh`
",293,False,en,1
340,1,2,0,Internals,rubyist,2015-05-28T15:55:48Z,2,0,1,1,"Add a note in CONTRIBUTING about accepting the CLA.

:warning: This cannot be merged yet :warning:

@bkeepers is going to add an appropriate route to the CLA app, once that's done we can merge this.
",199,True,en,0
339,3,1,0,Internals,rubyist,2015-05-28T15:56:07Z,9,1,2,1,"If git-lfs does not exist (e.g. it has been uninstalled) the pre-push hook should still exit cleanly so the push can continue. The script will output a warning stating that the repo has been set up for Git LFS but that it is not installed.

/cc #333 
",251,True,en,1
336,14,4,0,Internals,technoweenie,2015-05-27T19:57:22Z,887,1494,25,0,"This moves all the tests from the `commands` package to the new shell tests. 
- [x] clean
- [x] env
- [x] init - I removed these tests because they test that the global git config is updated. I don't want tests to modify existing global git configs.
- [x] ls-files
- [x] pointer
- [x] pre-push
- [x] push
- [x] smudge
- [x] status
- [x] update
- [x] version - also removed, since every test run calls this
",406,False,en,24
335,2,0,0,Internals,technoweenie,2015-05-26T15:56:36Z,15,19,2,0,"This hacks `$HOME` so it's set to a temporary `./test/remote` dir.  This way we can create a `$HOME/.gitconfig` for common Git settings. The helpers don't have to create a separate git config file for every remote repo. This should also override any system wide or user git config settings that may affect tests.  See http://git-scm.com/docs/git-config#FILES
",359,True,en,2
332,4,5,0,Externals,andyneff,2015-06-17T21:26:56Z,515,0,11,22,"A set of RPMs that will build git-lfs on CentOS 5, 6, and 7 for #328. A build_rpm.bsh script is included to basically automate installing (and build in the case of CentOS 5 and 6) the build dependencies, and build the git-lfs rpm and srpm
",239,True,en,0
331,15,7,0,Internals,technoweenie,2015-05-28T20:42:22Z,3123,208,179,3,"Trying Nut out.  I like the simpler config file. Unfortunately, it doesn't seem to be rewriting the imports for me.  https://github.com/jingweno/nut/issues/24
",159,True,en,23
329,1,3,0,Externals,joerg,2015-05-25T14:05:40Z,1,1,1,0,"I tried implementing an LFS Server in JAVA and came up with this issue. According to https://tools.ietf.org/html/rfc5987, it has to always be ""key = value"". I also tried this change and my implementation now works (or at least I am one small step further).
",257,True,en,0
327,2,0,0,Internals,technoweenie,2015-05-22T22:19:06Z,31,10,3,0,".gitattributes needs spaces in paths replaced with `[[:space:]]`

Fixes #298
",77,True,en,2
323,6,0,2,Internals,technoweenie,2015-05-22T21:54:39Z,96,106,4,1,"This moves the track command's tests to the shell scripts.  It also fixes #294, taking the feedback into account.
",114,True,en,3
321,3,0,0,Internals,technoweenie,2015-05-21T21:26:03Z,15,4,4,0,"This adds a couple new env vars for integration tests:
- `GIT_LFS_TEST_DIR` sets an alternate tmp dir for tests.  Ideally tests run outside of the git-lfs (or any) repository.
- `GIT_LFS_TEST_MAXPROCS` tells `xargs` how many tests to run in parallel.

EDIT: I was unable to get #294 to fail in the new test suite, and realized it was because they were running inside the Git LFS project directory.  Though this is fine for most uses, I think CI systems and possibly core Git LFS devs should export better settings for these env vars.  For instance, it may make sense to turn maxprocs down on Travis, which has just 2 cores. 
",625,False,en,2
319,4,0,0,Internals,technoweenie,2015-05-21T17:55:14Z,57,6,4,0,"Adds a failing test on top of https://github.com/github/git-lfs/pull/312 using the new test suite (#306).
",106,True,en,2
315,1,2,0,Externals,sinbad,2015-05-19T14:16:27Z,1,1,1,0,,0,False,en,0
313,10,9,0,Externals,andyneff,2015-06-17T21:26:37Z,98,19,2,30,"The build script for CentOS could not build the man pages on CentOS 6 since ruby 2 is not available. However, there is a way to get ruby via the RVM. That has been added in so that CentOS 6 can build the man pages using this script

Getting golang on CentOS 5 isn't really a ""supported"" idea, but I looked into a number of work arounds and settled on the simplest one. I saw it mentioned in the comments and gave it a try. If you would rather say NO to CentOS 5, I can remove that, but I can also say that this will build and run git-lfs on a a CentOS 5 Machine (Tested on a 5.11 VM).

Also add the ability to use a currently cloned version of git-lfs, so it does not always clone into /tmp
",691,True,en,0
312,1,3,0,Externals,michael-k,2015-05-21T17:55:16Z,10,1,1,4,"Fixes #310

`filepath.Abs()` created `absDir` based on the current working directory.
",86,True,en,0
311,1,1,0,Externals,michael-k,2015-05-16T13:28:00Z,8,4,1,0,"This also keeps the usages of variable 'start' close together.
",63,True,en,0
309,2,9,0,Externals,ssgelm,2015-05-21T20:14:09Z,73,0,9,6,"This adds support for building a debian package.  I believe there should be some documentation on building the package still.  Where would you like that to go?

Package can be built by running `dpkg-buildpackage -us -uc` from the root of the repo.  It is currently confirmed to work on Debian jessie and wheezy. On wheezy it requires `wheezy-backports` versions of `dh-golang`, `git`, and `golang`.
",399,True,en,0
306,30,12,5,Internals,technoweenie,2015-05-21T17:15:34Z,839,1,11,6,"Code spike to see if https://github.com/github/git-lfs/pull/291 would work better with shell scripts.  The main rationale is that these aren't Go tests, so running them with the ""testing"" package isn't necessary.  Some of the tests will rely heavily on `os.Chdir()`, which affects the entire process.  Even with goroutines, there's no guarantee that parallel tests won't run in the same process.  Just running #291 with any kind of concurrency leads to weird errors.

Hopefully we can get around cross platform shell issues by using the common commands supported everywhere, and implement others in tiny Go commands.  For instance, a command like `lfstest-gitserver` could spin up an HTTP server that responds to Git and Git LFS calls that tests use.
",751,True,en,6
305,7,1,0,Externals,michael-k,2015-05-15T14:47:31Z,35,32,1,0,"My changes are mostly refactoring.  Non-refactoring changes are:
- Don't return a file name we didn't write to eb12f25
- Write error to stderr, even if os.MkdirAll fails e8c6175

The cases where `os.MkdirAll` and `os.Create` fail, are (still) handled differently and I'm not sure if this was intended in the first place. (The previous code didn't make it that obvious.) Please review.
",385,False,en,0
303,3,1,0,Internals,technoweenie,2015-05-14T14:41:20Z,77,42,31,0,"This updates `script/fmt` to use `goimports` instead of the built-in `gofmt`.  The main benefit here is that it organizes the import statements with stdlib packages above the 3rd party libs.  The main change is in [`script/fmt`](https://github.com/github/git-lfs/compare/goimports?expand=1#diff-f9a8d86d11fc6a80a862480ab36f3941) itself:

``` diff
+hash goimports 2>/dev/null || {
+  echo ""Installing goimports""
+  echo ""go get golang.org/x/tools/cmd/goimports""
+  go get golang.org/x/tools/cmd/goimports
+}
+
 # don't run gofmt in these directories
 ignored=(/bin/ /docs/ /log/ /man/ /tmp/ .vendor)
 for i in */ ; do
   if [[ ! ${ignored[*]} =~ ""/$i"" ]]; then
-    gofmt -w -l ""$@"" ""${i%?}""
+    goimports -w -l ""$@"" ""${i%?}""
   fi
 done
```

Is this valid, or should this fall back to `gofmt`?  `gofmt` respects the import style that `goimports` forces, so we won't have to worry about competing code formatting tools.
",920,True,en,9
300,14,8,1,Externals,michael-k,2015-05-13T19:25:02Z,108,102,12,1,"This is my first contribution to this project, so I'm not sure what's appreciated and what's not. Please let me know. I'm happy to change the PR in any way necessary.

As I worked myself through the codebase I made some changes to the codestyle and did some minor refactoring (switched if-else; returned nil as payload with error). I split it in small commits to make it easier to follow.
",389,True,en,0
299,5,1,1,Externals,jsh,2015-05-13T16:48:49Z,92,46,4,1,"Add instructions for CentOS7, and some missing steps for Ubuntu 14.04.
",71,True,en,0
285,38,12,7,Internals,rubyist,2015-05-28T16:50:32Z,1178,242,24,23,"This PR allows the LFS client to batch its upload and download operations.

Typically, the client has to ask the server about each object it wants to upload or download, resulting in many http round trips. This causes significant delay when dealing with a large amount of objects.

This PR proposes a change to the API that provides a batch endpoint that gives the client information about a number of objects at once.

The client will `POST` an array of oid/size objects to the batch endpoint, and the endpoint will return an array of link relations for each object asked about. The presence or absence of any of the `download`, `upload`, and `verify` relations can be used to determine the state of the object.
- `download` present - server has and has verified the object
- `upload` present - server does not have the object, client can upload and follow `verify` (if given)

TODO:
- [x] Spec the batch endpoints
- [x] Upload queue can work with batch endpoint
- [x] Add a `get` command to bulk download
",1007,True,en,8
283,1,2,0,Externals,catphish,2015-05-05T15:31:38Z,1,1,1,0,"Trailing periods after filenames cause copy-paste annoyance. Please consider removing this or reformatting the message.

Apologies in advance if I'm ignoring a practise that exists throughout the rest of Git.
",209,True,en,0
277,2,1,0,Externals,ddanier,2015-05-22T22:22:11Z,2,2,1,20,"While playing with https://github.com/ddanier/django-git-lfs I noticed the documentation for the href attribute is a bit off. If you point git-lfs to /objects it will produce /objects/objects. So the correct URL may not contain ""objects"". This commit fixes this documentation issue.
",283,True,en,0
274,3,2,0,Internals,technoweenie,2015-04-30T16:03:11Z,46,0,2,0,"This brings over the items from #268 to a new changelog file.
",62,True,en,0
271,2,2,0,Internals,technoweenie,2015-04-29T15:32:48Z,288,29,4,0,"This teaches `git lfs clean` to pass Git LFS pointers straight through.  There's no point in saving a pointer of a pointer.
",124,True,en,1
267,1,0,0,Internals,technoweenie,2015-04-28T23:37:00Z,12,1,1,0,"Quick fix for #266.  It'd be nice if `smudge` could verify files as it's writing them.  But, it simply streams the contents to stdout.  By the time it's realized the file is bad, it's already written to the working directory.  Checking the file before writing to stdout could add significant time when smudging large files.
",324,True,en,0
265,1,1,0,Internals,technoweenie,2015-04-28T19:04:38Z,5,7,2,3,"@peff suggested setting diff/merge properties in `.gitattributes`.  This gives us and users a place to set custom Git LFS options for diffing and merging.  Since Git LFS has nothing for this now, it should fall back to the default diffing and merging behavior.

Note: This only affects the `git lfs track` command.  Users can still manually add the lines to `.gitattributes` with their own properties.

/cc @mhagger too.
",421,True,en,1
264,1,1,0,Internals,technoweenie,2015-04-24T21:32:27Z,14,1,6,0,"This fails fast in a few commands (`clean`, `smudge`, `pointer`, and `push`) if they expect STDIN, but don't get it.  This commonly happens in `clean` and `smudge` commands if users run them interactively.

Fixes #210
",218,True,en,1
263,10,1,0,Internals,technoweenie,2015-04-28T22:02:09Z,588,141,13,4,"As discussed in https://github.com/github/git-lfs/pull/228, the push command actually has two modes:

```
# run by a user
$ git lfs push origin master

# run by pre-push hook
$ echo ""refs/heads/master {local-sha1} refs/heads/master {remote-sha1}"" | git lfs push origin https://github.com/some/repo
```

This PR splits them apart into separate commands, and updates the docs.  The old functionality in `push` is kept, until we can safely roll pre-push updates out.
",464,True,en,4
258,21,11,6,Internals,rubyist,2015-04-30T15:53:19Z,553,241,29,7,"This PR will add support to allow uploads to happen concurrently.
- [x] Create an upload queue
- [x] Synchronize initial `git config` call
- [x] Synchronize first credentials access
- [x] Display all upload errors
- [x] Add a configuration option with a sensible default
- [x] Nicer progress output
- [x] Docs
- [x] Fix all the TODOs I added
",342,False,en,5
257,1,1,0,Internals,technoweenie,2015-04-22T21:57:05Z,8,0,1,0,"This would've made #209 super easy to troubleshoot.

```
$ GIT_TERMINAL_PROMPT=0 git push dev master
Uploading droidtocat.gif
Change the GIT_TERMINAL_PROMPT env var to be prompted to enter your credentials for https://some-git-lfs-server.com
```

/cc @kevinSuttle
",264,True,en,0
252,1,3,0,Internals,bkeepers,2015-04-22T19:46:37Z,2,0,1,2,"to make it a little easier to discover.
",40,True,en,0
247,3,1,0,Internals,technoweenie,2015-04-24T17:58:35Z,26,26,3,4,"/cc #242 @ddanier

I'm keeping the issue open until we can figure out how to securely cache the tokens.
- [x] Update client to look for the `href` property
",156,True,en,0
246,16,3,9,Internals,technoweenie,2015-04-24T17:58:00Z,540,117,11,4,"Tightens up the pointer spec according from @swisspol in https://github.com/github/git-lfs/issues/233 and https://gist.github.com/swisspol/b9856fcca81029efb960.
- [x] implement git pointer commands
",198,False,en,4
245,2,0,0,Internals,technoweenie,2015-04-20T16:45:45Z,9,1,2,0,"As I was going through the spec, I realized that `git-lfs` actually reads the config values in backwards.  Local git config values should always overwrite `.gitconfig`.
- [x] Fix the implementation in the code
",210,False,en,0
244,1,0,0,Internals,technoweenie,2015-04-20T16:33:51Z,5,5,1,0,"Closes #236 /cc @borromeotlhs

Also removed some old bits about the clean filter queueing the file to be uploaded.  The local queue was removed long ago in favor of scanning the commit range in `pre-push`.
",206,True,en,0
241,1,0,0,Internals,rubyist,2015-04-17T13:30:13Z,1,0,1,0,"From #231
",10,True,en,0
240,1,1,0,Internals,rubyist,2015-04-17T13:13:45Z,2,2,1,0,"Corrects some configuration documentation, reported in #239
",60,True,en,0
237,1,1,0,Internals,technoweenie,2015-04-16T16:08:42Z,11,11,3,0,"Fixes #206

```
$ git config remote.master.lfs_url whatever
error: invalid key: remote.master.lfs_url
```
",106,True,en,1
235,1,1,0,Internals,mhagger,2015-04-15T12:35:50Z,1,1,1,0,"Properly quote the arguments that are passed to `git lfs push --stdin` just in case they contain any shell metacharacters.
",123,True,en,0
232,2,2,0,Internals,technoweenie,2015-04-16T15:34:54Z,39,0,1,1,"Here are the high level ideas we're thinking of for future releases of Git LFS.  Nothing is final until it's merged into master.  
",131,True,en,0
228,13,4,0,Internals,mhagger,2015-04-20T17:42:22Z,80,68,11,7,"See the individual commit messages for details.

Another thing that might be wrong but I'm not sure: The manpages for [`git-lfs-ls-files`](https://github.com/github/git-lfs/blob/master/docs/man/git-lfs-ls-files.1.ronn) and [`git-lfs-push`](https://github.com/github/git-lfs/blob/master/docs/man/git-lfs-push.1.ronn) both talk about ""refspecs"". In Git, a refspec is a specific thing: a mapping between remote references and local references, typically with a form like

```
refs/heads/*:refs/remotes/origin/*
```

The `git-lfs-push` manpage says that the command can be invoked with arguments `<repo> [refspec]`. It is not clear, but I suppose that `<repo>` should be the name of a remote repository, so it should probably be called `<remote>`. Is `refspec` is a refspec as described above?

The `--stdin` documentation for the same command is confusing because it says that it ""read[s] the repo and refspec on stdin"". But according to `githooks(5)`, the input to a `pre-push` hook is

```
<local ref> SP <local sha1> SP <remote ref> SP <remote sha1> LF
```

There is no ""repo"" in this input, nor is there a refspec, though I suppose `git-lfs-push` could infer those from the input plus values in the configuration. I'm puzzled.

The other manpage that refers to refspecs is the one for `git-lfs-ls-files`. From the text, it sounds like what is really meant here is not ""refspec"" but ""reference"" (or maybe ""remote""?) or even ""commit"" or (to use Git's technical jargon) ""commit-ish"". But it's not really clear.

Both of these manpages would be improved by examples.
",1564,True,en,0
225,5,1,0,Externals,thekafkaf,2015-04-15T12:47:30Z,5,0,1,4,,0,False,en,0
223,1,2,0,Externals,PeterDaveHello,2015-04-10T23:47:00Z,1,1,1,0,"cc c7b71c1
",11,True,en,0
221,1,0,0,Internals,rubyist,2015-04-10T23:35:51Z,7,8,2,0,"Remove some media refs, from #216
",34,True,en,0
218,2,1,0,Externals,thekafkaf,2015-04-10T19:33:47Z,2,2,1,0,"Two really tiny changes, bumped into them while reading the code, said ""why not?"".
Have a great day!
",101,False,en,0
215,1,3,0,Externals,Mistobaan,2015-04-28T23:34:08Z,10,1,1,18,"See [Article](http://biasedbit.com/blog/golang-custom-transports/)
",67,True,en,0
213,2,3,0,Internals,rubyist,2015-04-14T23:54:35Z,25,1,1,4,"Will fix #211 

/cc @bkeepers 
",31,True,sv,0
212,2,7,0,Externals,rtyley,2015-04-15T12:40:32Z,8,3,1,4,"I'd only read the LFS spec, and not the code - thanks to @mhagger for setting me straight last night at the Git Birthday Party! The support I'm trying to put into the [BFG](https://rtyley.github.io/bfg-repo-cleaner/) has to put files in the same place as the Git LFS client, obviously - I got it [wrong](https://github.com/rtyley/bfg-repo-cleaner/blob/git-lfs-alpha/bfg-library/src/main/scala/com/madgag/git/bfg/cleaner/LfsBlobConverter.scala#L78) because I didn't check the implementation:

https://github.com/github/git-lfs/blob/a0d389385/lfs/lfs.go#L44
https://github.com/github/git-lfs/blob/a0d389385/commands/smudge_test.go#L54-L55
",637,True,en,0
205,1,3,0,Externals,PeterDaveHello,2015-04-10T15:48:51Z,1,1,1,0,,0,False,en,0
194,3,2,0,Externals,mattn,2015-04-09T15:52:26Z,2,2,3,0,"Hope to install client with `go get`

```
go get github.com/github/git-lfs/cmd/git-lfs
```
",91,True,en,0
192,1,3,1,Externals,pborreli,2015-04-08T23:59:39Z,2,2,2,0,,0,False,en,0
191,1,1,0,Internals,bkeepers,2015-04-08T20:59:13Z,0,1,1,0,"The build failures were actually caused by the git config issue that was fixed later in #181.
",94,True,en,0
189,1,2,0,Externals,lucaswerkmeister,2015-04-08T19:35:52Z,1,1,1,0,,0,False,en,0
188,1,2,0,Externals,fj,2015-04-08T21:02:08Z,1,1,1,0,"It's not clear from the documentation that `size` is in bytes, since it's only described as ""an integer"".
",106,True,en,0
187,1,1,0,Internals,leereilly,2015-04-08T18:16:30Z,2,2,1,0,"Filing this under `#extremeNitPicking`:

![image](https://cloud.githubusercontent.com/assets/121322/7051136/d5684d4e-ddda-11e4-907d-3b53f11b2576.png)

/cc @github/assets 
",171,True,en,0
186,4,6,0,Externals,chrissiebrodigan,2015-04-08T16:49:52Z,0,2,1,0,"Based on the pre-release findings, there's a likelihood that people will download the client and try to use it with GitHub immediately and fail. Let's reduce potential support load by being explicit. :sparkles: 

/cc @tclem @bkeepers @technoweenie 
",249,True,en,0
185,2,1,0,Internals,technoweenie,2015-04-15T12:49:19Z,2,0,2,6,"Somehow left this `Finish()` call out in the client rewrite for v0.5.x.  

```
[master 6bc3a3b] booya
 1 file changed, 1 insertion(+), 1 deletion(-)
Uploading test1.dat
19.07 MB / 19.07 MB  100.00 %
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 363 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
```
",406,True,en,0
184,4,1,0,Internals,leereilly,2015-04-07T16:47:53Z,7,7,3,0,"Simply replaces a few references to `Hawser` in man pages and test code comments with `Git LFS` :boom:

/cc @technoweenie 
",123,True,en,2
183,7,0,0,Internals,technoweenie,2015-04-08T03:37:19Z,183,43,6,4,"- [x] get ssh working
- [x] add docs
",37,False,nl,1
181,5,3,0,Internals,bkeepers,2015-04-08T20:34:11Z,10,0,2,13,"This configures Travis CI according to http://docs.travis-ci.com/user/languages/go/

We won't be able to test this until the repository is public, so we can wait to merge this at that time.
",190,True,en,0
180,3,2,0,Internals,technoweenie,2015-03-22T16:11:13Z,11,7,4,1,"I didn't remember why we left this out.  This PR outputs the following:

```
$ g clone https://github.com/hawser/hawser-test
Cloning into 'hawser-test'...
remote: Counting objects: 115, done.
remote: Total 115 (delta 0), reused 0 (delta 0), pack-reused 115
Receiving objects: 100% (115/115), 12.90 KiB | 0 bytes/s, done.
Resolving deltas: 100% (9/9), done.
Checking connectivity... done.
6.34 MB / 6.34 MB  100.00 % ss
Downloaded mp4/HoloLensMars.mp4
2.25 MB / 2.30 MB  97.96 % % 1s
Downloaded mp4/video.mp4
169.31 KB / 190.00 KB  89.11 % 
Downloaded psd/octicons-bg.psd
```

That's better, but the progress output is a little weird.  There are some leftover artifacts (extra %'s), and only 1 file got to 100%.  

@rubyist reminded me that we [went down this road already](https://github.com/hawser/git-hawser/pull/31).  The main difference I see between my output and his is the ""Checkout out files"" message.

(without progress)

![](https://f.cloud.github.com/assets/143/2403434/ac8d96ee-aa2e-11e3-9658-036d24c513be.gif)

(with progress)

![hotmess](https://f.cloud.github.com/assets/143/2403471/3e106b50-aa2f-11e3-9711-d5aca55bf53a.gif)

When both Git and Hawser are writing to stderr, the output gets jumbled.  

@mhagger: Any thoughts why some clones print out that ""Checking out files"" message, when others do not?  I thought it was a Git client version difference, but @rubyist doesn't see the message every time.  
",1423,True,en,0
176,2,0,0,Internals,technoweenie,2015-03-19T17:43:47Z,42,0,1,13,"This attempts to fix the case where you can't push if the objects aren't in your `.git/hawser/objects` directory.  Normally they should be there:
- Objects are downloaded to `.git/hawser/objects` as their pointers go through the smudge filter on checkout.
- When objects are added, they go through the clean filter which writes the files to `.git/hawser/objects`.

If the `.git/hawser/objects` directory gets into a weird state (for example, if the user manually removed some files in there), this attempts to re-clean the objects based on the git repository file path.
",570,False,en,0
175,13,3,0,Internals,technoweenie,2015-03-05T21:46:48Z,132,37,3,0,"This encapsulates the tracerx pattern for http calls.  

``` go
// old pattern, on every http call
tracerx.Printf(""api_put: %s %s"", oid, filename)
res, wErr := doRequest(req, creds)
tracerx.Printf(""api_put_status: %d"", res.StatusCode)
```

This has two issues:
1. The status code is explicitly printed on _every_ http call.
2. The request url isn't traced.

This PR wraps it up in `DoHTTP()`.  Also, renaming `doRequest()` to `doHTTPWithCreds()` so it's clear why it's a separate function.

EDIT: This PR also adds support for `GIT_CURL_VERBOSE`.

This also means we can add the verbose curl tracing for #172 in `DoHTTP()`.
",624,True,en,0
174,13,17,8,Internals,technoweenie,2015-03-19T17:39:52Z,106,106,2,20,"This removes all of the older endpoints and redirection stuff.  The Hawser API is now a simple JSON API, using hypermedia to control the client.  

[rendered](https://github.com/hawser/git-hawser/blob/simplify-api/docs/api.md)
",227,True,en,0
173,5,1,0,Internals,technoweenie,2015-03-05T18:30:40Z,202,72,4,7,"2dd5983841bc4231c15d80cb06e700bcbb032456 teaches `hawser.Download()` how to follow a download hypermedia link.  Since only a new test is added, this should continue to work with our various pre-release servers.  

There's a few minor refactors before that commit too.

I know `client.go` is pretty gnarly now.  It should look a lot better by v0.5.0 when we drop all the pre-release stuff :)
",391,True,en,3
168,2,1,0,Internals,technoweenie,2015-02-18T15:44:06Z,74,3,3,0,"A couple quick things:
1. Use the correct `*http.Request` value when creating the verify callback request in `callExternalPut()` /cc @rubyist
2. Add a line break to `.gitattributes` if it needs one /cc @gjtorikian 
",215,False,en,1
166,3,2,0,Internals,technoweenie,2015-02-17T19:55:26Z,142,35,3,0,"This renames `clientRequest()` to just `request()`, and extracts the credential-grabbing stuff to `setRequestHeaders()`.  `setRequestHeaders()` works on a `*http.Request`, so it can be used on the external put and verify calls.  It forces the hawser User Agent, and sets the Authorization header according to the git credentials _unless_ the `*http.Request` already has an Authorization header.

This should work in the following scenarios:
## Scenario: Accepting PUT to the Git Media API

```
POST https://my-media.com/objects
{
  ""_links"": {
    ""upload"": {""href"": ""https://my-media.com/objects/OID""}
  }
}

# no Authorization header, so get git credentials for ""my-media.com"" before making the PUT.
```
## Scenario: Redirecting PUT to external site

```
POST https://my-media.com/objects
{
  ""_links"": {
    ""upload"": {
      ""href"": ""https://other-media.com/objects/OID"",
      ""header"": {
        ""Authorization"": ""Token whatever""
      }
    },
    ""verify"": {
      ""href"": ""https://my-media.com/objects/OID/verify""
    }
  }
}

# The upload request has an Authorization header, so no git credentials are queried or saved for ""other-media.com"".
# Verify request has no Authorization header, so it uses git credentials for ""my-media.com""
```
",1248,True,en,2
165,5,0,0,Internals,technoweenie,2015-02-17T19:56:18Z,220,77,5,0,"This annotates `*hawser.WrappedError` with a `Panic` bool field.  When enabled, the `git hawser` command will dump the error to stderr and log the stack trace in the hawser logs.  Common HTTP 4xx errors don't warrant a panic though.  They should respond with a simple error:

```
$ git push origin test-1 
Authorization error: https://github.com/hawser/hawser-foo.git/info/media/objects/d1c8fab51418ef587fcf5dd8e73c60b9700704e2f8f5292ea12ec27c285b23a3
Check that you have proper access to the repository.
```
",509,True,en,2
163,4,4,0,Internals,technoweenie,2015-02-17T16:39:32Z,225,93,7,3,"Adds support for following redirections on downloads.  This works by defining `hawser.DoHTTP()` (zomg please suggest a better name) which selects an `*http.Client` based on the request method.  

Once we can remove the redirection hack for GitHub Enterprise 2.1 (https://github.com/hawser/git-hawser/pull/153), we can remove the custom `CheckRedirect`.
",353,True,en,4
162,3,1,0,Internals,technoweenie,2015-02-13T23:22:32Z,244,250,5,0,"This PR addresses some things that have come up while implementing the server.
1. ""callback"" is a generic term.  This PR renames the link relation to ""verify"" to describe what it does.
2. Instead of returning a 201 a successful preflight POST request, return a 202 to say ""your request is good, now send the file to the 'upload' link relation"".
3. Removed ""status"" and ""body"" from the verify callback.  Not sure what use they had.  Also added ""size"".
",451,False,en,3
161,5,2,4,Internals,technoweenie,2015-02-13T16:40:17Z,192,187,8,0,"- Merge the hawserclient package into hawser.
- Simplify the client interface to just Download() and Upload().
- Un-export the other client functions.
- Move ObjectUrl() to a function on *hawser.Configuration.

/cc @rubyist
",224,False,en,3
160,9,1,0,Internals,technoweenie,2015-02-12T16:16:50Z,585,53,5,0,"Adds some much-needed tests to the `hawserclient` package.  We should really add way more though :)

Based on the feedback on this PR, I want to go further with the refactoring.  Here are a few changes I'd like to make:
1. Merge the `hawserclient` package into `hawser`.
2. Simplify the client interface to just `Download()` and `Upload()`.
3. Move `ObjectUrl()` to a function on `*hawser.Configuration`.

In general, the top level `hawserclient` functions like `Get()`, `Put()`, etc bother me.  I know this is more of a cli program than a library, but it feels like those function should take the a `*hawser.Configuration` object.  For one, it would let us run the client tests in parallel.

/cc @rubyist
",706,True,en,2
158,12,20,24,Internals,joshvera,2015-02-11T21:36:05Z,48,1,1,5,"Fixes https://github.com/github/Windows/issues/3981.

/cc @niik @ammeep @shiftkey @Haacked for review. Should this be a Powershell script? Anyone know how to force the script to run in Admin mode?
",197,True,en,0
155,1,0,0,Internals,bkeepers,2015-02-03T18:12:43Z,2,4,2,0,"This just updates the links from github/hawser to hawser/git-hawser.
",69,True,en,0
154,1,4,0,Internals,technoweenie,2015-02-17T16:38:08Z,46,6,3,14,"I ran into this in QA again.  Right now `git hawser push` always defaults to the origin branch.  So it's difficult to test a single hawser-test repository against github.com and enterprise.  This patch gets the current remote from the first arg in `git hawser push`.  This is basically what Git is doing:

```
echo ""refs/heads/master OLDSHA refs/heads/master NEWSHA"" | ./git/hooks/pre-push origin https://github.com/hawser/git-hawser
```

This patch sets the `CurrentRemote` property to the first command line arg, which is `origin` in my example above.

There are cases where no remote name will be given, so it's just a URL.  Since that git config won't exist, it will fall back to `origin`.  Though I almost want to have it bail early in that case, so you're not pushing some files to an unexpected URL.
",807,True,en,1
153,1,2,0,Internals,technoweenie,2015-02-02T16:09:29Z,18,6,3,0,"This fixes an issue with the latest `git-hawser` client communicating with the old GitHub Enterprise 2.1 server.  Basically, the `POST /objects` request in the latest API spec hits the default route of the media app, which simply redirects to the GHE homepage.  This is a quick hack to treat this 302 like a 405 response.  
",324,True,en,0
152,1,6,0,Internals,technoweenie,2015-02-02T16:09:29Z,177,110,7,0,"This sets up the `add` and `remove` commands on the top level, instead of under `path`.  Since these are the most commonly used porcelain commands in Hawser, I wanted them to be easier to type.

```
# LIST PATHS
$ git hawser path 

# ADD PATH
$ git hawser add ""*.gif""

# REMOVE PATH
$ git hawser remove ""*.psd""
```

/cc @github/desktop: Just FYI. I don't think either clients ran the `git hawser path *` commands directly.
",423,True,en,1
151,25,0,2,Internals,rubyist,2015-02-01T00:18:47Z,571,551,100,1,"Operation Rename.
",18,True,en,14
150,5,1,2,Internals,rubyist,2015-01-30T15:18:57Z,193,42,2,6,"This PR will allow the client to handle the redirecting API outlined in https://github.com/github/git-media/pull/140
- [x] Work with the redirecting API
- [x] Ensure it still works with the old API
- [x] Write tests for the redirecting functions
- [x] Name the http response variable consistently :wink:

In this update, the client will attempt to make the `POST` call from the new API. If this call is made to a a server that supports the old API, the server will return a 405. In that case, the client will proceed with the old `OPTIONS`+`PUT` method of uploading assets.

The git media header verification was loosened a bit to only run when the response is of the appropriate media type. I believe this header is being phased out entirely, in the future.
",759,False,en,0
149,2,1,0,Externals,eanakashima,2015-01-16T16:33:25Z,2,5,1,0,"This way we don't have to update the README every time there's a new release. :sparkles: Also added a note about `install.sh` but wasn't sure about that one, since the script is more of a convenience than a requirement.

/cc @technoweenie @github/git-media 
",258,True,en,0
147,1,0,0,Internals,leereilly,2015-01-12T19:51:35Z,1,1,1,0,,0,False,en,0
146,1,0,0,Internals,mhagger,2015-01-12T14:29:44Z,2,2,2,0,"The links from `README.md` and from `docs/README.md` to the man pages are currently broken. They point to `man`, which is a build product that doesn't exist in the source code.

Instead, point at `docs/man`, where the source code for the man pages is located. The man pages here are not formatted beautifully, but are quite readable.

If you had more elaborate plans, for example somehow causing the man pages to be built on the server, then this PR might be inappropriate. But right now the links are broken, so _something_ should be done.
",541,True,en,0
145,2,0,0,Internals,technoweenie,2015-01-12T00:53:46Z,40,21,3,0,"Skip HTTPs verification if....
- [x] `GIT_SSL_NO_VERIFY` is set in ENV
- [x] `http.sslVerify` is set in git config
",115,False,en,1
140,11,16,15,Internals,technoweenie,2015-01-30T15:20:53Z,176,31,1,43,"This adds redirections to the Git Media API.  GET requests can return the raw data, or redirect to a new location.

[rendered](https://github.com/github/git-media/blob/redirection-proposal/docs/api.md)
1. Return the raw content.
   
   ```
   curl https://my-media.com/objects/{oid} -H ""Accept: application/vnd.git-media"" -u user:pass
   HTTP/1.1 200 OK
   Content-Type: application/octet-stream
   Content-Size: 123
   
   {object contents}
   ```
2. Redirect to a different host.  This is how GitHub's server will work.
   
   ```
   curl -L https://github.com/user/repo/objects/{oid} -H ""Accept: application/vnd.git-media"" -u user:pass
   HTTP/1.1 302 Found
   Location: https://my-media.com/objects/{oid}?token=whatever
   
   HTTP/1.1 200 OK
   Content-Type: application/octet-stream
   Content-Size: 123
   
   {object contents}
   ```

Uploads are preceded with a pre-flight request.  This request determines if the media server already has the object.

```
$ curl https://my-media.com/objects/{oid} -u user:pass \
  -H ""Accept: application/vnd.git-media""

HTTP/1.1 200 Ok
{
  ""oid"": ""abcdef"",
  ""_links"": {
    ""upload"": { ""href"": ""https://my-media.com/objects/{oid}"" }
  }
}
```

Depending on the output, the client can see (assuming authorization is valid):
- If the `oid` and `size` properties exist, without an ""upload"" link relation, the object exists on the server.
- If there is an ""upload"" link relation, the file needs to be uploaded.
- If there is a ""callback"" link relation, the client needs to POST to it after the file has been uploaded.
- [ ] Approve the spec
- [ ] Write integration tests
- [ ] Implement client code
",1640,True,en,0
139,1,0,0,Internals,rubyist,2015-01-30T15:19:51Z,4,4,2,88,"More correct concurrent access for tracers, reported in https://github.com/rubyist/tracerx/issues/1
",100,True,en,0
137,14,12,1,Internals,rubyist,2014-10-29T14:17:07Z,355,36,9,7,"`git media status` will show what would be pushed.

```
rubyist:git-media-test scott$ git media status
camb1.gif
```
- [x] Make it work
- [x] Do better than `^origin/HEAD`
- [ ] Write tests
",190,True,en,1
136,2,1,5,Internals,rubyist,2014-10-20T22:03:09Z,20,289,10,0,"- [x] Switch push over to the scanner
- [x] Remove link code and associated bits
- [x] Do some manual testing
",110,False,en,2
134,1,8,0,Internals,rubyist,2014-10-06T22:52:54Z,10,21,2,0,"On Windows, the parsing of `file://` URIs doesn't seem to handle drive letters very well. This change lets GIT_MEDIA_PROGRESS just be an absolute path. See also #133 

/cc @github/windows @github/mac for desktop client updates
",227,True,en,1
132,2,0,0,Internals,rubyist,2014-10-02T20:29:37Z,3,1,2,0,"Windows will throw an error if you're moving on top of an existing file. Reported in #131 
",91,True,en,0
130,26,11,9,Internals,rubyist,2014-10-13T15:33:15Z,506,28,12,10,"Start review [here](https://github.com/github/git-media/pull/130/files#diff-4)

Let's start scanning the repo and finding all the git media files that there have ever been!

Here's what the current prototype is based on:

```
git grep -l git-media $(git rev-list --objects --all | cut -f1 -d"" ""| git cat-file --batch-check | grep blob | cut -f1 -d"" "") | git cat-file --batch
```

It works like this:
1. Get all the objects in the repo `git rev-list --objects --all`
2. Get the size and type info for each sha1 `git cat-file --batch-check`
3. Filter out anything that is not a blob, or is over 200 bytes
4. Grep the objects for git-media pointer data `git grep -l git-media`
5. The passing objects are git media pointer files, get the contents `git cat-file --batch`

It works slightly differently in the Go code, because `git grep` cannot take a list of shas on stdin, and it'd be really easy to build a command line with too many arguments, so it runs an individual grep for each sha that is `blob && < 200 bytes`.

This works, and this first commit will print out all the git media OIDs it can find. However, I'm wondering if there are more efficient ways of doing this with fewer steps. /cc @mhagger in particular for that, since his git knowledge is supreme.

Once we have these OIDs, I think it's pretty safe to go ahead and create the link files for them, even though we may not actually have the file content. We can then provide opportunities for downloading any of the content, or various other things.
",1512,True,en,2
129,3,1,0,Internals,rubyist,2014-10-01T20:11:50Z,7,2,3,0,"If we receive no command line arguments in the push command it's because the pre-push hook is out of date.
",107,True,en,1
122,37,20,0,Internals,rubyist,2014-10-01T14:52:28Z,751,1252,36,12,"## Smarter Push

The first aspect of smarter push is removing the upload queue. Previously, whenever a git media file was cleaned (i.e. via `git add`) it was added to the upload queue. Then whenever `git push` was run, all queued files were synced. This was a problem because the git media files in the upload queue may not necessarily be in the commit(s) that are actually being pushed.

Instead of a queue, this PR keeps a database linking git's sha1 to the git media oid. This database is just a set of files under `.git/media/objects`, where the file name is the git sha1. This is similar in structure to git's own `.git/objects` database. The contents of each file contain the git media oid and the file name (if available). Future extensions could add more meta information to these files (e.g. which git media remotes it has been pushed to).
### Cleaning

With this PR, files are run through the clean filter as normal, and upon success of everything, the git media link file will be created.
### Smudging

The git media link files are also created from the smudge filter. This allows the database to be built on clone, and for new files that are synced down to be properly linked up.
### Pushing

When `git push` is run, the `pre-push` hook gets information on its command line and via stdin about the refs being pushed and where they're being pushed to. We use this information to get a list of git objects that are being pushed and look those objects up in the git media links database. If the git object has a matching git media file, that file is pushed to the git media endpoint.

There are cases where this will still attempt to push git media objects that the server already has. Before any object is `PUT` to the server, the client requests an `OPTIONS` to verify authentication. The server will now return a 200 status if it already has the file for the oid, and a 204 if it does not. In the event of a 200, the client will not send the `PUT` request.
### Updating git media config

This PR contains code that updates some git media configuration. First, the `pre-push` hook needs to be updated because the command line arguments were not being passed to git media.

Second, it will walk all of the git media objects under `.git/media` and create entries in the git media links database to ensure it's populated.

The update mechanism so far is pretty crude. I didn't want to go too far into it without some feedback, so I just got it to the point of working. I'm liking the ideas @mhagger proposed below around adding a configuration version and using that to help determine what to run or how to respond to the user in the event that something needs updated. This will likely be needed in the future if other changes are made.
### Other goodies

I've added a couple other things that were useful in building this out. There is now a `git media ls-files` and a `git media push --dry-run`. They work as such:

```
media scott$ git media ls-files
x.dat
y.dat
a/b.dat
```

This pretty much just traverses the git media link database and prints out everything it finds. A more authoritative version could be made where it's actually checking git's database for pointer files.

```
$ echo ""file 1"" > file1.dat
$ git add file1.dat
$ git commit -m ""add file 1""
[master 8332325] add file 1
 1 file changed, 3 insertions(+)
 create mode 100644 file1.dat
$ echo ""file 2"" > file2.dat
$ git add file2.dat
$ git commit -m ""add file 2""
[master bf76010] add file 2
 1 file changed, 3 insertions(+)
 create mode 100644 file2.dat
$ git media push --dry-run origin master
push file1.dat
push file2.dat
```

We have to drop to running `git media push` over `git push` because git does not pass the parameters down into the hook scripts.
## Original PR

Here are some proposals for the first steps toward a smarter push.

First, we'll nuke the queue as we currently have it. We shouldn't need this.

When the clean filter runs, e.g. on `git add <file>`, we'll clean it as normal but instead of adding it to a sync queue, we'll get the sha1 that git calculates for the pointer file.

We'll create a file under `.git/media/objects/aa/bbccddeeff00112233445566778899aabbcc`. This file will contain the git media oid. So it's kind of like git's object db, but with pointers to git media objects instead of content.

When the pre-push hook runs, we can gather a list of objects git wants to send from `git rev-list --objects`. As discussed in https://github.com/github/git-media/issues/104 this list of objects may include files we've already pushed, so we need a way to trim that down.

We can trim the list by adding a query to the server api which, given a list of git media oids will return the list of objects it doesn't know about, similar to how git negotiates what it's going to send. (Are there security implications to this? It is authenticated and scoped to the repo, so I think it should be OK.)

Once we have that list, we sync those files and continue on as normal.
- [x] Create link file when cleaning
- [x] Update pre push hook
  - [x] Get list of git objects push thinks it's going to send
  - [x] Weed out anything that doesn't have a matching link file
  - [x] Push as normal
- [x] Handle missing refs case (e.g. pushing a new branch)
- [x] Provide a `git media queues` replacement showing unsynced files
- [x] Provide a `--dry-run` option
- [x] Store filename in link file, if available. It gets displayed when pushing
- [x] Migrate any data that's in an upload queue then :skull: it
- [x] If a branch is being deleted, ensure no media objects are sent
",5565,True,en,7
120,3,5,0,Internals,rubyist,2014-09-15T22:55:16Z,13,20,3,0,"Example: `git-media/0.2.2 (darwin; git 1.9.1; go 1.3)`

The version command was using the user agent string, I left that as such and removed the redundant git version line:

```
$ ./bin/git-media version
git-media/0.2.2 (darwin; git 1.9.1; go 1.3)
```

Any other info we should add?
",283,True,en,1
119,1,1,0,Internals,rubyist,2014-09-15T15:30:02Z,2,0,1,0,"This will fix https://github.com/github/git-media/issues/116
",61,True,en,0
118,2,1,0,Internals,rubyist,2014-09-15T14:56:02Z,11,8,1,3,"There is a bug in the way the git credential helpers launch the daemon if it is
not already running such that the stderr of the grandchild does not appear to
be getting closed, causing the git media client to not receive EOF on the pipe
and wait forever.

There's more description in the related issue, https://github.com/github/git-media/issues/117
",350,False,en,0
115,1,1,0,Internals,technoweenie,2014-09-09T17:24:34Z,11,3,1,0,"The `--data-binary` flag tells curl to upload the raw binary data.  It wasn't before, so we were pushing corrupt packages.
",123,True,en,0
114,3,6,0,Internals,technoweenie,2014-09-09T17:24:38Z,29,11,6,0,"This sets a User-Agent on outgoing Git Media API requests.  It also expands the `version` command so it shows the Git and Go versions:

```
$ script/run version
git media v0.2.1 (go v1.3)
git version 1.9.1
```
",210,True,en,2
113,4,0,0,Internals,technoweenie,2014-09-08T16:04:31Z,177,17,5,2,"Add's a release script that uploads the compiled binaries to the Releases API with the proper labels and everything.

![release_v0_2_1_ _github_git-media](https://cloud.githubusercontent.com/assets/21/4172990/2b738b36-3552-11e4-8764-1ac0c6f7b579.png)
",251,True,en,0
112,2,0,1,Internals,rubyist,2014-09-05T17:28:56Z,21,2,2,0,"When a file that isn't a pointer file passes through smudge it currently panics and can't proceed. If the file given to smudge cannot be recognized as a pointer file then we should just pass that data out into the file.
",220,True,en,1
111,1,2,3,Internals,shiftkey,2014-09-03T22:39:08Z,2,1,1,0,"Fixes #108 

Obligatory warning:

![](http://all-images.org/wp-content/uploads/2013/12/643917_555674231115834_703158588_n.png)

After being shouted at by the go compiler a bunch, I think I've found a better way to check for the filesystem root using a gem in the `filepath` docs:

http://golang.org/pkg/path/filepath/#Clean

> The returned path ends in a slash only if it represents a root directory, such as ""/"" on Unix or `C:\` on Windows.

Combining that with checking the last character on the file path (not the only character) _should_ catch this issue we're facing with finding the root of a Windows drive.

Thoughts?
",625,True,en,0
106,1,0,0,Internals,rubyist,2014-08-19T21:49:01Z,1,1,1,0,,0,False,en,0
105,3,0,0,Internals,technoweenie,2014-08-18T20:30:59Z,427,174,9,0,":heart: sharing code
",21,True,en,2
101,3,0,0,Internals,technoweenie,2014-08-18T16:20:24Z,107,530,11,3,"Simplify the pointer format.  Go with something that matches how Git objects look:

```
$ git cat-file -p HEAD
tree f142fb62a2c8be67161b5fc2bb4fb0ef03021d83
parent ad57cf79b332fbff40f8bd0a0babc82850e5b01c
```

This lets us remove the goini package.  Start your code review [here](https://github.com/github/git-media/compare/pointer-v3?expand=1#diff-6).
",353,True,en,4
100,3,9,0,Internals,technoweenie,2014-08-18T16:21:20Z,25,18,2,4,"The format is now:

```
{event} {index}/{totalFiles} {sentBytes}/{totalBytes} {filename}
```

One caveat: The initial entry will have 0/0 sent/total bytes.  This is because we don't always know the size ahead of time.  Should we leave that first message out then?

/cc @joshaber 
",280,True,en,1
98,19,2,0,Internals,technoweenie,2014-08-08T22:19:26Z,249,103,9,0,"Trying to fix #25 before shipping Git Media v0.2.0.
- [x] Fixed an issue with writing log files.  The `:`'s in the filename were tripping Windows up.
- [x] Made sure to close the temp file from the `clean` command before renaming it.  Windows wouldn't rename the write-locked file.
- [x] Added `*gitmedia.WrappedError` for wrapping errors with a stack trace generated closer to the error. 
- [x] Fix smudge error
- [x] confirm clean
- [x] confirm push
## OLD BOOMTOWN STACK

```
Welcome to Boomtown

Error!
/Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/commands.go:140 (0x32dd0)
    logPanic: fmt.Fprintln(fmtWriter, loggedError.Error())
/Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/commands.go:96 (0x31ff3)
    handlePanic: if err == nil {
/Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/commands.go:66 (0x31d89)
    Panic: 
/Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/command_logs.go:88 (0x2ec50)
    logsBoomtownCommand: Panic(err, ""Welcome to Boomtown"")
/Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:355 (0x3fcac)
    (*Command).execute: c.Run(c, argWoFlags)
/Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:334 (0x3fb03)
    (*Command).findAndExecute: return cmd.execute(a)
/Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:408 (0x406a0)
    (*Command).Execute: err = c.findAndExecute(args)
/Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/commands.go:75 (0x31f1a)
    Run: LoggedError(err, format, args...)
/Users/rick/github/git-media/cmd/git-media.go:8 (0x201a)
    main: commands.Run()
/usr/local/go/src/pkg/runtime/proc.c:247 (0x11d2a)
/usr/local/go/src/pkg/runtime/proc.c:1445 (0x144f0)
```
## NEW BOOMTOWN STACK

```
Error!
Inner error message!
goroutine 16 [running]:
github.com/github/git-media/gitmedia.Stack(0x0, 0x0, 0x0)
    /Users/rick/github/git-media/.vendor/src/github.com/github/git-media/gitmedia/errors.go:42 +0x89
github.com/github/git-media/gitmedia.Errorf(0x6381b0, 0xc208001550, 0x390b40, 0x6, 0x0, 0x0, 0x0, 0x576b40)
    /Users/rick/github/git-media/.vendor/src/github.com/github/git-media/gitmedia/errors.go:22 +0x4b
github.com/github/git-media/commands.logsBoomtownCommand(0x576b40, 0x57d328, 0x0, 0x0)
    /Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/command_logs.go:87 +0xf6
github.com/spf13/cobra.(*Command).execute(0x576b40, 0x57d328, 0x0, 0x0, 0x0, 0x0)
    /Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:355 +0x17c
github.com/spf13/cobra.(*Command).findAndExecute(0x577340, 0xc20800e010, 0x2, 0x2, 0x0, 0x0)
    /Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:334 +0xd3
github.com/spf13/cobra.(*Command).Execute(0x577340, 0x0, 0x0)
    /Users/rick/github/git-media/.vendor/src/github.com/spf13/cobra/command.go:408 +0x7b0
github.com/github/git-media/commands.Run()
    /Users/rick/github/git-media/.vendor/src/github.com/github/git-media/commands/commands.go:80 +0x2a
main.main()
    /Users/rick/github/git-media/cmd/git-media.go:8 +0x1a
```
",3207,False,en,0
97,18,13,2,Internals,technoweenie,2014-08-07T19:50:23Z,319,49,13,0,"Implements #95.  If an app sets the `GIT_MEDIA_PROGRESS` env, Git Media commands will write the file status to the file.  Git Media will create the directory and file if necessary.  But it is up to the calling application to cleanup the file as desired.  Git Media will append to the file if it already exists.

The file format is just `{filename} {percentComplete}`.  Git Media should always emit an entry with 0% complete.  

```
smudge 1/1 0 my-image.jpg
smudge 1/1 50 my-image.jpg
smudge 1/1 100 my-image.jpg
smudge 1/1 0 other-image.jpg
smudge 1/1 25 other-image.jpg
smudge 1/1 100 other-image.jpg
```

Some caveats:
- This relies on the `%f` flag in the clean/smudge filter definitions.  Git will pass the filename as an argument to `git media [smudge | clean]`.  Certain older Git versions won't send anything though.  In these rare cases, the OID will be used.  In the event Git Media can't even find an OID, the string `<unknown file>` is used.  This is likely a bug though.
- `smudge` and `clean` events don't know how many files are part of the current operation, so they always report ""1/1"".
- [x] stream progress updates for `smudge`
- [x] stream progress updates for `clean`
- [x] stream progress updates for `push`
",1230,True,en,4
96,1,0,0,Internals,technoweenie,2014-08-06T20:43:56Z,9,0,2,0,"Fixes #90
",10,True,en,1
94,17,21,0,Internals,technoweenie,2014-08-05T16:44:55Z,258,57,8,7,"When downloading files from the Git Media endpoint, write to a tempfile and only move to its spot in `.git/media` once we're sure it matches the SHA-256 signature.

Need to find a reliable way to test this...
- [ ] Add some self-healing when trying to work with corrupt `.git/media` files.
",290,True,en,1
93,5,2,0,Internals,technoweenie,2014-07-25T22:44:11Z,70,3,4,0,"See https://github.com/github/git-media/pull/92#issuecomment-50172043

```
# pipe an old pointer to `smudge --info`
$ git cat-file -p 4e1d2e57593994f3e1b4a8ea0e25abd19ab72984 | git media smudge --info                                                                                        
1719898 /path/to/.git/media/17/ab/17ab91cebd2972fa7f01b6e77b28c59d341534d1d8d6fffacb6f3ea9d3aabff4

# pipe an old pointer without a local file
$ echo ""# external\n17ab91cebd2972fa7f01b6e77b28c59d341534d1d8d6fffacb6f3ea9d3aabff5"" | git media smudge --info
0 --

# pipe an ini pointer
$ echo ""[git-media]\nversion=http://git-media.io/v/2\noid=sha256:17ab91cebd2972fa7f01b6e77b28c59d341534d1d8d6fffacb6f3ea9d3aabff4\nsize=1719898\n"" | git media smudge --info
1719898 /path/to/.git/media/17/ab/17ab91cebd2972fa7f01b6e77b28c59d341534d1d8d6fffacb6f3ea9d3aabff4

# pipe an ini pointer without a local file
$ echo ""[git-media]\nversion=http://git-media.io/v/2\noid=sha256:17ab91cebd2972fa7f01b6e77b28c59d341534d1d8d6fffacb6f3ea9d3aabff5\nsize=1719898\n"" | git media smudge --info
1719898 --
```
",1076,True,en,1
91,4,0,0,Internals,technoweenie,2014-07-24T20:14:41Z,22,0,11,0,"This keeps the generated man/html pages out of source control.
- Put the [ronn](http://rtomayko.github.io/ronn/) files in docs/man.  These are mostly markdown, and fit in with the rest of the docs.
- Update `script/man` to copy files to `./man`, and then build it.  
",267,False,en,0
87,12,3,3,Internals,technoweenie,2014-07-25T17:33:44Z,683,71,14,3,"Experiment to see what it'd be like to update the git media pointer format to add metadata.

EDIT: See #85 for the rationale.
",126,True,en,3
84,20,2,3,Internals,technoweenie,2014-07-24T18:05:46Z,3850,244,25,27,"I've been wanting to play with cobra for awhile.  It gives us posix compatible flag handling, and an automatic help command.

A lot of the files are part of the vendored libs.  [Skip all that noise](https://github.com/github/git-media/pull/84/files#diff-13).
",259,True,en,5
81,2,2,0,Internals,skalnik,2014-07-24T18:06:03Z,4,4,1,27,"Both work, but I figure docs should stay consistent :book:
",59,True,en,0
80,4,1,0,Internals,technoweenie,2014-06-25T17:20:29Z,11,53,7,0,,0,False,en,0
79,2,1,0,Internals,rubyist,2014-06-24T15:04:47Z,14,4,2,0,"Some updates to documentation in preparation for testing
",57,True,en,0
78,3,5,3,Internals,rubiojr,2014-06-16T15:02:09Z,43,0,1,1,,0,False,en,0
77,2,2,0,Internals,rubiojr,2014-06-14T15:43:12Z,2,2,2,0,"The default /bin/sh in some places isn't bash (like Ubuntu, dash) and
the script is using Bashisms:

```
[1005][rubiojr@octox] checkbashisms -f script/test
possible bashism in script/test line 7 (alternative test command ([[ foo
]] should be [ foo ])):
if [[ ""$#"" != ""0"" ]]; then
```

So trying to run it results in:

```
./script/test: 7: ./script/test: [[: not found
^Cexit status 2
```
",389,False,en,0
76,7,3,3,Internals,rubyist,2014-06-16T16:52:26Z,65,14,3,4,"In some cases, .git is not a directory but is a file pointing to the real .git directory. This is true in the case of submodules, and may be true for other odd set ups.

If we detect that .git is a file, see if it matches the pointer syntax and if so, use that for the LocalGitDir (and LocalMediaDir).

This should address #73 #74 and #75
",339,True,en,2
72,1,1,0,Internals,technoweenie,2014-06-12T17:37:17Z,5,4,2,6,"Seems weird having a global temp dir.  This puts it in the repository's .git directory.
",88,True,en,1
71,2,0,0,Internals,technoweenie,2014-06-05T23:18:32Z,120,13,40,0,"Adds some tests to verify #22 is fixed.
",40,True,en,3
70,1,0,0,Internals,technoweenie,2014-06-05T21:46:21Z,323,0,13,0,"Saw this while running `script/bootstrap -all`:

```
Building for windows/amd64
.vendor/src/github.com/cheggaaa/pb/pb_win.go:6:2: cannot find package ""github.com/olekukonko/ts"" in any of:
    /opt/boxen/goenv/versions/1.2.1/src/pkg/github.com/olekukonko/ts (from $GOROOT)
    /Users/rick/github/git-media/.vendor/src/github.com/olekukonko/ts (from $GOPATH)

 - cp script/install.bat.example bin/releases/windows-amd64/git-media-v0.0.1/install.bat

 - zip -j bin/releases/git-media-windows-amd64-v0.0.1.zip bin/releases/windows-amd64/git-media-v0.0.1/install.bat
  adding: install.bat (deflated 43%)
```
",603,True,en,1
69,18,0,0,Internals,technoweenie,2014-06-09T13:38:57Z,422,273,25,3,"Merged the latest master into #63.  The only conflict was in `gitmedia/logging.go`.  I just ported 2862ab18a691628c8775e9626564fafccae469db to `commands/commands.go`.
",167,True,en,7
68,4,0,4,Internals,technoweenie,2014-06-05T21:26:57Z,244,220,18,0,"Moves the logging to the `commands` package.  Need to review the changes to the core `gitmedia` package carefully.  We want more idiomatic Go code that returns errors.
",168,True,en,2
67,1,0,0,Internals,technoweenie,2014-06-05T17:26:58Z,26,0,2,0,"I'm trying to reduce how often specific git-media commands are run explicitly by users.  
",90,True,en,1
66,1,0,0,Internals,technoweenie,2014-06-05T17:20:11Z,8,22,3,0,"This doesn't configure anything.
",33,True,en,1
65,2,0,3,Internals,technoweenie,2014-06-05T14:51:51Z,61,4,6,0,"This makes the clean/smudge filters install hooks automatically.

Fixes #56
",76,True,en,2
64,2,0,0,Internals,technoweenie,2014-06-04T18:27:04Z,124,101,42,0,"This moves the tests to `./commands`.  They are now broken up by command and not the sample repository fixture.  So, there are technically more Go test methods, but the same number of `*TestCommand` instances.
",210,True,en,7
63,11,0,1,Internals,rubyist,2014-06-09T13:39:15Z,27,5,5,4,"Doing some general error handling and clean up here.

Not ready to merge yet.
",78,True,en,1
62,1,0,0,Internals,rubyist,2014-06-04T16:04:27Z,44,2,3,0,"A manual replacement of #60 which was made difficult to merge by #61 
",70,True,en,1
61,7,3,3,Internals,rubyist,2014-06-04T13:27:09Z,131,64,5,0,"This provides separate initialization paths:

If you're not in a repo, `git media init` will only run the global initialization, which is adding the filter setup to `~/.gitconfig`.

If you're in a repo, `git media init` will run the global init, and also run a repo init - which currently only calls the (empty) hook initialization.

If you run `git media init hooks`, it will run only the hook initialization.

We can easily add subcommands to this, or maybe wad the local stuff back together a bit more, in the event that I'm over-thinking this.
",548,True,en,0
59,7,1,2,Internals,rubyist,2014-06-03T18:37:06Z,82,134,32,0,"This is a first pass at removing local import paths. These are frowned upon by gophers and break a bunch of tooling. We can probably improve upon this structure a bit, but this should build and all tests should run with the existing set up (hopefully).
",253,True,en,3
58,9,2,0,Internals,technoweenie,2014-06-03T18:32:12Z,173,1,11,0,"How's this look?

Still needs
- [x] `git media path`
- [x] Add scripts for generating output with [ronn](https://github.com/rtomayko/ronn).
",140,True,en,0
